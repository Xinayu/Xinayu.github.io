<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[添加复制功能]]></title>
    <url>%2F2018%2F07%2F05%2Fhexo--%E6%B7%BB%E5%8A%A0%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[hexo自带的代码段没有复制功能，有时候不是很方便，我们使用clipboard.js完善该功能。 引入插件每个主题使用的模板语言不一样，这里以.pug为栗子cd你的博客目录，然后打开 theme -&gt; layout -&gt; _partial -&gt;head.pug，加入外链 script(type='text/javascript', src='https://cdn.bootcss.com/clipboard.js/1.5.16/clipboard.min.js') 添加按钮使用自定义标签&lt;copy&gt;代替复制按钮，一个按钮映射下面第一个代码段。为按钮设置一些CSS样式： .btn-copy&#123; float: right; cursor: pointer; width: 20px; height: 20px; color: #4ca3ff; position: relative; &amp;:before&#123; content: '\2618 '; font-size: 26px; top: -0.4em; position: absolute; right: 0.3em; &#125;&#125; 最终效果如图： 动态实现只要找到能实现全局使用的js即可cd你的博客目录，然后打开 theme -&gt; source -&gt; js -&gt;xx.js ，添加功能 //add sign for each pres$('copy').addClass('btn-copy').each(function(index) &#123; //为当前元素下的第一个代码段添加id $(this).parent(':first').nextAll('figure:first').find('pre').attr("id","pre"+(index+1)); //添加映射关系 $(this).attr('data-clipboard-target',"#pre"+(index+1));&#125;);let clipboard = new Clipboard('.btn-copy'); //初始化 因每一个主题的渲染方式存在差异，具体的元素选择也应入乡随俗 核心是一个复制按钮映射一个代码段]]></content>
      <categories>
        <category>hexo功能整合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[效果样式]]></title>
    <url>%2F2018%2F07%2F05%2FSwiper3-0-%E6%95%88%E6%9E%9C%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[整合提取各个效果对应的样式，按需所取，去除冗余 渐变样式 /* Fade */.swiper-container-fade.swiper-container-free-mode .swiper-slide &#123;-webkit-transition-timing-function: ease-out;-moz-transition-timing-function: ease-out;-ms-transition-timing-function: ease-out;-o-transition-timing-function: ease-out;transition-timing-function: ease-out;&#125;.swiper-container-fade .swiper-slide &#123;pointer-events: none;-webkit-transition-property: opacity;-moz-transition-property: opacity;-o-transition-property: opacity;transition-property: opacity;&#125;.swiper-container-fade .swiper-slide .swiper-slide &#123;pointer-events: none;&#125;.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active &#123;pointer-events: auto;&#125;.swiper-zoom-container &#123;width: 100%;height: 100%;display: -webkit-box;display: -moz-box;display: -ms-flexbox;display: -webkit-flex;display: flex;-webkit-box-pack: center;-moz-box-pack: center;-ms-flex-pack: center;-webkit-justify-content: center;justify-content: center;-webkit-box-align: center;-moz-box-align: center;-ms-flex-align: center;-webkit-align-items: center;align-items: center;text-align: center;&#125;.swiper-zoom-container &gt; img,.swiper-zoom-container &gt; svg,.swiper-zoom-container &gt; canvas &#123;max-width: 100%;max-height: 100%;object-fit: contain;&#125; 添加JS：effect:&#39;fade&#39; 3D翻转公用样式 /* 3D Container */.swiper-container-3d &#123;-webkit-perspective: 1200px;-moz-perspective: 1200px;-o-perspective: 1200px;perspective: 1200px;&#125;.swiper-container-3d .swiper-wrapper,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-cube-shadow &#123;-webkit-transform-style: preserve-3d;-moz-transform-style: preserve-3d;-ms-transform-style: preserve-3d;transform-style: preserve-3d;&#125;.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-slide-shadow-bottom &#123;position: absolute;left: 0;top: 0;width: 100%;height: 100%;pointer-events: none;z-index: 10;&#125;.swiper-container-3d .swiper-slide-shadow-left &#123;background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));&#125;.swiper-container-3d .swiper-slide-shadow-right &#123;background-image: -webkit-gradient(linear, right top, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));&#125;.swiper-container-3d .swiper-slide-shadow-top &#123;background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));&#125;.swiper-container-3d .swiper-slide-shadow-bottom &#123;background-image: -webkit-gradient(linear, left bottom, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));&#125;.swiper-container-coverflow .swiper-wrapper,.swiper-container-flip .swiper-wrapper &#123;-ms-perspective: 1200px;&#125; cube翻转 /* Cube */.swiper-container-cube .swiper-slide &#123;visibility: hidden;-webkit-transform-origin: 0 0;-moz-transform-origin: 0 0;-ms-transform-origin: 0 0;transform-origin: 0 0;width: 100%;height: 100%;&#125;.swiper-container-cube.swiper-container-rtl .swiper-slide &#123;-webkit-transform-origin: 100% 0;-moz-transform-origin: 100% 0;-ms-transform-origin: 100% 0;transform-origin: 100% 0;&#125;.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-prev,.swiper-container-cube .swiper-slide-next + .swiper-slide &#123;pointer-events: auto;visibility: visible;&#125;.swiper-container-cube .swiper-cube-shadow &#123;position: absolute;left: 0;bottom: 0px;width: 100%;height: 100%;background: #000;opacity: 0.6;-webkit-filter: blur(50px);filter: blur(50px);z-index: 0;&#125; coverflow翻转 /* Coverflow */.swiper-container-coverflow .swiper-wrapper,.swiper-container-flip .swiper-wrapper &#123;-ms-perspective: 1200px;&#125; 添加JS代码 effect : 'cube',cube: &#123; slideShadows: true, //开启slide阴影。默认 true。 shadow: true, //开启投影。默认 true。 shadowOffset: 100, //投影距离。默认 20，单位px。 shadowScale: 0.6 //投影缩放比例。默认0.94。&#125;//-------华丽的分割线------------effect : 'coverflow',slidesPerView: 3,coverflow: &#123; rotate: 30, //slide做3d旋转时Y轴的旋转角度。默认50。 stretch: 10, //每个slide之间的拉伸值，越大slide靠得越紧。 默认0 depth: 60, //slide的位置深度。值越大z轴距离越远，看起来越小。 默认100。 modifier: 2, //epth和rotate和stretch的倍率，相当于depth*modifier、rotate*modifier、stretch*modifier，值越大这三个参数的效果越明显。默认1。 slideShadows : false //阴影&#125;,centeredSlides: true,]]></content>
      <categories>
        <category>Swiper3.0手册</category>
      </categories>
      <tags>
        <tag>Swiper3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[局部组件]]></title>
    <url>%2F2018%2F07%2F05%2FSwiper3-0-%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最好不要直接直接引用完整的swiper的css文件要根据页面中是否包括滑动块（slides）、分页器(pagination)、前进按钮和动画等进行精简 前进后退按钮 /* Arrows */.swiper-button-prev,.swiper-button-next &#123;position: absolute;top: 50%;width: 27px;height: 44px;margin-top: -22px;z-index: 10;cursor: pointer;-moz-background-size: 27px 44px;-webkit-background-size: 27px 44px;background-size: 27px 44px;background-position: center;background-repeat: no-repeat;&#125;.swiper-button-prev.swiper-button-disabled,.swiper-button-next.swiper-button-disabled &#123;opacity: 0.35;cursor: auto;pointer-events: none;&#125;.swiper-button-prev,.swiper-container-rtl .swiper-button-next &#123;background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E");left: 10px;right: auto;&#125;.swiper-button-prev.swiper-button-black,.swiper-container-rtl .swiper-button-next.swiper-button-black &#123;background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E");&#125;.swiper-button-prev.swiper-button-white,.swiper-container-rtl .swiper-button-next.swiper-button-white &#123;background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E");&#125;.swiper-button-next,.swiper-container-rtl .swiper-button-prev &#123;background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E");right: 10px;left: auto;&#125;.swiper-button-next.swiper-button-black,.swiper-container-rtl .swiper-button-prev.swiper-button-black &#123;background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E");&#125;.swiper-button-next.swiper-button-white,.swiper-container-rtl .swiper-button-prev.swiper-button-white &#123;background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E");&#125;/* 改变背景 */.swiper-button-next,.swiper-button-prev&#123; width: 0.65rem; height: 0.65rem; background:url(//game.gtimg.cn/images/cqby/cp/a20180110bycjm/arrow.png) no-repeat center; background-size: 100%&#125;.swiper-button-prev&#123; background:url(//game.gtimg.cn/images/cqby/cp/a20180110bycjm/arrow2.png) no-repeat center; background-size: 100%&#125; 分页器 /* Pagination Styles */.swiper-pagination &#123;position: absolute;text-align: center;-webkit-transition: 300ms;-moz-transition: 300ms;-o-transition: 300ms;transition: 300ms;-webkit-transform: translate3d(0, 0, 0);-ms-transform: translate3d(0, 0, 0);-o-transform: translate3d(0, 0, 0);transform: translate3d(0, 0, 0);z-index: 10;&#125;/* Common Styles */.swiper-pagination-fraction,.swiper-pagination-custom,.swiper-container-horizontal &gt; .swiper-pagination-bullets &#123;z-index: 3;bottom: 14px;left: 0;width: 100%;&#125;/* Bullets */.swiper-pagination-bullet &#123;display: inline-block;border-radius: 100%;background: #000;opacity: 0.2;&#125;button.swiper-pagination-bullet &#123;border: none;margin: 0;padding: 0;box-shadow: none;-moz-appearance: none;-ms-appearance: none;-webkit-appearance: none;appearance: none;&#125;.swiper-pagination-clickable .swiper-pagination-bullet &#123;cursor: pointer;&#125;.swiper-pagination-white .swiper-pagination-bullet &#123;background: #fff;&#125;.swiper-pagination-bullet-active &#123;opacity: 1;background: #007aff;&#125;.swiper-pagination-white .swiper-pagination-bullet-active &#123;background: #fff;&#125;.swiper-pagination-black .swiper-pagination-bullet-active &#123;background: #000;&#125;.swiper-container-vertical &gt; .swiper-pagination-bullets &#123;right: 10px;top: 50%;-webkit-transform: translate3d(0px, -50%, 0);-moz-transform: translate3d(0px, -50%, 0);-o-transform: translate(0px, -50%);-ms-transform: translate3d(0px, -50%, 0);transform: translate3d(0px, -50%, 0);&#125;.swiper-container-vertical &gt; .swiper-pagination-bullets .swiper-pagination-bullet &#123;margin: 5px 0;display: block;&#125;.swiper-container-horizontal &gt; .swiper-pagination-bullets .swiper-pagination-bullet &#123;margin: 0 5px;&#125;/* 自定义进度条的样式 */.swiper-pagination-bullet&#123;width: 2.2rem;height: 2.2rem;background: red;opacity:0.5;&#125;span.swiper-pagination-bullet.swiper-pagination-bullet-active&#123;background: black;opacity: 1&#125; 分页器切换页面 var mySwiper = new Swiper ('#swiper-container1', &#123; pagination : '.swiper-pagination', //分页器 paginationClickable :true //点击分页器自动切换&#125;)]]></content>
      <categories>
        <category>Swiper3.0手册</category>
      </categories>
      <tags>
        <tag>Swiper3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用方法]]></title>
    <url>%2F2018%2F07%2F05%2Fswiper3-0-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本结构Swiper: 整个滑动对象，有时特指滑块释放后仍然正向移动直到贴合边缘的过程(过渡)container: Swiper的容器，包括滑块（slides）、封套（wrapper)、分页器(pagination)、前进按钮等wrapper: 触控的对象，可触摸区域，移动的块的集合，过渡时会随slide切换产生位移slider: 切换的滑块，可以包含文字、图片、html元素或另外一个Swiperpagination: 分页器，指示slide的数量和当前活动的slide 结构样式线上路径 &lt;script src="//ossweb-img.qq.com/images/js/swiper/swiper-3.4.2.min.js"&gt;&lt;/script&gt; 页面结构 &lt;div class="swiper-container" id="swiper-container1"&gt; &lt;div class="swiper-wrapper"&gt; &lt;div class="swiper-slide"&gt;Slide 1&lt;/div&gt; &lt;div class="swiper-slide"&gt;Slide 2&lt;/div&gt; &lt;div class="swiper-slide"&gt;Slide 3&lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class="swiper-scrollbar"&gt;&lt;/div&gt;&lt;/div&gt; 基础样式 /* base */.swiper-wp8-horizontal &#123;-ms-touch-action: pan-y;touch-action: pan-y;&#125;.swiper-container &#123;margin-left: auto;margin-right: auto;position: relative;overflow: hidden;/* Fix of Webkit flickering */z-index: 1;&#125;.swiper-container-no-flexbox .swiper-slide &#123;float: left;&#125;.swiper-container-vertical &gt; .swiper-wrapper &#123;-webkit-box-orient: vertical;-moz-box-orient: vertical;-ms-flex-direction: column;-webkit-flex-direction: column;flex-direction: column;&#125;.swiper-wrapper &#123;position: relative;width: 100%;height: 100%;z-index: 1;display: -webkit-box;display: -moz-box;display: -ms-flexbox;display: -webkit-flex;display: flex;-webkit-transition-property: -webkit-transform;-moz-transition-property: -moz-transform;-o-transition-property: -o-transform;-ms-transition-property: -ms-transform;transition-property: transform;-webkit-box-sizing: content-box;-moz-box-sizing: content-box;box-sizing: content-box;&#125;.swiper-container-android .swiper-slide,.swiper-wrapper &#123;-webkit-transform: translate3d(0px, 0, 0);-moz-transform: translate3d(0px, 0, 0);-o-transform: translate(0px, 0px);-ms-transform: translate3d(0px, 0, 0);transform: translate3d(0px, 0, 0);&#125;.swiper-container-multirow &gt; .swiper-wrapper &#123;-webkit-box-lines: multiple;-moz-box-lines: multiple;-ms-flex-wrap: wrap;-webkit-flex-wrap: wrap;flex-wrap: wrap;&#125;.swiper-container-free-mode &gt; .swiper-wrapper &#123;-webkit-transition-timing-function: ease-out;-moz-transition-timing-function: ease-out;-ms-transition-timing-function: ease-out;-o-transition-timing-function: ease-out;transition-timing-function: ease-out;margin: 0 auto;&#125;.swiper-slide &#123;-webkit-flex-shrink: 0;-ms-flex: 0 0 auto;flex-shrink: 0;width: 100%;height: 100%;position: relative;&#125;/* Auto Height */.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide &#123;height: auto;&#125;.swiper-container-autoheight .swiper-wrapper &#123;-webkit-box-align: start;-ms-flex-align: start;-webkit-align-items: flex-start;align-items: flex-start;-webkit-transition-property: -webkit-transform, height;-moz-transition-property: -moz-transform;-o-transition-property: -o-transform;-ms-transition-property: -ms-transform;&#125;/* 设置宽度和高度 */#swiper-container1&#123; width: 500px; height: 500px;&#125;.swiper-slide1&#123; background: red;&#125; 初始化 var mySwiper = new Swiper ('#swiper-container1', &#123; direction: 'vertical', loop: true,// 如果需要分页器 pagination: '.swiper-pagination',// 如果需要前进后退按钮 nextButton: '.swiper-button-next', prevButton: '.swiper-button-prev',// 如果需要滚动条 scrollbar: '.swiper-scrollbar',&#125;) 更多细节参考官网API:http://3.swiper.com.cn/api/index.html]]></content>
      <categories>
        <category>Swiper3.0手册</category>
      </categories>
      <tags>
        <tag>Swiper3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加本地搜索]]></title>
    <url>%2F2018%2F07%2F04%2Fhexo--%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[随着文章数量的不断增加，目录和标签已经不能满足我们的需求，添加本地搜索有助于我们对所需资源进行快捷定位 安装搜索插件cd你的博客目录，鼠标右键选择Git Bash Here $ npm install hexo-generator-searchdb --save 修改站点配置文件在_config.yml添加搜索支持 search： path: search.xml field: post format: html limit: 10000 开启搜索功能修改主题目录下的_config.yml local_search: enable: true]]></content>
      <categories>
        <category>hexo功能整合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github]]></title>
    <url>%2F2018%2F07%2F04%2Fhexo--Hexo%2BGithub%2F</url>
    <content type="text"><![CDATA[利用Hexo+Github搭建个人博客 安装Git + nodejsGit: https://www.git-scm.com/download/Node.js: https://nodejs.org/zh-cn/ 安装hexo$ npm install hexo-cli -g //全局安装hexo$ hexo init blog //创建blog文件并且初始化$ cd blog //进入刚才创建的blog文件 $ npm install //安装各种依赖$ hexo server //启动服务 配置个人用户信息$ git config --global user.name &quot;yourname&quot; //用户名$ git config --global user.email &quot;yourEmail&quot; //邮箱 在_config.yml中添加关联的仓库地址 deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 创建SSHSSH是一种网络协议，用于计算机之间的加密登录 ssh-keygen -t rsa -C &quot;youremail@example.com 进入文件找到key$ cd ~/.ssh$ cat id_rsa.pub 图中蓝色区域 配置Github新建一个名为yourname.github.io的仓库在全局settings里面配置SSH，把key复制进里面，titile自拟 部署安装部署插件 $ npm install hexo-deployer-git --save 依次输入$ hexo clean$ hexo g$ hexo d 访问: https://yourname.github.io/]]></content>
      <categories>
        <category>hexo功能整合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue搭建项目]]></title>
    <url>%2F2018%2F07%2F02%2FVue--%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[在使用vue搭建项目之前，要安装所需依赖 安装 nodejs 安装 webpack:$ npm install webpack -g 安装 vue-cli:$ npm install vue-cli -g 鉴于国内网络限制，可以选择切换镜像源npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm install不推荐使用国内镜像 初始化项目文件 创建一个名为“Abc”的初始化文件夹 vue init webpack Abc 如果已经提前建好了文件夹，则只需在该文件夹内 vue init webpack 如果node_modules没有安装，则npm install 使用npm run dev启动 配置路由vue适合用来构建SPA应用，所以路由嵌套很正常。在入口页面App.html中，router-view是路由区域。单页面的切换就在该区域。 &lt;template&gt; &lt;div id="app"&gt; &lt;transition name="fade" mode="out-in"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt; 引入路由组件(src / router / index.js) //依赖import Vue from 'vue'import Router from 'vue-router'//主路由import Main from '@/components/Main'//分路由import Login from '@/components/Login' //登录页面import Card from '@/components/pages/Card' //学籍卡片 设置路由的跳转(src / router / index.js) export default new Router(&#123; // mode: 'history', routes: [ &#123;path: '*', hidden: true, redirect: &#123; path: '/404' &#125; //重定向404 &#125;, &#123; path: '/login', //路径 component: Login, //组件 name:'', &#125;, &#123; path: '/404', component: notFound, name:'', &#125;, &#123; path: '/', leaf: true, icon:'icon-myschedule', //参数，传递给路由页面进行渲染 iconColor:'#d10dff', component: Main, main:true, name:'', children:[ &#123; path: '/Plan', component: Plan, name: '培养方案' &#125; ] &#125; ]&#125;) 链接跳转(src / components / xx.vue) &lt;div class="hello"&gt; &lt;router-link to="/"&gt;&lt;/router-link&gt; &lt;!--使用to来跳转，对应路由文件里面的path--&gt;&lt;/div&gt; 获取路由参数：v-for=&quot;(item,index) in $router.options.routes 使用参数：item.children[n].path]]></content>
      <categories>
        <category>Vue使用手册</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex参考]]></title>
    <url>%2F2018%2F07%2F02%2FVue--Vuex%2F</url>
    <content type="text"><![CDATA[vuex是数据仓库，同时也是状态管理器 使用方法新建js文件写入store.js //引入依赖import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const state =&#123; //state是状态 count:1 //count是公用的数据，放在状态里面&#125;;//暴露出去export default new Vuex.Store(&#123; state&#125;) 在组件中使用（app.vue） &lt;!-- 使用$.store.state获取状态 --&gt;&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;h3&gt;这是数据仓库的值：&#123;&#123;$.store.state.count&#125;&#125;&lt;/h3&gt; ①使用computed简化指令（app.vue） computed:&#123; //computer用于临时计算，返回一个对象 count()&#123; //这里把count的值指向为 this.$store.state.count return this.$store.state.count &#125;&#125; 现在，count的值就有了，而且指向为this.$store.state.count这个时候就可以这么写 &lt;h3&gt;这是数据仓库的值：&#123;&#123;$store.state.count&#125;&#125;--&#123;&#123;count&#125;&#125;&lt;/h3&gt; ②使用mapState简化指令（app.vue）引入和添加（app.vue） //引入mapStateimport &#123;mapState&#125; from 'vuex'//添加方式computed:mapState(['count']) 改变数据的值通过mutations来改变state里面的值(store / vuex.js) const mutations = &#123; add(state,n)&#123; //第一个是状态参数，第二个是自定义参数 state.count+=n; &#125;&#125;;//把状态和方法都暴露出去export default new Vuex.Store(&#123; state,mutations&#125;) 在组件里接收数据（app.vue） import store from '@/vuex/store'; //接收数据import &#123; mapState,mapMutations &#125; from 'vuex'; export default &#123; data()&#123; return &#123; message:'hello world' &#125; &#125;, store, //接收数据 methods:mapMutations([ 'add','reduce' ]), &#125; 使用数据（app.vue） &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt;&lt;button @click="$store.commit('add',10)"&gt;增加&lt;/button&gt;&lt;!--只能通过 $store.commit（）调用方法--]]></content>
      <categories>
        <category>Vue使用手册</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios+Mock]]></title>
    <url>%2F2018%2F07%2F02%2FVue--Axios%2BMock%2F</url>
    <content type="text"><![CDATA[目录结构Axios用于前后端通信，mock.js用于模拟随机数据，搭配使用旨在脱离后端进行开发测试。 |-- data // 目录示例 |-- api.js // 统一管理axios所有的请求 |-- index.js // 拦截请求 |-- mock-data.js // 模拟数据 模拟随机数据（data / mock-data.js）//引入mockimport Mock from 'mockjs';//模拟用户const LoginUsers = &#123; id: 1, username: 'USER3114001996', password: '123456', num:'3114001996', year:'2014', departments:'信息工程学院', program:'轨道交通电气化', cla:'140716', sec:'男', desc:'如有信息错误，请及时反馈~~', name: Mock.Random.cname(), phone: Mock.mock(/^\d&#123;11&#125;/), weChat: Mock.mock(/^\d&#123;9&#125;/), pas: Mock.Random.id(), schoolNum:Mock.mock(/^\d&#123;10&#125;/), address: Mock.Random.province() +Mock.Random.city()+Mock.Random.county(true)&#125;;//导出数据export &#123;LoginUsers&#125;; 拦截请求（data / index.js）//依赖let axios = require('axios');let MockAdapter = require('axios-mock-adapter');//通过axios-mock-adapter生成代理api地址//导入数据import &#123;Users,course,schedule&#125; from "./mock-data"export default &#123; init() &#123; //实例化 let mock = new MockAdapter(axios); //拦截带参数的请求，reply的参数为 (status, data, headers) mock.onGet('/login').reply(config =&gt; &#123; let username = config.username; //存储请求数据 let password = config.password; return new Promise((resolve, reject) =&gt; &#123; let hasUser = (Users.username==username &amp;&amp; Users.password==password)?true:false; //匹配成功 if (hasUser) &#123; resolve([200, &#123; code: 200, msg: '请求成功' &#125;]); &#125; else &#123; resolve([200, &#123; code: 500, msg: '账号或密码错误' &#125;]); &#125; &#125;) &#125;); //拦截没有参数的请求 mock.onGet('/card').reply(200, &#123; LoginUsers: LoginUsers //返回的对象 &#125;); mock.onGet('/plan').reply(200, &#123; course: course &#125;); &#125;&#125; 通过管理请求（data / api.js）//统一管理axios所有的请求import axios from 'axios'let base = ''; //$&#123;base&#125;/xx 为路径//获取登录信息 export const requestLogin = params =&gt; axios.get(`$&#123;base&#125;/login`,params).then(res =&gt; res.data);//获取卡片信息export const cardMessage = params =&gt; axios.get(`$&#123;base&#125;/card`,params).then(res =&gt; res.data);//获取培养计划export const getPlan = params =&gt; axios.get(`$&#123;base&#125;/plan`,params).then(res =&gt; res.data);//获取课程表export const schedule = params =&gt; axios.get(`$&#123;base&#125;/schedule`,params).then(res =&gt; res.data); 使用请求首先引入api文件 import &#123;requestLogin&#125; from '../../data/api' 然后在有需要的地方使用引入的方法 export default &#123; name: "Login", data() &#123; return &#123; test: &#123; name: 'USER3114001996', region: '123456' &#125;, checked: true, loading:false &#125; &#125;, methods:&#123; enter()&#123; this.loading = true; //发送axios请求并且传递用户参数 let loginParams = &#123; username: this.test.name, password: this.test.region &#125;; requestLogin(loginParams).then((data) =&gt; &#123; let &#123; msg, code, user &#125; = data; if(code!==200)&#123; this.loading = false; this.$message(&#123; message: msg, type: 'error', duration:1200 &#125;); &#125;else&#123; this.loading = false; //请求成功后跟换路径，跳转路由 this.$router.push(&#123; path: '/Card' &#125;); &#125; &#125;) &#125; &#125;&#125;]]></content>
      <categories>
        <category>Vue使用手册</category>
      </categories>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery常用操作]]></title>
    <url>%2F2018%2F06%2F29%2FjQuery--%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[收集和整合jquery常用操作，便于快速查询和使用，提升开发效率。 判断滚动条位置 $(window).scroll(function(event) &#123; if ($('html,body').scrollTop() &gt; $('.sect1').height()) &#123; //do something &#125; else &#123; //do something &#125;&#125;); 导航按钮 //pc端function bodyMove(num) &#123; $("html,body").animate(&#123; scrollTop: num &#125;, 400, function() &#123;&#125;);&#125;$('.nav').each(function(index, el) &#123; $(this).click(function(event) &#123; var href = $(this).attr('data-href'); bodyMove($(href).offset().top); &#125;);&#125;);//zepto没有animatefunction bodyMove(num) &#123; $("html,body").scrollTop(num);&#125; 获取鼠标位置 screenX：相对于屏幕的坐标 clientX：相对于浏览器内容区域的坐标（不包括滚动条隐藏的部分） pageX：相对于页面文档的坐标，和浏览器宽高无关 offsetX：相对于盒子模型里面的坐标，和浏览器宽高无关 function getCoordinates(e,t) &#123; return site = &#123; x:e[t+'X'], y:e[t+'Y'], &#125;&#125;$('body').mousemove(function(event) &#123; console.log(getCoordinates(event,'client'));&#125;); 选择同辈元素 //zepto和jquery均适用$('.box').click(function(event) &#123; $(this).addClass('active').siblings().removeClass('active');&#125;); 对元素进行判断 if (!$('.nav').length) &#123;&#125; //检测元素是否存在if (!$('.key').html()) &#123;&#125; //检测元素是否为空（不包括自身）if (!$('.key').is(':empty')) &#123;&#125; //检测元素是否为空（包括自身） 阻止移动端浏览器页面滑动 document.body.addEventListener('touchmove',bodyScroll,false);// 去除默认事件function bodyScroll(event)&#123; event.preventDefault();&#125;]]></content>
      <categories>
        <category>jQuery使用手册</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弹窗组件]]></title>
    <url>%2F2018%2F06%2F14%2FTX-%E5%BC%B9%E7%AA%97%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。 在文档底部添加引用 &lt;script src="//ossweb-img.qq.com/images/js/comm/showDialog.min.js"&gt;&lt;/script&gt; 结构 &lt;div class="pop" id=""&gt; &lt;a href="javascript:showDialog.hide()" class="close" onclick="PTTSendClick('btn','close','关闭弹窗');"&gt;&lt;/a&gt;&lt;/div&gt; 弹窗的高度一般不要超过550px为每一个弹窗添加特定的id,方便调用以及更改样式写样式之前，对弹窗相同样式进行抽取，具体到不同的弹窗具体修改 参考代码如下: /*------popCom------*/.pop&#123; position: relative; display: none; overflow: hidden; width: 6.6rem; margin-left: -3.3rem !important; text-align: center; background: url(ossweb-img/pop-bg.png) repeat;&#125;.pop .close&#123; position: absolute; top: 0.2rem; right: 0.2rem; width: 0.26rem; height: 0.26rem; background: url(ossweb-img/close.png) no-repeat center; background-size: 100%;&#125;/* ways */#ways&#123; height: 3.6rem;&#125;#ways .title&#123; margin-top: 0.65rem;&#125; 显示弹窗 showDialog.show('id'); //对于不同弹窗，更换不同的id即可 隐藏弹窗 showDialog.hide(); 是否可滚屏当弹窗出现时屏幕是否可以滚动，取决于客户需求，参看代码 $('body,html').css('overflowY', 'hidden'); //隐藏滚动条，弹窗初始化启用$('body,html').css('overflowY', 'auto'); //显示滚动条，弹窗关闭后启用]]></content>
      <categories>
        <category>TX-解决方案</category>
      </categories>
      <tags>
        <tag>供应商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容措施]]></title>
    <url>%2F2018%2F06%2F13%2FCSS%E6%89%8B%E5%86%8C--%E5%85%BC%E5%AE%B9%E6%8E%AA%E6%96%BD%2F</url>
    <content type="text"><![CDATA[透明度opcaity .ele&#123; opacity: 1; filter: progid:DXImageTransform.Microsoft.Alpha(opacity=100); &#125; 让ie低版本支持inlline-block .ele&#123; display: inline-block; *display: inline; *zoom: 1&#125; 解决Chrome在应用transition时页面闪动的问题？ -webkit-transform-style:preserve-3d;/* 或者 */-webkit-backface-visibility:hidden; 解决移动端的滑动事件总是出现无法侦听被动事件在使用有些移动端插件时，如果使用了滑动事件，可能会包报错 Unable to preventDefault inside passive event listener due to target being treated as passive * &#123; touch-action: none; &#125; flex垂直居中兼容性写法 .flex&#123; text-align: center; font-size: 18px; display: -webkit-box; display: -ms-flexbox; display: -webkit-flex; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; -webkit-justify-content: center; justify-content: center; -webkit-box-align: center; -ms-flex-align: center; -webkit-align-items: center; align-items: center;&#125;]]></content>
      <categories>
        <category>CSS手册</category>
      </categories>
      <tags>
        <tag>CSS兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2018%2F06%2F05%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[弹性布局是未来布局的发展趋势，现代浏览器均对flex实现了不同程度的支持，但是如果要兼容老版本的浏览器，则还是应该回归原始的布局方式。 基本概念容器和项目弹性布局的实现需要一个容器，也就是flex容器。只要把父元素的display设置为flex，则他的子元素就全部成为了flex项目 主轴和交叉轴主轴（main axis）处于水平方向，是x轴。起点叫main start，终点叫做main end。交叉轴（cross axis）处于垂直方向，是y轴。起点叫cross start，终点叫做cross end。 容器属性flex-direction 该属性决定项目的拍排列方向,有:水平方向：row（从左到右），row-reverse（从右到左）;垂直方向：column（从上到下），column-reverse（从下到上）.box&#123; flex-direction: column|column-reverse|row|row-reverse;&#125; flex-wrap改属性决定了项目溢出容器时候的处理方式，默认是自动收缩不换行（nowrap）不换行，水平方向自动收缩：nowrap换行：warp换行之后反向：wrap-reverse 如果设置了项目的宽度，并且项目的总宽度之和&gt;容器的宽度，在设置了不换行nowarp的情况下，项目宽度会被自动压缩，不超过容器范围 flex-flow是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。优先使用这个属性。 justify-content该属性决定项目在主轴(x轴)上的对其方式 .box&#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。align-items 该属性决定项目在交叉轴(y轴)上的对其方式 .box&#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 尤其要注意，如果项目没有设置具体高度，那么他会默认填充满容器 align-content多轴属性，当换行的时候，会有多个主轴或者交叉轴的存在。该属性和主轴对其方式是一致的。 .box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 项目属性order排列顺序。数值越小，排列越靠前，默认为0 .flex-item &#123; order: &lt;integer&gt;;&#125; flex-grow放大比例，默认为0，即如果存在剩余空间，也不放大 .flex-item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink缩小比例，默认为1，即如果空间不足，该项目将缩小 .flex-item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis分配多余空间之前，项目占据的主轴空间（main size），也就是固定宽度 .flex-item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flex 是flex-grow, flex-shrink 和 flex-basis的简写，默认值0 1 auto。后两个属性可选 align-self 单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 小实例用弹性布局实现百分比高度的文字垂直居中 考虑到浏览器的兼容性差异，最好flex相关属性都加上浏览器内核前缀]]></content>
      <categories>
        <category>弹性布局</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频弹窗]]></title>
    <url>%2F2018%2F03%2F15%2FTX-%E8%A7%86%E9%A2%91%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。 PC视频引用视频组件 &lt;script src="//ossweb-img.qq.com/images/js/comm/showDialog.min.js"&gt;&lt;/script&gt;&lt;script src="//vm.gtimg.cn/tencentvideo/txp/js/txplayer.js"&gt;&lt;/script&gt; 结构样式及调用html &lt;!-- 视频弹窗 --&gt;&lt;div class="pop" id="vindex-play"&gt; &lt;span class="btn-pop-close" onclick="hideVideo();" title="点击关闭" onclick="PTTSendClick('btn','close','关闭弹窗');"&gt;×&lt;/span&gt; &lt;div class="pop-con" id="vplay-con" style="padding-top: 0"&gt;&lt;/div&gt;&lt;/div&gt; css /*--------video---------*/#vindex-play &#123;position:relative;display: none;width:800px;height:500px;padding-top: 0;border:2px solid #e9d7a5;background: none;&#125;#vindex-play .btn-pop-close&#123;position:absolute;top:-2px;right:-41px;display:block;width:40px;height:40px;cursor: pointer;text-align:center;text-decoration: none;color:#fff;background-color: #e9d7a5;font-family:Tahoma;font-size:30px;line-height:36px;&#125;#vindex-play .btn-pop-close:hover &#123;text-decoration:none;color:#fff;&#125;#vindex-play .pop-con,#vindex-play .pop-con .tenvideo_player&#123;width: 800px;height: 500px;&#125; js // pc视频弹窗方法function playVideo(e,vid) &#123; showDialog.show(&#123;id:e&#125;); //e为弹窗,vid为视频编码 var player = new Txplayer(&#123; containerId: 'vplay-con', vid: vid, width: '100%', height: '100%', autoplay: false &#125;);&#125;// 关闭pc视频弹窗方法function hideVideo() &#123; var flv_s = document.getElementById("vplay-con"); if (flv_s)&#123; flv_s.innerHTML= ""; &#125; showDialog.hide();&#125; 调用 onclick="playVideo('vindex-play','q0625wf8pcn')" H5视频引用视频组件&lt;script src="//ossweb-img.qq.com/images/js/comm/showDialog.min.js"&gt;&lt;/script&gt;&lt;script src="//imgcache.gtimg.cn/tencentvideo_v1/tvp/js/tvp.player_v2.js" charset="utf-8"&gt;&lt;/script&gt; 结构样式及调用html &lt;!-- 视频弹窗 --&gt;&lt;div id="videoPlayer" class="video_player"&gt;&lt;/div&gt;&lt;i id="videoClose" class="video_close"&gt;×&lt;/i&gt; css /*--------video---------*//*--------video--------*/.video_close&#123;width: 0.6rem;height: 0.6rem;color: #d2b853;font-size: 0.6rem;line-height: 0.6rem;&#125;.video_player &#123;position: fixed;z-index: 10011;top: 0;left: 0;display: none;width: 100%;height: 100%;background: #000;&#125;.video_close &#123;position: fixed;z-index: 10014;top: 2%;right: 2%;display: none;width: 0.6rem;width: 0.4rem;height: 0.6rem;height: 0.4rem;text-align: center;color: #d2b853;color: #0091de;background: #000;font-size: 0.6rem;font-size: 0.8rem;font-weight: 700;line-height: 0.6rem;&#125; js //视频var showVideo = function()&#123; var video = new tvp.VideoInfo(); video.setVid(vid); //视频码 var player = new tvp.Player(); player.create(&#123; width:"100%", height:"100%", video:video, modId:"videoPlayer", isHtml5UseAirPlay:true, isHtml5UseFakeFullScreen:true, autoplay:false &#125;); $('#videoPlayer').show(); $('#videoClose').show();&#125;;$('#videoClose').on("click",function()&#123; $('#videoPlayer').hide().html(" "); $('#videoClose').hide();&#125;); 调用 onclick="showVideo('r0539nr9q6d');"]]></content>
      <categories>
        <category>TX-解决方案</category>
      </categories>
      <tags>
        <tag>供应商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5端构建]]></title>
    <url>%2F2018%2F03%2F14%2FTX-%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[结构样式为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。 html &lt;div class="sect sect1"&gt;&lt;/div&gt;&lt;div class="sect sect2"&gt;&lt;/div&gt; css .sect1&#123;height: 2rem;background: url() no-repeat center top&#125;.sect2&#123;height: 3rem;background: url() no-repeat center top&#125;.sect&#123;position:relative;margin: 0 auto;overflow: hidden;background-size: 100%;width:7.5rem; &#125; 组件上报 ontouchend="PTTSendClick('btn','back','返回官网')" 分离路径传奇霸业://game.gtimg.cn/images/cqby/cp/a20180223bsdm/御龙在天://game.gtimg.cn/images/ylzt/cp/a20180124jymtm/传奇世界://game.gtimg.cn/images/cqsj3d/cp/a20180223bsdm/梦幻诛仙://game.gtimg.cn/images/mhzx/cp/a20180418gcwfm/轩辕传奇://game.gtimg.cn/images/xycq/cp/a20180423jyxtm/QQ炫舞: //game.gtimg.cn/images/x5m/cp/a20180516bbztm/ 链接跳转传霸官网://shuang.qq.com/m/main.shtml御龙官网://ylzt.qq.com/m/传世官网://3d.qq.com/传世兴趣部落 /传世游戏论坛 /传世公众号 /传世微博梦诛官网://mhzx.qq.com/m/index.shtml轩辕官网://xycq.qq.com/m/炫舞官网://x5m.qq.com/m/m201711/index.html]]></content>
      <categories>
        <category>TX-解决方案</category>
      </categories>
      <tags>
        <tag>供应商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微区构建]]></title>
    <url>%2F2018%2F03%2F13%2FTX-%E5%BE%AE%E7%A4%BE%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[结构样式为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。 html &lt;div class="sect sect1"&gt;&lt;/div&gt;&lt;div class="sect sect2"&gt;&lt;/div&gt; css .sect1&#123;height: 2rem;background: url() no-repeat center top&#125;.sect2&#123;height: 3rem;background: url() no-repeat center top&#125;.sect&#123;position:relative;margin: 0 auto;overflow: hidden;background-size: 100%;width:7.5rem; &#125; 组件上报 ontouchend="PTTSendClick('btn','back','返回官网')" 分离路径御龙在天://game.gtimg.cn/images/ylzt/ingame/act/a20180117jmyc/梦幻诛仙://game.gtimg.cn/images/mhzx/ingame/act/a20180418gcwf/QQ炫舞: //game.gtimg.cn/images/x5m/ingame/act/a20180516bbztm/ 链接跳转御龙官网://ylzt.qq.com/ingame/all/index.shtml梦诛官网://mhzx.qq.com/ingame/all/topic.shtml炫舞官网://x5m.qq.com/ingame/all/index.shtml]]></content>
      <categories>
        <category>TX-解决方案</category>
      </categories>
      <tags>
        <tag>供应商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PC端构建]]></title>
    <url>%2F2018%2F03%2F11%2FTX-PC%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[结构样式为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。 html &lt;div class="sect sect1"&gt; &lt;div class="part part1"&gt;&lt;/div&gt;&lt;/div&gt; css .sect&#123;position:relative;margin: 0 auto;width: 100%;min-width: 1180px;&#125;.part&#123;overflow: hidden;position: relative;margin: 0 auto;width: 1180px;&#125;.sect1&#123;background: url() no-repeat center top&#125;.sect1 .part1&#123;height: 806px;&#125; 组件上报 onclick="PTTSendClick('btn','back','返回官网')" 分离路径传奇霸业://game.gtimg.cn/images/cqby/cp/a20180223bsd/御龙在天://game.gtimg.cn/images/ylzt/cp/a20180117jymt/传奇世界://game.gtimg.cn/images/cqsj3d/cp/a20180223bsd/梦幻诛仙://game.gtimg.cn/images/mhzx/cp/a20180418gcwf/轩辕传奇://game.gtimg.cn/images/xycq/cp/a20180423jyxt/QQ炫舞: //game.gtimg.cn/images/x5m/cp/a20180517bbzt/ 链接跳转传霸官网://shuang.qq.com/index.shtml御龙官网://ylzt.qq.com/传世官网://3d.qq.com/梦诛官网://mhzx.qq.com/轩辕官网://xycq.qq.com/炫舞官网://x5m.qq.com/web201711/main.shtml]]></content>
      <categories>
        <category>TX-解决方案</category>
      </categories>
      <tags>
        <tag>供应商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享蒙层]]></title>
    <url>%2F2018%2F03%2F11%2FTX-%E5%88%86%E4%BA%AB%E8%92%99%E5%B1%82%2F</url>
    <content type="text"><![CDATA[使用说明针对移动设备浏览方式的差异，分为两种分享方式：右上角和下方对浏览方式进行判断然后选用适合的蒙层 结构 &lt;!-- 右上角分享蒙层 --&gt;&lt;div class="share share-right"&gt; &lt;img src="share.png" alt="share" class="share-icon"&gt; &lt;p&gt;点击右上角分享给好友&lt;/p&gt;&lt;/div&gt;&lt;!-- 下方分享蒙层 --&gt;&lt;div class="share share-down"&gt; &lt;p&gt;点击下方导航栏,分享给好友&lt;/p&gt;&lt;/div&gt; 样式 /* share */.share&#123;position: fixed;z-index: 2;top: 0;display: none;width: 100%;height: 100%;text-align: center;color: white;background: rgba(12, 12, 12, 0.91);font-size: 0.4rem;&#125;.share-right p&#123;margin-left:25%;&#125;.share-right img.share-icon &#123;width: 1.42rem; margin: 12% 0 0 58%;&#125;.share-down p&#123;margin-top: 90%;font-size: 0.35rem;&#125; 判断方法展开和关闭 //判断分享类型var ua = navigator.userAgent.toLowerCase();if ((ua.match(/MicroMessenger/i) == 'micromessenger') || (ua.match(/QQ/i) == "qq") || (ua.match(/WeiBo/i) == "weibo")) &#123; $('.share-right').show();&#125; else &#123; $('.share-down').show();&#125;//关闭蒙层$.each(['.share-right', '.share-down'], function(index, value) &#123; $(value).click(function(event) &#123; $(this).hide(); &#125;);&#125;); 分享图标跳转下载]]></content>
      <categories>
        <category>TX-解决方案</category>
      </categories>
      <tags>
        <tag>供应商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组型对象的实现]]></title>
    <url>%2F2017%2F09%2F22%2FJS--%E6%95%B0%E7%BB%84%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在jQuery中，如果调用$函数访问一个元素，例如console.log($(&#39;div&#39;));，则会返回一个数组型对象。可以借助循环添加的方式实现 var o = &#123;&#125;;array = ['p','a']for(i=0;i&lt;array.length;i++)&#123; o[i] = arry[i];&#125;o.length = array.length;console.log(o); //&#123;0: "p", 1: "a", length: 2&#125; 但是在jQuery里面，是通过数组的push方法来实现的 var o = &#123;&#125;;var arry = ['p','a'];Array.prototype.push.apply(o,arry)console.log(o); //&#123;0: "p", 1: "a", length: 2&#125; 原来apply的this指向的是数组，现在转换为对象]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call和apply]]></title>
    <url>%2F2017%2F09%2F22%2FJS--call%20%E5%92%8C%20apply%2F</url>
    <content type="text"><![CDATA[每个函数都有call和apply方法，可以用来改变this的指向，或者说，用call和apply来帮助对象，去调用某个函数的方法 使用场景比如某个对象想用它本身没有的方法，但是又不想重写，就可以使用call和apply去调用其他函数的方法 Array.prototype.slice.call(arguments) 这时候的this并不是一个Array，因为需要借用Array类的方法，所以使用了call 再来看一个栗子： var cat = &#123; object:'怪兽'&#125;var superman =&#123; object:'鱼'&#125;superman.beat = function () &#123; console.log(this.object);&#125;//猫调用superman的beat的方法，但是它本身是没有这个方法的superman.beat.call(cat); 作用总结所以其实call和apply有两个作用 ① 改变this的指向② 让某个对象不用重写方法去调用其他对象的方法 换个层面来说，其实，当一个函数作为一个对象的方法被调用的时候，this指向的就是这个对象，比如说 var cat =&#123; speak:function () &#123; console.log('我是猫的方法'); &#125;&#125;cat.speak() 所以，当使用apply和call的时候，该对象就有了新的方法。所以，为什么会改变this的指向，其实和上面的一样，函数作为这个对象的方法调用了 superman.beat.call(cat);//相当于cat.beat()//所以this就指向了cat对象 最后看一个栗子加深理解 var a = 3;var cat =&#123; a:1&#125;var ani = function () &#123; console.log(this.a);&#125;ani(); //3 直接调用，this指向windowani.apply(cat) //1 作为cat的方法调用，this指向对象cat]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的封装]]></title>
    <url>%2F2017%2F08%2F23%2FJS--%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[命名空间（用对象的方式模拟）首先用对象字面量的方式创建一个命名空间 var Game = &#123;&#125;; 添加模块，可以将相同功能或者属性的归类 Game.module1 = &#123;name:'p',m:function()&#123;&#125;&#125;; 然后调用这个模块 Game.module1.m(); 可以用立即执行函数把这个命名空间包裹起来，这样可以减少变量冲突 伪类js没有块作用域，有函数作用域，把方法和属性卸载函数里面，可以减少变量冲突 对于构造器函数，包含实例化属性，自身属性，继承属性 function Person(name) &#123; this.name = name; //实例化属性 this.public = function () &#123; //实例化属性 console.log('this指向实例化的对象') &#125;; function private() &#123; console.log('这是私有的方法') //自身属性 &#125;&#125;Person.prototype = &#123; //继承属性 my:function () &#123; console.log('这是可以继承方法') &#125;&#125;; 然后通过new实现继承 var man = new Person('PETER');console.log(man.name); //PETERconsole.log(man.public()); //this指向实例化的对象console.log(man.my()); //这是可以继承方法console.log(man.private()); //Uncaught TypeError 实际案例中，会用私有方法调用共有方法或者共有方法调用私有方法 function Person(name) &#123; this.name = name; function pm() &#123; console.log(this.name) //输出实例化对象的name &#125; this.text = function () &#123; console.log('public method'); pm.call(this); //绑定到是实例化的对象 &#125;&#125;this.name = 1;var man= new Person('peter');man.text(); //peter 采用对象工厂的方式核心思路：定义一个人对象，函数返回一个对象 function Person(name) &#123; function pm() &#123; console.log(self.name) //------→ &#125; // | var self =&#123; // ←---| name:name, text:function () &#123; console.log('publick method'); pm(); &#125; &#125;; return self; //这个函数会返回一个对象，也就是实例化的对象继承了这个对象里面的属性&#125;var man = new Person('oe');man.text();]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2017%2F08%2F22%2FJS--%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[通过ES5的 Object.create实现创建父类function Parent() &#123;&#125;Parent.prototype.headCount = 1;Parent.prototype.eat = function () &#123;console.log('eat')&#125; 创建子类 function Children() &#123;&#125;Children.prototype.language = 'javascript';Children.prototype.work = function () &#123; console.log('work')&#125; 建立关系，修正构造器 Children.prototype = Object.create(Parent.prototype);Children.prototype.constructor = Children; 调整顺序 //父类function Parent() &#123;&#125;Parent.prototype.headCount = 1;Parent.prototype.eat = function () &#123; console.log('eat')&#125;;//关联修正，调整顺序Children.prototype = Object.create(Parent.prototype);Children.prototype.constructor = Children;//子类function Children() &#123;&#125;Children.prototype.language = 'javascript';Children.prototype.work = function () &#123; console.log('work')&#125;; 自己写一个函数步骤也是先定义父类和子类，然后建立关系，修正顺序，不过建立关系函数有所变化 function creatEx(c,p) &#123; function F() &#123;&#125; F.prototype = p.prototype; c.prototype = new F(); c.prototype.constructor = c;&#125; 对于函数的关联，思路是把c.prototype和p.prototype连接起来，然后通过new实例化c产生的对象久可以同时使用c和p的方法和属性 如果子类要访问父类中的动态变量，比如this.name，改如何解决？ function Parent(name) &#123; this.name = name&#125;function Children(name) &#123; Parent.apply(this,arguments) //调用Parent，同时this绑定为该Children函数&#125;]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型继承]]></title>
    <url>%2F2017%2F08%2F22%2FJS-JS%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[JS的原型继承在js中，要想创建一个对象，不是通过实例化，而是通过选择一个对象作为原型去克隆它来达到目的。而且对象只能克隆函数对象里面的prototype属性，既是Function.prototye，由于只有函数才有prototype对象，所以，想要创建一个对象，就必须要用函数才能创建，这个函数通常被称为构造器函数。来看一下普通对象和函数对象的创建：var cat= &#123;&#125;;function demo()&#123;&#125; 对于cat，只是普通对象，是通过Object函数构造的,所以克隆了Object函数的prototypecat == (克隆) Object.prototype 对于demo，是函数对象，比较高级，因为： 它通过Function函数构造，克隆了Function函数的prototype 同时，自己又是一个函数，也有自己的prootype，可以当作构造器被其他对象克隆 demo == (克隆) Function.prototype 重点来了，函数的prototype，是一个对象，那么这个对象也是从其他对象克隆过来的在js中，克隆根原型是null，其次是Object.prototype，也就是说，js所有的对象，都是通过Object.prototype克隆而来的上面这张图充分解释了js的原型继承概念，可以分几部去总结： 普通对象克隆了Object.prototype，函数对象克隆了Function.prototype Object.prototype的Object函数，它也克隆了Function.prototype Function对象克隆了自己的prototype Function.prototype这个对象，反过来克隆了Object函数的Object.prototype，所以最终的根克隆对象，其实就是Object.prototype，在它上面，是一个null，没有任何克隆的内容 console.log(Object.getPrototypeOf(Object)== Function.prototype); //tureconsole.log(Object.getPrototypeOf(Function.prototype)== Object.prototype); //tureconsole.log(Object.getPrototypeOf(Function)== Function.prototype); //tureconsole.log(Object.getPrototypeOf(Object.prototype)== null); //ture]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arguments和重载]]></title>
    <url>%2F2017%2F08%2F21%2FJS--arguments%2F</url>
    <content type="text"><![CDATA[函数被调用的时候，会接收两个附加参数，this和arguments。 arguments是一个对象。当arguments（实参）和parameters（形参）的个数不匹配时，不会导致错误，多余的实参会被忽略。 function cat(a,b) &#123; console.log(cat.length); //函数的形参个数 console.log(arguments.length); //函数的实参个数&#125; 重载比如要实现一个求和的函数 function add() &#123; var ad = 0; for(var i=0;i&lt;arguments.length;i++)&#123; ad += arguments[i]; &#125;&#125;add(1,2,3); //6 当实参类型不一样时候的处理假设有一段p标签。同时改变字体颜色大小等书写 function change() &#123; var ele = document.getElementsByClassName('text')[0]; //如果时对象类型 if(typeof arguments[0] == 'object')&#123; for(key in arguments[0])&#123; ele.style[key] = arguments[0][key] &#125; &#125;else&#123; ele.style.fontSize = arguments[0]; ele.style.backgroundColor = arguments[1]; &#125;&#125;change('44px','red')change(&#123;fontSize:'44px',backgroundColor:'green'&#125;) 当一个对象属性是动态值的时候，不能通过.访问，只能通过[]访问]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prototype 和 __proto__]]></title>
    <url>%2F2017%2F08%2F15%2FJS--prototype%20%E5%92%8C%20__proto__%2F</url>
    <content type="text"><![CDATA[关于prototype当一个新函数被创建时，会被赋予一个 prototype属性，这个属性是用来存放继承特性的地方只有函数才有prototype。 var Demo = function () &#123;&#125;console.log(Demo.prototype) // &#123;constructor: ƒ&#125; 可以表示为 Demo.prototype={constructor: ƒ} 因此我们可以对这个 prototype属性进行扩展，存放更多继承的特性，例如： Demo.prototype.call = function () &#123;console.log('我是新增加的继承特性')&#125;;var he = new Demo(); //Demo是构造器，he是构造函数，通过new连接he.call(); //我是新增加的继承特性 但是要注意的是，因为是继承特性，如果直接调用Demo.call()是不存在的 Demo函数不做继承的属性直接写，例如：Demo.call = function(){} 问题深入：JS是基于原型的语言 JS中的对象都继承于object.prototype，所以，尽管JS实现了继承概念，但是单一的原型object.prototype未免丧失活力，因此JS提供了可以改变对象的原型，以达到继承属性的办法 比如我们有一个Demo函数，其原型是object.prototype，现在，我们要改变他的原型以获得想要的属性 var obj = &#123;name:2&#125;; //定义一个我们想要继承的属性 ←--var Demo = function () &#123;&#125;; // ↑Demo.prototype = obj; //改变原型指向 -----------→ ↑var he = new Demo(); console.log(he.name) //2 Demo原型成功指向了obj，大功告成 关于__proto____proto__可以用于检测构造该对象的构造器的原型，听起来有点绕口，结合上面的例子 var obj = &#123;name:2&#125;; //定义一个我们想要继承的属性 ←--var Demo = function () &#123;&#125;; // ↑Demo.prototype = obj; //改变原型指向 -----------→ ↑var he = new Demo(); //he是构造函数，Demo是构造器console.log(he.__proto__) //&#123;name: 2&#125; he.__proto_刚好等于构造器Demo的原型，换一种写法就是he.__proto_ = Demo.prototype]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的关联]]></title>
    <url>%2F2017%2F08%2F15%2FJS--%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[JS的数据类型有两种： 原始类型（string、boolean、number、null、undefined） 对象类型（object） 对象之间的关联，可以通过Object.creat()来创建 var foo = &#123; something:function()&#123; console.log('hello') &#125;&#125;;var bar = Object.create(foo);bar.something(); //hello Object.create(...)会创建一个新对象（bar）并把它关联到我们指定的对象（foo） 用这种方式关联对象，可以充分发挥Prototype机制的威力，同时避免不必要的麻烦（比如使用new的构造函数调用会生成.prototype和.constructor引用） 解决旧IE无法使用Object.creat()的问题 if(!Object.creat)&#123; Object.creat = function(o)&#123; function F()&#123;&#125; F.prototype = 0; return new F(); &#125;;&#125; Object.create(null)会创建一个没有原型链的对象，这种特殊的空[[prototyepe]]对象被称为“字典”，他们完全不会受到原型链的干扰，因此特别适合用来存储数据]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于闭包]]></title>
    <url>%2F2017%2F08%2F14%2FJS--%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[维基解释：闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使离开了创造它的环境也不例外 在Js中，如果一个函数在另外一个函数中定义，那么这个函数会访问到父函数里面定义的成员，形成闭包。​或者说，一个函数能访问它被创建时所处的上下文环境，就是闭包。 主要有三点： 他是函数中的函数（无论嵌套多少层） 无论他是在父函数内部调用还是被return出去外部接收后调用，都能记住原来父函数的词法环境 //函数在内部被调用function f1() &#123; var a = 2; function f2() &#123; console.log(a) //2 &#125; f2(); //内部执行，严格来说不算闭包，是词法作用域的查找方式，从内到外&#125;//函数在外部被调用function f1() &#123; var a = 2; return function f2() &#123; console.log(a) // &#125;&#125;var x = f1(); //此时x等于return出来的f2x(); //2 这就是闭包，函数在外部被调用，但是函数还能记住创建他的词法环境 闭包的作用减少全局变量，延续生命周期 //函数在外部被调用function f1() &#123; var a =1; //a在函数作用域里面，不会污染全局变量 return function () &#123; console.log(a++) &#125;&#125;var result = f1();result(); 减少传递给函数的参数数量封装使用闭包的注意点对捕获的变量只是个引用，不是复制 function f1() &#123; var num = 1; function f2() &#123; console.log(num) //引用了num而不是复制 &#125; num++; f2()&#125;f1() //2 父函数每调用一次，会产生不同的闭包 function f1() &#123; var num = 1; return function f2() &#123; num++; console.log(num) &#125;&#125;var result1 = f1(); result1(); //2result1(); //3var result2 = f1();//result和result2虽然都是调用了f1,但是词法作用域是不相同的，不会互相影响result2(); //2result2(); //3 循环中问题 for(var i =1;i&lt;3;i++)&#123; console.log(i); //1,2 //能实时打印i setTimeout(function () &#123; //回调函数 console.log(i); //3,3 //程序加载完才执行，所以是3 &#125;,1000)&#125;//解决方案，利用立即执行函数和闭包将参数传递进去for(var i =1;i&lt;4;i++)&#123; (function (id) &#123; setTimeout(function () &#123; console.log(id) &#125;,1000) &#125;)(i)&#125; 假设有一个需求，有三个按钮，以此点击发出ajax请求 &lt;button id="1"&gt;1&lt;/button&gt;&lt;button id="2"&gt;2&lt;/button&gt;&lt;button id="3"&gt;3&lt;/button&gt; for(var i =1;i&lt;4;i++)&#123; var btn = document.getElementById(i); btn.onclick = function () &#123; alert(i); //回调函数不会马上执行 //4 &#125;&#125; 我们期望依次弹出1，2，3，但是结果全是三个4 因为for没有快作用域，i暴露在全局之中，回调函数执行时，循环已经结束，此时i=4； 解决方案，使用闭包，或者用let代替var for(var i =1;i&lt;4;i++)&#123; var btn = document.getElementById(i); btn.onclick = (function (id) &#123; //这是父函数， return function () &#123; //闭包函数 alert(id); //函数持续引用父函数里面传递的参数，形成闭包 &#125; &#125;)(i);&#125; 其实解决思路就是，在回调函数没有执行之前，把想要的参数传递进去，这就可以使用闭包，让回调函数里面的函数，用return函数的方式，引用外部父函数传递的形参 为什么要使用立即执行函数？是因为i参数改变时，立即执行函数才能把实时参数传递进去 每次循环的时候，父函数带着想要传递的参数立即执行，因为有闭包的存在，子函数依赖与父函数传递的参数，所以子函数就能正确引用每次循环不同的i值]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的解析与执行过程]]></title>
    <url>%2F2017%2F08%2F13%2FJS--JS%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在JS真正执行代码之前，会对代码有个预处理过程 预处理阶段 首先创建词法环境（这里是全局） 把用声明的方式创建的函数和用var定义的变量扫描出来，把这些函数和变量的名字加到词法环境中（这里是全局） // LexcialEnvironment (词法环境)&#123; a:undefined, //a是变量的名字，右边是值 f:对函数的引用, //f是函数的名字，右边引用(函数声明的方式) g:undefined //g是函数的名字，右边引用(函数表达式创建的函数)&#125; 声明函数 function xx(){}区别于函数表达式var xx = function xx(){} 用函数表达式创建的函数，在预处理阶段，函数名字也会被加到词法环境中，但是后面的值不会解析，返回undefined 处理函数声明有冲突，会覆盖 console.log(a); //function a() &#123;console.log(3);&#125;function a() &#123;console.log(2);&#125;function a() &#123;console.log(3);&#125; 处理变量声明有冲突，会忽略 console.log(a); //function a() &#123;console.log(3);&#125;function a() &#123;console.log(2);&#125;function a() &#123;console.log(3);&#125;var a = 2; //因为处理变量a有冲突，规则是忽略//可以把函数表达式也当作变量声明 var xx = function()&#123;&#125; ① 用var开头的变量或者函数都会被提升，加入到词法环境，值都是undefined​② function a (){}的形式，a被提升同时值是该函数引用​③ var 声明冲突会被忽略，function声明会覆盖 ​ 执行阶段 在执行阶段就会真正赋值（无论原来值是变量还是函数，都会被覆盖） 如果碰到在词法环境中找不到的名字，则会报错]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this的用法]]></title>
    <url>%2F2017%2F08%2F10%2FJS--this%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScript的 this 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境 除去不常用的with 和eval 的情况，具体到实际应用中， this 的指向大致可以分为以下 4种 作为对象的方法调用 此时this指向该对象 var obj = &#123; a: 1, getA: function()&#123; alert ( this === obj ); // 输出：true alert ( this.a ); // 输出: 1 &#125;&#125;;obj.getA(); 作为普通函数调用 指向全局对象，在浏览器的 JavaScript里，这个全局对象是 window 对象。 window.name = 'globalName';var getName = function()&#123;return this.name;&#125;;console.log( getName() ); // 输出：globalName 构造器调用 当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 指向返回的这个对象 var Cat = function (name) &#123; this.name = name&#125;;var white = new Cat(p);console.log(white.name) //p call或者apply调用 改变this的指向 var cat = &#123; name:'p', x:function () &#123; console.log(this.name) &#125;&#125;;var obj = &#123;name:'o'&#125;;cat.x.call(obj) //o ​]]></content>
      <categories>
        <category>JS出深入浅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp的实例参考]]></title>
    <url>%2F2017%2F06%2F12%2FGulp--%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[基本插件的安装GulpJs的安装依赖nodejs，所以先安装nodejs 打开nodejs里面的cmd文件，安装gulp全局变量 npm install -g gulp 安装项目开发所需要的依赖项 npm install --save-dev gulp 安装用来压缩js文件的插件 npm install --save-dev gulp-uglify 安装用来压缩css文件的插件 npm install --save-dev gulp-minify-css 解析less的插件 npm install --save-dev gulp-less 安装用来合并的插件 npm install --save-dev gulp-concat 用来检查js代码的插件 npm install --save-dev gulp-jshint 用来重命名的插件 npm install --save-dev gulp-rename 搭建服务器的插件 npm install --save-dev gulp-connect 一起安装 npm install --save-dev gulp gulp-uglify gulp-minify-css gulp-concat gulp-jshint gulp-rename 在项目根目录下建一个以gulpfile.js命名的文本 文件的压缩示例编辑根目录下的gulifile.js文件 var gulp = require('gulp'); //定义依赖项concat = require('gulp-concat'); //定义合并插件mincss = require('gulp-minify-css'); //定义压缩css的插件minjs = require('gulp-uglify'); //定义压缩js的插件rename = require('gulp-rename');//定义重命名插件//定义任务 第一个是任务名字，第二个是要执行哪些操作gulp.task('css', function() &#123; gulp.src(['css/*.css']) //操作css文件夹中所有的css文件 // gulp.src(['css/a.css'.'css.b.css']) //操作css文件夹中ab文件 .pipe(concat('min.css')) //执行合并插件并给合并完成的插件起一个名字 .pipe(mincss()) //执行压缩插件 .pipe(rename(&#123;suffix:'.xianyu'&#125;))//执行重命名插件 .pipe(gulp.dest('css1'))//把执行以上操作后的文件放在css1文件夹里面&#125;);gulp.task('js', function() &#123; gulp.src(['js/*.js']) //操作js文件夹中所有的js文件 // gulp.src(['js/a.js'.'js.b.js']) //操作js文件夹中ab文件 .pipe(concat('min.js')) //执行合并插件并给合并完成的插件起一个名字 .pipe(minjs()) //执行压缩插件 .pipe(rename(&#123;suffix:'.xianyu'&#125;))//执行重命名插件 .pipe(gulp.dest('js'))//把执行以上操作后的文件放在js文件夹里面&#125;);gulp.task('default',['css','js']); //执行任务名为css的任务//自动执行压缩任务gulp.watch('css/*.css',['css']); //如果css文件夹下任何一个css有变动，则执行名字为css的任务gulp.watch('js/*.js',['js']); //如果js文件夹下任何一个js有变动，则执行名字为js的任务 运行 gulp： gulp 实现热更新的例子 var gulp = require('gulp');concat = require('gulp-concat'); //定义合并插件less = require('gulp-less'); //定义less编译插件mincss = require('gulp-minify-css'); //定义压缩css的插件minjs = require('gulp-uglify'); //定义压缩js的插件sourcemaps = require('gulp-sourcemaps'); //定义sourcemapsconnect = require('gulp-connect'); //自动刷新服务gulp.task('Less', function () &#123; gulp.src('src/less/*.less') //入口文件目录 .pipe(sourcemaps.init()) .pipe(less()) //执行less .pipe(concat('min.css')) //合并文件 .pipe(mincss()) //压缩css .pipe(sourcemaps.write('./')) //生成sourcemaps .pipe(gulp.dest('dist/src/css')) //出口目录&#125;);gulp.task('js', function() &#123; gulp.src(['src/js/*.js']) //入口文件 .pipe(sourcemaps.init()) .pipe(concat('min.js')) //合并文件 .pipe(minjs()) //执行压缩插件 .pipe(sourcemaps.write('./')) //生成sourcemaps .pipe(gulp.dest('dist/src/js')) //出口目录&#125;);gulp.task('html', function () &#123; gulp.src('./dist/*.html') .pipe(connect.reload());&#125;);gulp.task('connect', function() &#123; //搭建服务器 connect.server(&#123; root: 'dist', livereload: true, port:8080 &#125;);&#125;);gulp.task('default',['Less','js','connect','html']); //执行任务//自动执行压缩任务gulp.watch('src/less/*.less',['Less']); //监视less文件gulp.watch('src/js/*.js',['js']); //监视js文件gulp.watch('dist/*.html',['html']); //监视js文件]]></content>
      <categories>
        <category>Gulp使用参考</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp入门指南]]></title>
    <url>%2F2017%2F06%2F12%2FGulp--%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率 1. 全局安装 gulp：$ npm install --global gulp 2. 作为项目的开发依赖（devDependencies）安装：$ npm install --save-dev gulp 3. 在项目根目录下创建一个名为 gulpfile.js 的文件：var gulp = require('gulp');gulp.task('default', function() &#123; // 将你的默认的任务代码放在这&#125;); 4. 运行 gulp：$ gulp 默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。 想要单独执行特定的任务（task），请输入 gulp &lt;task&gt; &lt;othertask&gt;。]]></content>
      <categories>
        <category>Gulp使用参考</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
</search>
