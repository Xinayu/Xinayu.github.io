[{"title":"其他事件","url":"%2F2019%2F02%2F11%2FJS%E4%BA%8B%E4%BB%B6--%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6%2F","content":"\n#### `session` 历史事件\n`hashchange` 事件:`URL` 的 `hash` 部分（即`#`号后面的部分，包括#号）发生变化时触发,一般在window对象上监听\n```js\n// URL 是 http://www.example.com/\nwindow.addEventListener('hashchange', myFunction);\n\nfunction myFunction(e) {\n  console.log(e.oldURL);\n  console.log(e.newURL);\n}\n\nlocation.hash = 'part2';\n// http://www.example.com/\n// http://www.example.com/#part2\n```\n\n#### 网页状态事件\n+ `DOMContentLoaded` :网页下载并解析完成以后，浏览器就会在document对象上触发 \n> 仅仅完成了网页的解析（整张页面的 DOM 生成了），所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束。也就是说，这个事件比load事件，发生时间早得多。\n```js\ndocument.addEventListener('DOMContentLoaded', function (event) {\n  console.log('DOM生成');\n});\n```\n\n+ `readystatechange()`：当 `Document` 对象和 `XMLHttpRequest` 对象的`readyState`属性发生变化时触发\n```js\n// loading：网页正在夹杂\n// interactive：网页解析完成，外部资源仍在加载\n// complete：网页解析完成，外部资源加载完成，即将出发load事件\ndocument.onreadystatechange = function () {\n  if (document.readyState === 'interactive') {\n    // ...\n  }\n}\n```\n\n#### 窗口事件\n+ `scroll` 事件：文档或文档元素滚动时触发，主要出现在用户拖动滚动条\n    结合节流函数进行监听\n    ```js\n    // 限制在一秒一次\n    function throttle(fn, wait) {\n        var time = Date.now();\n        return function() {\n            if ((time + wait - Date.now()) < 0) {\n            fn();\n            time = Date.now();\n            }\n        }\n    }\n\n    window.addEventListener('scroll', throttle(callback, 1000));\n    ```\n    > `debounce`是防抖，**连续操作**结束后执行\n    > `throttle`节流，确保一段时间内只执行**一次**\n    > 所以用户滚动应该使用节流\n\n+ `resize `事件：浏览器窗口大小时触发，主要发生在window对象上面\n    ```js\n    var resizeMethod = function () {\n        if (document.body.clientWidth < 768) {\n            console.log('移动设备的视口');\n        }\n    };\n\n    window.addEventListener('resize', resizeMethod, true);\n    ```\n\n#### 焦点事件\n发生在元素节点和`document`对象上面，与获得或失去焦点相关。它主要包括以下四个事件。\n+ `focus`：元素节点获得焦点后触发，该事件不会冒泡。\n+ `blur`：元素节点失去焦点后触发，该事件不会冒泡。\n+ `focusin`：元素节点将要获得焦点时触发，发生在`focus`事件之前。该事件会冒泡。\n+ `focusout`：元素节点将要失去焦点时触发，发生在`blur`事件之前。该事件会冒泡。\n这些事件继承了`FocusEvent`接口，具有以下属性：\n+ `FocusEvent.target`：事件的目标节点。\n+ `FocusEvent.relatedTarget`：对于`focusin`事件，返回失去焦点的节点；对于`focusout`事件，返回将要接受焦点的节点；对于`focus`和`blur`事件，返回null。\n\n```js\n// 表单的文本输入框，接受焦点时设置背景色，失去焦点时去除背景色\n// focus和blur事件不会冒泡，只能在捕获阶段触发，所以addEventListener方法的第三个参数需要设为true。\nform.addEventListener('focus', function (event) {\n  event.target.style.background = 'pink';\n}, true);\n\nform.addEventListener('blur', function (event) {\n  event.target.style.background = '';\n}, true);\n```","tags":["JS事件"],"categories":["JS事件"]},{"title":"触摸事件","url":"%2F2019%2F02%2F09%2FJS%E4%BA%8B%E4%BB%B6--%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%2F","content":"\n#### 概述\n浏览器的触摸API由三个部分组成\n\n+ `Touch`：一个触摸点\n+ `TouchList`：多个触摸点的集合\n+ `TouchEvent`：触摸引发的事件实例\n\n很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用`event.preventDefault`方法阻止发出鼠标事件。\n\n#### `Touch`接口\n单个触点产生`Touch`实例\n```js\nvar touch = new Touch(touchOptions);\n```\n##### 实例属性:\n+ `identifier`：返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束\n    ```js\n    someElement.addEventListener('touchmove', function (e) {\n        for (var i = 0; i < e.changedTouches.length; i++) {\n            console.log(e.changedTouches[i].identifier);\n        }\n    }, false);\n    ```\n\n+ `screenX`，`screenY`，`clientX`，`clientY`，`pageX`，`pageY`\n\n    `Touch.screenX`属性和`Touch.screenY`属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。\n\n    `Touch.clientX`属性和`Touch.clientY`属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。\n\n    `Touch.pageX`属性和`Touch.pageY`属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。\n\n+ `radiusX`，`radiusY`，`rotationAngle`\n\n    `Touch.radiusX`属性和`Touch.radiusY`属性，分别返回触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度。\n\n    `Touch.rotationAngle`属性表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间。\n\n    ```js\n    // 指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域\n    div.addEventListener('touchstart', rotate);\n    div.addEventListener('touchmove', rotate);\n    div.addEventListener('touchend', rotate);\n\n    function rotate(e) {\n        var touch = e.changedTouches.item(0);\n        e.preventDefault();\n\n        src.style.width = touch.radiusX * 2 + 'px';\n        src.style.height = touch.radiusY * 2 + 'px';\n        src.style.transform = 'rotate(' + touch.rotationAngle + 'deg)';\n    };\n    ```\n+ `force`：返回一个0到1之间的数值，表示触摸压力。0代表没有压力，1代表硬件所能识别的最大压力。\n\n+ `target`：返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。\n\n\n#### `TouchList` 接口\n一组触摸点的集合。它的实例是一个类似数组的对象，成员是**`Touch`的实例对象**`，表示所有触摸点。\n它的实例主要通过触摸事件的`TouchEvent.touches`、`TouchEvent.changedTouches`、`TouchEvent.targetTouches`这几个属性获取。\n\n它的实例属性和实例方法只有两个。\n\n+ `TouchList.length`：数值，表示成员数量（即触摸点的数量）。\n+ `TouchList.item()`：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。\n\n#### `TouchEvent` 接口\n`TouchEvent` 接口继承了 `Event` 接口，表示由触摸引发的事件实例\n\n##### 实例属性\n+ `altKey`：布尔值，表示触摸时是否按下了 Alt 键\n+ `ctrlKey`：布尔值，表示触摸时是否按下了 Ctrl 键\n+ `shiftKey`：布尔值：表示触摸时是否按下了 Shift 键\n+ `metaKey`：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）\n```js\nsomeElement.addEventListener('touchstart', function (e) {\n  console.log('altKey = ' + e.altKey);\n  console.log('ctrlKey = ' + e.ctrlKey);\n  console.log('metaKey = ' + e.metaKey);\n  console.log('shiftKey = ' + e.shiftKey);\n}, false);\n```\n\n+ `changedTouches`：返回一个`TouchList`实例，成员是一组Touch实例对象，表示本次触摸事件的相关触摸点\n    对于不同的时间，该属性的含义有所不同。\n\n     + `touchstart`事件：被激活的触摸点\n     + `touchmove`事件：发生变化的触摸点\n     + `touchend`事件：消失的触摸点（即不再被触碰的点）\n     ```js\n     someElement.addEventListener('touchmove', function (e) {\n        for (var i = 0; i < e.changedTouches.length; i++) {\n            console.log(e.changedTouches[i].identifier);\n        }\n    }, false);\n     ```\n\n+ `touches`：返回一个`TouchList`实例，成员是所有仍然处于活动状态（即触摸中）的触摸点。一般来说，一个手指就是一个触摸点\n    ```js\n    someElement.addEventListener('touchstart', function (e) {\n        switch (e.touches.length) {\n            // 一根手指触摸\n            case 1: handle_one_touch(e); break;\n            // 两根手指触摸\n            case 2: handle_two_touches(e); break;\n            // 三根手指触摸\n            case 3: handle_three_touches(e); break;\n            // 其他情况\n            default: console.log('Not supported'); break;\n        }\n    }, false);\n    ```\n\n+ `targetTouches`：返回一个`TouchList`实例，成员是触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点\n    ```js\n    // 判断是否所有的触摸点都在目标元素内\n    function touches_in_target(ev) {\n        return (ev.touches.length === ev.targetTouches.length ? true : false);\n    }\n    ```\n\n#### 触摸事件的种类\n通过`TouchEvent.type`属性查看:\n+ `touchstart`：用户开始触摸时触发，它的`target`属性返回发生触摸的元素节点。\n+ `touchend`：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的`target`属性与`touchstart`事件一致的，就是开始触摸时所在的元素节点。它的`changedTouches`属性返回一个`TouchList`实例，包含所有不再触摸的触摸点（即`Touch`实例对象）。\n+ `touchmove`：用户移动触摸点时触发，它的`target`属性与`touchstart`事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。\n+ `touchcancel`：触摸点取消时触发，比如在触摸区域跳出一个模态窗口`（modal window）`、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。\n\n```js\nvar el = document.getElementsByTagName('canvas')[0];\nel.addEventListener('touchstart', handleStart, false);\nel.addEventListener('touchmove', handleMove, false);\n\nfunction handleStart(evt) {\n  evt.preventDefault();\n  var touches = evt.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    console.log(touches[i].pageX, touches[i].pageY);\n  }\n}\n\nfunction handleMove(evt) {\n  evt.preventDefault();\n  var touches = evt.changedTouches;\n  for (var i = 0; i < touches.length; i++) {\n    var touch = touches[i];\n    console.log(touch.pageX, touch.pageY);\n  }\n}\n```\n","tags":["JS事件"],"categories":["JS事件"]},{"title":"拖拉事件","url":"%2F2019%2F02%2F09%2FJS%E4%BA%8B%E4%BB%B6--%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6%2F","content":"\n#### 拖拉事件的种类\n网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让元素节点可拖拉，可以将该节点的`draggable`属性设为`true`。\n```html\n<!-- 如果不想让图片等可以拖拉，设置值为false即可 -->\n<div draggable=\"true\">\n  此区域可拖拉\n</div>\n```\n> 一旦某个元素节点的`draggable`属性设为`true`，就无法再用鼠标选中该节点内部的文字或子节点了。\n\n当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。\n\n+ `drag`：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。\n\n+ `dragstart`：用户开始拖拉时，在被拖拉的节点上触发，该事件的`target`属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。\n\n+ `dragend`：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的`target`属性是被拖拉的节点。它与`dragstart`事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，`dragend`事件总是会触发的。\n\n+ `dragenter`：拖拉进入当前节点时，在当前节点上触发一次，该事件的`target`属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下`（drop）`拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。\n\n+ `dragover`：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的`target`属性是当前节点。该事件与`dragenter`事件的区别是，`dragenter`事件在进入该节点时触发，然后只要没有离开这个节点，`dragover`事件会持续触发。\n\n+ `dragleave`：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的`target`属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。\n\n+ `drop`：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许drop，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 `ESC` 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。\n\n```js\n// div节点被拖动时，背景色会变为红色，拖动结束，又变回绿色\ndiv.addEventListener('dragstart', function (e) {\n  this.style.backgroundColor = 'red';\n}, false);\n\ndiv.addEventListener('dragend', function (e) {\n  this.style.backgroundColor = 'green';\n}, false);\n```\n\n##### 例子：将一个节点从点钱父节点托拉到另一个父节点中\n```js\n/* HTML 代码如下\n <div class=\"dropzone\">\n   <div id=\"draggable\" draggable=\"true\">\n     该节点可拖拉\n   </div>\n </div>\n <div class=\"dropzone\"></div>\n <div class=\"dropzone\"></div>\n <div class=\"dropzone\"></div>\n*/\n\n// 被拖拉节点\nvar dragged;\n\ndocument.addEventListener('dragstart', function (event) {\n  // 保存被拖拉节点\n  dragged = event.target;\n  // 被拖拉节点的背景色变透明\n  event.target.style.opacity = 0.5;\n}, false);\n\ndocument.addEventListener('dragend', function (event) {\n  // 被拖拉节点的背景色恢复正常\n  event.target.style.opacity = '';\n}, false);\n\ndocument.addEventListener('dragover', function (event) {\n  // 防止拖拉效果被重置，允许被拖拉的节点放入目标节点\n  event.preventDefault();\n}, false);\n\ndocument.addEventListener('dragenter', function (event) {\n  // 目标节点的背景色变紫色\n  // 由于该事件会冒泡，所以要过滤节点\n  if (event.target.className === 'dropzone') {\n    event.target.style.background = 'purple';\n  }\n}, false);\n\ndocument.addEventListener('dragleave', function( event ) {\n  // 目标节点的背景色恢复原样\n  if (event.target.className === 'dropzone') {\n    event.target.style.background = '';\n  }\n}, false);\n\ndocument.addEventListener('drop', function( event ) {\n  // 防止事件默认行为（比如某些元素节点上可以打开链接），\n  event.preventDefault();\n  if (event.target.className === 'dropzone') {\n    // 恢复目标节点背景色\n    event.target.style.background = '';\n    // 将被拖拉节点插入目标节点\n    dragged.parentNode.removeChild(dragged);\n    event.target.appendChild( dragged );\n  }\n}, false);\n\n```\n> 拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。\n> 将文件从操作系统拖拉进浏览器，不会触发dragstart和dragend事件。\n\n#### `DragEvent` 接口\n拖拉事件都继承了`DragEvent`接口，这个接口又继承了`MouseEvent`接口和`Event`接口。\n```js\nnew DragEvent(type, options)\n```\n`DragEvent()`构造函数接受两个参数，第一个参数是字符串，表示事件的类型，该参数必须；第二个参数是事件的配置对象，用来设置事件的属性，该参数可选。\n\n配置对象除了接受`MouseEvent`接口和`Event`接口的配置属性，还可以设置`dataTransfer`属性要么是null，要么是一个`DataTransfer`接口的实例。\n\n#### `DataTransfer` 接口概述\n所有拖拉事件的实例都有一个`DragEvent.dataTransfer`属性，用来**读写需要传递的数据**。这个属性的值是一个`DataTransfer`接口的实例。\n\n拖拉的数据分成两方面：数据的种类（又称格式）和数据的值。数据的种类是一个 MIME 字符串（比如`text/plain、image/jpeg`），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 `URL`。\n\n拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过`dragenter`和`dragover`事件的监听函数，检查数据类型，以确定是否允许放下`（drop）`被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为`text/uri-list`。\n\n发生`drop`事件时，监听函数取出拖拉的数据，对其进行处理。\n\n#### `DataTransfer` 的实例属性\n+ `dropEffect`:设置放下`（drop）`被拖拉节点时的效果，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值\n    ```js\n    // copy：复制被拖拉的节点\n    // move：移动被拖拉的节点\n    // link：创建指向被拖拉的节点的链接\n    // none：无法放下被拖拉的节点\n\n    target.addEventListener('dragover', function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n        e.dataTransfer.dropEffect = 'copy';\n    });\n    // 拖拉元素一旦drop，接受的区域会复制该节点\n    // dropEffect属性一般在dragenter和dragover事件的监听函数中设置，对于dragstart、drag、dragleave这三个事件，该属性不起作用。因为该属性只对接受被拖拉的节点的区域有效，对被拖拉的节点本身是无效的。进入目标区域后，拖拉行为会初始化成设定的效果\n    ```\n\n+ `effectAllowed`：设置本次拖拉中允许的效果\n    ```js\n    // copy：复制被拖拉的节点\n    // move：移动被拖拉的节点\n    // link：创建指向被拖拉节点的链接\n    // copyLink：允许copy或link\n    // copyMove：允许copy或move\n    // linkMove：允许link或move\n    // all：允许所有效果\n    // none：无法放下被拖拉的节点\n    // uninitialized：默认值，等同于all\n\n    source.addEventListener('dragstart', function (e) {\n     e.dataTransfer.effectAllowed = 'move';\n    });\n\n    target.addEventListener('dragover', function (e) {\n        ev.dataTransfer.dropEffect = 'move';\n    });\n    // 只要dropEffect属性和effectAllowed属性之中，有一个为none，就无法在目标节点上完成drop操作\n    ```\n\n+ `files`：一个 FileList 对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象\n\n    接收拖拉文件的例子：\n    ```js\n    // HTML 代码如下\n    // <div id=\"output\" style=\"min-height: 200px;border: 1px solid black;\">\n    //   文件拖拉到这里\n    // </div>\n    var div = document.getElementById('output');\n\n    div.addEventListener(\"dragenter\", function( event ) {\n        div.textContent = '';\n        event.stopPropagation();\n        event.preventDefault();\n    }, false);\n\n    div.addEventListener(\"dragover\", function( event ) {\n        event.stopPropagation();\n        event.preventDefault();\n    }, false);\n\n    div.addEventListener(\"drop\", function( event ) {\n        event.stopPropagation();\n        event.preventDefault();\n        var files = event.dataTransfer.files;\n        for (var i = 0; i < files.length; i++) {\n            div.textContent += files[i].name + ' ' + files[i].size + '字节\\n';\n        }\n    }, false);\n    ```\n    读取文件内容:\n    ```js\n    div.addEventListener('drop', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n\n    var fileList = e.dataTransfer.files;\n        if (fileList.length > 0) {\n            var file = fileList[0];\n            var reader = new FileReader();\n            reader.onloadend = function(e) {\n                if (e.target.readyState === FileReader.DONE) {\n                    var content = reader.result;\n                    div.innerHTML = 'File: ' + file.name + '\\n\\n' + content;\n                }\n            }\n            reader.readAsBinaryString(file);\n        }\n    });\n    ```\n\n+ `types`：只读的数组，每个成员是一个字符串，里面是拖拉的数据格式（通常是 `MIME `值）。比如，如果拖拉的是文字，对应的成员就是`text/plain`。\n    ```js\n    //只有当被拖拉的节点是一个链接时，才允许在当前节点放下\n    function contains(list, value){\n        for (var i = 0; i < list.length; ++i) {\n            if(list[i] === value) return true;\n        }\n        return false;\n    }\n\n    function doDragOver(event) {\n        var isLink = contains(event.dataTransfer.types, 'text/uri-list');\n        if (isLink) event.preventDefault();\n    }\n    ```\n\n+ `items`：返回一个类似数组的只读对象（`DataTransferItemList` 实例），每个成员就是本次拖拉的一个对象（`DataTransferItem` 实例）。如果本次拖拉不包含对象，则返回一个空对象\n\n#### `DataTransfer` 的实例方法\n+ `setData()`：设置拖拉事件所带有的数据\n    ```js\n    // 为当前的拖拉事件加入纯文本数据。\n\n    event.dataTransfer.setData('text/plain', 'Text to drag');\n\n    // 该方法接受两个参数，都是字符串。第一个参数表示数据类型（比如text/plain），第二个参数是具体数据。如果指定类型的数据在dataTransfer属性不存在，那么这些数据将被加入，否则原有的数据将被新数据替换。\n    ```\n    如果是拖拉文本框或者拖拉选中的文本，会默认将对应的文本数据，添加到`dataTransfer`属性，不用手动指定。\n    ```js\n    // 使用setData方法，可以替换到原有数据。\n    <div draggable=\"true\" ondragstart=\"event.dataTransfer.setData('text/plain', 'bbb')\">\n        aaa\n    </div>\n    ```\n\n+ `getData()`：接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用`setData`方法添加的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有`drop`事件触发后，才能取出数据\n    ```js\n    // 从多种类型的数据里面取出数据\n    function doDrop(event) {\n        var types = event.dataTransfer.types;\n        var supportedTypes = ['text/uri-list', 'text/plain'];\n        types = supportedTypes.filter(function (value) { types.includes(value) });\n        if (types.length) {\n            var data = event.dataTransfer.getData(types[0]);\n        }\n        event.preventDefault();\n    }\n    ```\n\n+ `clearData()`：删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果\n\n+ `setDragImage()`：手动设置拖动过程中，跟鼠标一起移动的显示的图片\n    ```js\n    /* HTML 代码如下\n    <div id=\"drag-with-image\" class=\"dragdemo\" draggable=\"true\">\n        drag me\n    </div>\n    */\n    var div = document.getElementById('drag-with-image');\n    div.addEventListener('dragstart', function (e) {\n        var img = document.createElement('img');\n        img.src = 'http://path/to/img';\n        e.dataTransfer.setDragImage(img, 0, 0);\n    }, false);\n    ```","tags":["JS事件"],"categories":["JS事件"]},{"title":"Location对象","url":"%2F2019%2F02%2F08%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B--Location%E5%AF%B9%E8%B1%A1%2F","content":"`Location`对象是浏览器提供的原生对象，提供 `URL` 相关的信息和操作方法。通过`window.location`和`document.location`属性，可以拿到这个对象\n\n#### 属性\n+ `Location.href`：整个 URL。\n+ `Location.protocol`：当前 URL 的协议，包括冒号（:）。\n+ `Location.host`：主机，包括冒号（:）和端口（默认的80端口和443端口会省略）。\n+ `Location.hostname`：主机名，不包括端口。\n+ `Location.port`：端口号。\n+ `Location.pathname`：URL 的路径部分，从根路径/开始。\n+ `Location.search`：查询字符串部分，从问号?开始。\n+ `Location.hash`：片段字符串部分，从#开始。\n+ `Location.username`：域名前面的用户名。\n+ `Location.password`：域名前面的密码。\n+ `Location.origin：URL` 的协议、主机名和端口。\n```js\n// 跳转到新网址\ndocument.location = 'http://www.example.com';\n// 等同于\ndocument.location.href = 'http://www.example.com';\n\n// 滚动到新的锚点\ndocument.location.href = '#top';\n// 等同于\ndocument.location.hash = '#top';\n```\n\n#### 方法\n+ `Location.assign()`：浏览器立刻跳转到新的 URL\n+ `Location.replace()`：览器立刻跳转到新的 URL（删除历史无法回到当前页面）\n+ `Location.reload()`：重新加载当前网址，相当于按下浏览器的刷新按钮\n    ```js\n    // 网页将滚动到头部（即scrollTop === 0）\n    window.location.reload(true);\n    ```\n\n#### `URL`的编码和解码\n不合法字符（如中文）会被**转义**，规则是根据操作系统的默认编码，将每个字节转为**百分号（%）**加上两个**大写的十六进制字母**。\n##### 转码\n+ `encodeURI()`：转码整个 URL\n    ```js\n    encodeURI('http://www.example.com/q=春节')\n    // \"http://www.example.com/q=%E6%98%A5%E8%8A%82\"\n    ```\n    \n+ `encodeURIComponent()`：转码 URL 的组成部分\n    ```js\n    encodeURIComponent('春节')\n    // \"%E6%98%A5%E8%8A%82\"\n    encodeURIComponent('http://www.example.com/q=春节')\n    // \"http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82\"\n    ```\n\n##### 解码\n+ `decodeURI()`：整个 URL 的解码,是`encodeURI()`方法的逆运算\n    ```js\n    decodeURI('http://www.example.com/q=%E6%98%A5%E8%8A%82')\n    // \"http://www.example.com/q=春节\"\n    ```\n\n+ `decodeURIComponent()`：URL 片段的解码，是`encodeURIComponent()`方法的逆运算\n    ```js\n    decodeURIComponent('%E6%98%A5%E8%8A%82')\n    // \"春节\"\n    ```\n\n","tags":["URL"],"categories":["浏览器模型"]},{"title":"表单模型","url":"%2F2019%2F02%2F08%2FJS%E4%BA%8B%E4%BB%B6--%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6%2F","content":"\n#### 表单事件的种类\n+ `input`事件\n\n    `input`事件当`<input>`、`<select>`、`<textarea>`的值发生变化时触发。对于复选框（`<input type=checkbox>`）或单选框（`<input type=radio>`），用户改变选项时，也会触发这个事件。另外，对于打开`contenteditable`属性的元素，只要值发生变化，也会触发`input`事件。\n\n    input事件会连续触发，比如用户每按下一次按键，就会触发一次input事件。\n\n    input事件对象继承了InputEvent接口。\n    ```js\n    /* HTML 代码如下\n    <select id=\"mySelect\">\n    <option value=\"1\">1</option>\n    <option value=\"2\">2</option>\n    <option value=\"3\">3</option>\n    </select>\n    */\n\n    function inputHandler(e) {\n    console.log(e.target.value)\n    }\n\n    var mySelect = document.querySelector('#mySelect');\n    mySelect.addEventListener('input', inputHandler);\n    ```\n\n+ `slect`事件\n\n    `<input>`、`<textarea>`里面选中文本时触发。\n    ```js\n    // HTML 代码如下\n    // <input id=\"test\" type=\"text\" value=\"Select me!\" />\n\n    var elem = document.getElementById('test');\n    elem.addEventListener('select', function (e) {\n        console.log(e.type); // \"select\"\n    }, false);\n    ```\n+ `change`事件\n\n    `change`事件当`<input>`、`<select>`、`<textarea>`的值发生变化时触发。它与`input`事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面`input`事件必然伴随`change`事件。具体来说，分成以下几种情况。\n\n     + 激活单选框`（radio）`或复选框`（checkbox）`时触发。\n     + 用户提交时触发。比如，从下列列表`（select）`完成选择，在日期或文件输入框完成选择。\n     + 当文本框或`<textarea>`元素的值发生改变，并且丧失焦点时触发。\n\n+ `invalid`事件\n    用户提交表单时，如果表单元素的值不满足校验条件，就会触发invalid事件\n    ```js\n    <form>\n        <input type=\"text\" required oninvalid=\"console.log('invalid input')\" />\n        <button type=\"submit\">提交</button>\n    </form>\n\n    // 输入框如果不填，用户点击按钮提交时会触发输入框的invalid事件，导致提交被取消\n    ```\n\n+ `reset` 事件，`submit` 事件\n\n    这两个事件发生在表单对象`<form>`上，而不是发生在表单的成员上。\n\n    reset事件当表单重置（所有表单成员变回默认值）时触发。\n\n    submit事件当表单数据向服务器提交时触发。注意，submit事件的发生对象是`<form>`元素，而不是`<button>`元素，因为提交的是表单，而不是按钮。\n\n#### `InputEvent` 接口\n`InputEvent` 接口用来描述`input`事件的实例，继承`Event`接口并且有自己的属性和方法\n\n实例属性：\n+ `data`：返回一个字符串，表示变动的内容\n\n    ```js\n    // HTML 代码如下\n    // <input type=\"text\" id=\"myInput\">\n    var input = document.getElementById('myInput');\n    input.addEventListener('input', myFunction, false);\n\n    function myFunction(e) {\n        console.log(e.data);\n    }\n\n    // 如果手动在输入框里面输入abc，控制台会先输出a，再在下一行输出b，再在下一行输出c。然后选中abc，一次性将它们删除，控制台会输出null或一个空字符串\n    ```\n\n+ `inputType`:返回一个字符串，表示字符串发生变更的类型\n\n    常见情况：\n     + 手动插入文本：`insertText`\n     + 粘贴插入文本：`insertFromPaste`\n     + 向后删除：`deleteContentBackward`\n     + 向前删除：`deleteContentForward`\n\n+ `dataTransfer`：返回一个 `DataTransfer` 实例。该属性只在文本框接受粘贴内容`（insertFromPaste）`或拖拽内容`（insertFromDrop）`时才有效","tags":["JS事件"],"categories":["JS事件"]},{"title":"键盘模型","url":"%2F2019%2F02%2F07%2FJS%E4%BA%8B%E4%BB%B6--%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%2F","content":"\n#### 键盘事件的分类\n键盘事件由用户击打键盘触发，主要有`keydown`、`keypress`、`keyup`三个事件，它们都继承了`KeyboardEvent`接口。\n\n+ `keydown`：按下键盘时触发。\n+ `keypress`：按下有值的键时触发，即按下 `Ctrl`、`Alt`、`Shift`、`Meta` 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发`keydown`事件，再触发这个事件。\n+ `keyup`：松开键盘时触发该事件。\n\n#### `KeyboardEvent` 的实例属性\n+ `altKey`：是否按下了`Alt`键\n+ `ctrlKey`：是否按下了`Ctrl`键\n+ `metaKey`：是否按下了`meta`键\n+ `shiftKey`：是否按下了`Shift `键\n+ `code`：返回一个字符串，表示当前按下的键的字符串形式，只读\n    + 数字键`0 - 9`：返回`digital0 - digital9`\n    + 字母键`A - z`：返回`KeyA - KeyZ`\n    + 功能键`F1 - F12`：返回 `F1 - F12`\n    + 方向键：返回`ArrowDown`、`ArrowUp`、`ArrowLeft`、`ArrowRight`\n    + `Alt` 键：返回`AltLeft`或`AltRight`\n    + `Shift` 键：返回`ShiftLeft`或`ShiftRight`\n    + `Ctrl` 键：返回`ControlLeft`或`ControlRight`\n+ `key`：返回一个字符串，表示按下的键名，只读\n    如果同时按下一个控制键和一个符号键，则返回符号键的键名。比如，按下 Ctrl + a，则返回a；按下 Shift + a，则返回大写的A。\n\n    如果无法识别键名，返回字符串Unidentified。\n+ `location`：返回一个整数，表示按下的键处在键盘的哪一个区域\n    + 0：处在键盘的主区域，或者无法判断处于哪一个区域。\n    + 1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。\n    + 2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。\n    + 3：处在数字小键盘。\n+ `repeat`: 返回一个布尔值，代表该键是否被按着不放\n\n#### `KeyboardEvent` 的实例方法\n+ `getModifierState()`：方法返回一个布尔值，表示是否按下或激活指定的功能键\n```js\n// Alt：Alt 键\n// CapsLock：大写锁定键\n// Control：Ctrl 键\n// Meta：Meta 键\n// NumLock：数字键盘开关键\n// Shift：Shift 键\nif (\n  event.getModifierState('Control') +\n  event.getModifierState('Alt') +\n  event.getModifierState('Meta') > 1\n) {\n  return;\n}\n// 只要Control、Alt、Meta里面，同时按下任意两个或两个以上的键就返回\n```js\n","tags":["JS事件"],"categories":["JS事件"]},{"title":"键盘事件","url":"%2F2019%2F02%2F07%2FJS%E4%BA%8B%E4%BB%B6--%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6%2F","content":"\n#### 进度事件种类\n进度事件用来描述资源加载的进度，主要由 AJAX 请求、`<img>`、`<audio>`、`<video>`、`<style>`、`<link>`等外部资源的加载触发，继承了`ProgressEvent接口`。它主要包含以下几种事件。\n\n+ `abort`：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。\n+ `error`：由于错误导致外部资源无法加载时触发。\n+ `load`：外部资源加载成功时触发。\n+ `loadstart`：外部资源开始加载时触发。\n+ `loadend`：外部资源停止加载时触发，发生顺序排在error、abort、load等事件的后面。\n+ `progress`：外部资源加载过程中不断触发。\n+ `timeout`：加载超时时触发。\n\n#### 判断`img`加载完成\n运用`img`的`completed`属性判断是否加载完成\n```js\nfunction loaded() {\n  // ...\n}\n\nif (image.complete) {\n  loaded();\n} else {\n  image.addEventListener('load', loaded);\n}\n\n```\n由于 `DOM` 的元素节点没有提供是否加载错误的属性，所以`error`事件的监听函数最好放在`<img>`元素的 `HTML` 代码中，这样才能保证发生加载错误时百分之百会执行。\n```js\n<img src=\"/wrong/url\" onerror=\"this.style.display='none';\" />\n```\n当然，动态添加的`<img>`元素可以实时监听错误\n> `error`事件不会冒泡\n\n","tags":["JS事件"],"categories":["JS事件"]},{"title":"鼠标事件","url":"%2F2019%2F02%2F05%2FJS%E4%BA%8B%E4%BB%B6--%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%2F","content":"每个鼠标事件会产生一个`MouseEvent`实例，`MouseEvent`接口代表鼠标相关事件，继承了`Event`接口并且拥有独有的方法和属性。\n```js\nvar event = new MouseEvent(type, options);\n```\n#### 实例属性\n按下对应的键盘：\n+ `altKey`：Alt 键\n+ `ctrlKey`：Ctrl 键\n+ `metaKey`：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）\n+ `shiftKey`：Shift 键\n按下了鼠标的哪个键：`MouseEvent.button`,只读\n\n  + 0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如mousemove事件）。\n  + 1：按下辅助键（通常是中键或者滚轮键）。\n  + 2：按下次键（通常是右键）。\n\n    返回一个三个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况。该属性只读\n  + 1：二进制为001（十进制的1），表示按下左键。\n  + 2：二进制为010（十进制的2），表示按下右键。\n  + 4：二进制为100（十进制的4），表示按下中键或滚轮键。\n\n+ `clientX`和`clientY`：返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素）和垂直坐标（单位像素），属性只读。\n    ```js\n    // HTML 代码为\n    // <body onmousedown=\"showCoords(event)\">\n    function showCoords(evt){\n        console.log(\n            'clientX value: ' + evt.clientX + '\\n' +\n            'clientY value: ' + evt.clientY + '\\n'\n        );\n    }\n    ```\n\n+ `movementX`和`movementY`：返回当前位置与上一个mousemove事件之间的水平距离（单位像素）和垂直距离（单位像素），只读\n    ```js\n    // movementX等于下面的计算公式\n    currentEvent.movementX = currentEvent.screenX - previousEvent.screenX\n\n    // movementY等于下面的计算公式\n    currentEvent.movementY = currentEvent.screenY - previousEvent.screenY\n    ```\n\n+ `screenX`和`screenY`：返回鼠标位置相对于屏幕左上角的水平坐标（单位像素）和垂直坐标（单位像素），只读\n    ```js\n    // HTML 代码如下\n    // <body onmousedown=\"showCoords(event)\">\n    function showCoords(evt) {\n        console.log(\n            'screenX value: ' + evt.screenX + '\\n',\n            'screenY value: ' + evt.screenY + '\\n'\n        );\n    }\n    ```\n\n+ `offsetX`和`offsetY`：`MouseEvent.offsetX`属性返回鼠标位置与目标节点左侧的`padding`边缘的水平距离（单位像素），`MouseEvent.offsetY`属性返回与目标节点上方的padding边缘的垂直距离，只读\n    ```js\n    /* HTML 代码如下\n    <style>\n        p {\n        width: 100px;\n        height: 100px;\n        padding: 100px;\n        }\n    </style>\n    <p>Hello</p>\n    */\n    var p = document.querySelector('p');\n    p.addEventListener(\n    'click',\n    function (e) {\n        console.log(e.offsetX);\n        console.log(e.offsetY);\n    },\n    false\n    );\n\n    // 鼠标如果在p中心点击，会返回150，150\n    ```\n\n+ `pageX`和`pageY`：返回鼠标位置与文档左侧边缘和上侧边缘的距离（单位像素），只读\n\n#### `WheelEvent` 接口\n`WheelEvent` 接口继承`MouseEvent`实例，表示鼠标滚轮实例对象\n```js\nvar wheelEvent = new WheelEvent(type, options);\n// type:wheel，目前只能是这个\n// deltaX：数值，表示滚轮的水平滚动量，默认值是 0.0。\n// deltaY：数值，表示滚轮的垂直滚动量，默认值是 0.0。\n// deltaZ：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。\n// deltaMode：数值，表示相关的滚动事件的单位，适用于上面三个属性。0表示滚动单位为像素，1表示单位为行，2表示单位为页，默认为0。\n```\n实例属性：\n+ `WheelEvent.deltaX`：数值，表示滚轮的水平滚动量。\n+ `WheelEvent.deltaY`：数值，表示滚轮的垂直滚动量。\n+ `WheelEvent.deltaZ`：数值，表示滚轮的 Z 轴滚动量。\n+ `WheelEvent.deltaMode`：数值，表示上面三个属性的单位，0是像素，1是行，2是页。","tags":["JS事件"],"categories":["JS事件"]},{"title":"Event对象","url":"%2F2019%2F02%2F05%2FJS%E4%BA%8B%E4%BB%B6--Event%E5%AF%B9%E8%B1%A1%2F","content":"事件触发后会产生一个`Event`对象，作为**参数**传递给监听函数\nEvent对象本身就是一个构造函数，可以用来生成新的实例。\n```js\nevent = new Event(type, options);\n```\n事件触发相当于`new`一个`Event`函数，然后传递给监听函数,所以继承了`Event.prototype`\n\n#### 实例属性\n+ `bubbles`：当前事件是否会冒泡,只读\n+ `eventPhase`：事件所处阶段。0：没有发生，1：捕获，2：到达节点，3：冒泡\n+ `cancelable`：事件是否可以取消，只读\n+ `cancelBubble`：布尔值，如果设为true，相当于执行Event.stopPropagation()，可以阻止事件的传播\n+ `defaultPrevented`：该事件是否调用过\n比较重要的属性\n+ `currentTarget`：返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点\n+ `target`：返回原始触发事件的那个节点，即事件最初发生的节点。事件传播过程中，不同节点的监听函数内部的Event.target与Event.currentTarget属性的值是不一样的，前者总是不变的，后者则是指向监听函数所在的那个节点对象。\n    ```js\n    // HTML代码为\n    // <p id=\"para\">Hello <em>World</em></p>\n    function hide(e) {\n    console.log(this === e.currentTarget);  // 总是 true\n    console.log(this === e.target);  // 有可能不是 true\n    e.target.style.visibility = 'hidden';\n    }\n\n    para.addEventListener('click', hide, false);\n    ```\n+ `type`：事件类型，只读\n    ```js\n    var evt = new Event('look');\n    evt.type // \"look\"\n    ```\n+ `detail`：只有浏览器的 UI （用户界面）事件才具有。1：单机，2：双击，3：三击；对于鼠标滚轮事件，Event.detail是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。\n\n#### 实例方法\n+ `preventDefault()`：阻止浏览器的默认行为\n    ```js\n    // HTML 代码为\n    // <input type=\"checkbox\" id=\"my-checkbox\" />\n    var cb = document.getElementById('my-checkbox');\n\n    cb.addEventListener(\n    'click',\n    function (e){ e.preventDefault(); },\n    false\n    );\n    ```\n    浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框\n    > 只是取消浏览器默认行文，不会取消事件的传播\n\n+ `stopPropagation()`：阻止事件的传播\n+ `stopImmediatePropagation()`：阻止通一个事件被其他监听函数调用，阻止更彻底\n+ `composedPath()`：返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。","tags":["JS事件"],"categories":["JS事件"]},{"title":"事件模型","url":"%2F2019%2F02%2F04%2FJS%E4%BA%8B%E4%BB%B6--%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%2F","content":"\n#### 监听函数\n浏览器的**事件模型**，是通过**监听函数**对事件作出反应。就是**事件驱动**。\nJavaScript 有三种方法，可以为事件绑定监听函数。\n+ `HTML` 的 `on-` 属性\n    ```js\n    <div onClick=\"console.log(2)\">\n        <button onClick=\"console.log(1)\">点击</button>\n    </div>\n    ```\n    > 函数要加圆括号\n    > 只在冒泡阶段触发\n    > 可以通过`setAttribute`方法设置`on-`属性\n\n+ 元素节点的事件属性\n    ```js\n    window.onload = doSomething;\n\n    div.onclick = function (event) {\n    console.log('触发事件');\n    };\n    ```\n    只在**冒泡阶段**触发\n\n+ EventTarget.addEventListener\n`Node`节点部署了`EventTarget`接口，所以可以通过`addEventListener`监听事件\n    ```js\n    target.addEventListener(type, listener[, useCapture]);\n    ```\n    默认在**冒泡阶段**触发，可以修改\n\n#### 事件的传播\n事件发生后会在子元素和父元素之间传播，这个传播过程分为三个阶段：\n1. 捕获阶段：从`window`对象传导到目标节点（上层传到底层）\n2. 目标阶段：在目标节点上触发\n3. 冒泡阶段：从目标节点传导悔`window`对象（底层传到上层）\n```js\nvar ul = document.getElementsByClassName('ul')[0];\nvar li = document.getElementsByClassName('li')[0];\n\nul.addEventListener('click', function (event) {\n    console.log('你点击了ul');\n    // 设置在捕获阶段触发\n}, true)\n\nli.addEventListener('click', function (event) {\n    console.log('你点击了li');\n    // 阻止事件冒泡\n    event.stopPropagation();\n})\n\n// 你点击了ul\n// 你点击了按钮\n```\n在捕获阶段先触发`ul`的事件，然后触发`li`的事件，同时阻止了事件冒泡。\n\n#### 事件的代理\n运用事件的冒泡特性，把子节点的监听定义在父节点上\n```js\nvar ul = document.querySelector('ul');\nul.addEventListener('click', function (event) {\n  if (event.target.tagName.toLowerCase() === 'li') {\n    // some code\n  }\n});\n```\n\n#### 阻止事件的传播\n如果不希望事件在捕获阶段和冒泡阶段传播，可以使用`stopPropagation`\n```js\np.addEventListener('click', function (event) {\n  event.stopPropagation();\n  console.log(1);\n});\n```\n只能阻止这个事件的传播，如果该节点还绑定了其他事件，不会被取消还是会触发。\n如果想要彻底取消该事件，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法。\n```js\np.addEventListener('click', function (event) {\n  event.stopImmediatePropagation();\n  console.log(1);\n});\n\np.addEventListener('click', function(event) {\n  // 不会被触发\n  console.log(2);\n});\n```","tags":["JS事件"],"categories":["JS事件"]},{"title":"EventTarget 接口","url":"%2F2019%2F02%2F03%2FJS%E4%BA%8B%E4%BB%B6--EventTarget%20%E6%8E%A5%E5%8F%A3%2F","content":"\n所有`Node`节点部署了`EventTarget`接口，用于事件操作（监听和触发），主要有三个方法：`addEventListener`、`removeEventListener`、`dispatchEvent`\n\n#### 监听事件 `addEventListener`\n一旦事件发生，就会执行回调函数，默认**只在冒泡阶段触发**。\n```js\ntarget.addEventListener(type, listener[, useCapture]);\n```\n1. type：事件名称，大小写敏感。\n2. listener：监听函数。事件发生时，会调用该监听函数。\n3. useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。该参数可选。\n\n```js\nfunction hello() {\n  console.log('Hello world');\n}\n\nvar button = document.getElementById('btn');\nbutton.addEventListener('click', hello, false);\n```\n`useCapture`除了是布尔值，还可以是一个属性配置对象\n+ capture：布尔值，表示该事件是否在捕获阶段触发监听函数\n+ once：布尔值，表示监听函数是否只触发一次，然后就自动移除\n+ passive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告\n```js\nelement.addEventListener('click', function (event) {\n  // 只执行一次的代码\n}, {once: true});\n```\n> 监听函数内部的`this`指向事件所在的对象\n\n#### 移除事件 `removeEventListener`\n```js\ntarget.removeEventListener(type, listener[, options]);\ntarget.removeEventListener(type, listener[, useCapture]);\n```\n1. 字符串，表示需要移除的事件类型\n2. 需要移除的 EventListener 函数（先前使用 addEventListener 方法定义的）\n3. useCapture 可选 指定需要移除的 EventListener 函数是否为事件捕获。如果无此参数，默认值为 false。如果同一个监听事件分别为“事件捕获”和“事件冒泡”注册了一次，一共两次，这两次事件需要分别移除。两者不会互相干扰。\n默认情况下，事件的监听都只在**冒泡阶段捕获**，所以移除事件的时候**默认移除冒泡阶段注册的事件**。\n对函数名的大小写敏感。\n\n#### 事件触发 `dispatchEvent`\n在节点上触发指定事件，触发监听函数（有兼容性问题）\n```js\npara.addEventListener('click', hello, false);\nvar event = new Event('click');\npara.dispatchEvent(event);\n```\n","tags":["JS事件"],"categories":["JS事件"]},{"title":"XMLHttpRequest 对象","url":"%2F2019%2F02%2F03%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B--XMLHttpRequest%20%E5%AF%B9%E8%B1%A1%2F","content":"\n用脚本发起通信，就可以叫做 `AJAX` 通信,有以下几个步骤：\n1. 创建 XMLHttpRequest 实例\n2. 发出 HTTP 请求\n3. 接收服务器传回的数据\n4. 更新网页数据\n```js\n// 创建实例\nvar xhr = new XMLHttpRequest();\n\n// 监听实例对象的状态\nxhr.onreadystatechange = function(){\n  // 通信成功时，状态值为4\n  if (xhr.readyState === 4){\n    if (xhr.status === 200){\n      console.log(xhr.responseText);\n    } else {\n      console.error(xhr.statusText);\n    }\n  }\n};\n\nxhr.onerror = function (e) {\n  console.error(xhr.statusText);\n};\n\nxhr.open('GET', '/endpoint', true);\nxhr.send(null);\n```\n\n#### 实例属性\n+ `readyState `：实例对象的当前状态，只读\n    + 0，表示 `XMLHttpRequest` 实例已经生成，但是实例的open()方法还没有被调用。\n    + 1，表示`open()`方法已经调用，但是实例的`send()`方法还没有调用，仍然可以使用实例的`setRequestHeader()`方法，设定 `HTTP` 请求的头信息。\n    + 2，表示实例的`send()`方法已经调用，并且服务器返回的头信息和状态码已经收到。\n    + 3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的`responseType`属性等于`text`或者空字符串，`responseText`属性就会包含已经收到的部分信息。\n    + 4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。\n\n+ `onreadystatechange`：指向一个监听函数\n+ `response`：表示服务器返回的数据体（即 HTTP 回应的 body 部分）\n    ```js\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            handler(xhr.response);\n        }\n    }\n\n    // 如果本次请求没有成功或者数据不完整，该属性等于null。但是，如果responseType属性等于text或空字符串，在请求没有结束之前（readyState等于3的阶段），response属性包含服务器已经返回的部分数据。\n    ```\n+ `responseType`：表示服务器返回数据的类型\n    + \"\"（空字符串）：等同于text，表示服务器返回文本数据。\n    + \"arraybuffer\"：ArrayBuffer 对象，表示服务器返回二进制数组。\n    + \"blob\"：Blob 对象，表示服务器返回二进制对象。\n    + \"document\"：Document 对象，表示服务器返回一个文档对象。\n    + \"json\"：JSON 对象。\n    + \"text\"：字符串。\n\n+ `responseText`：返回从服务器接收到的字符串，只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据\n    ```js\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', '/server', true);\n\n    xhr.responseType = 'text';\n    xhr.onload = function () {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText);\n        }\n    };\n\n    xhr.send(null);\n    ```\n\n+ `responseXML`：返回从服务器接收到的 HTML 或 XML 文档对象,只读\n+ `responseURL`：表示发送数据的服务器的网址\n\n+ `status`：服务器回应的 HTTP 状态码\n    + 200, OK，访问正常\n    + 301, Moved Permanently，永久移动\n    + 302, Moved temporarily，暂时移动\n    + 304, Not Modified，未修改\n    + 307, Temporary Redirect，暂时重定向\n    + 401, Unauthorized，未授权\n    + 403, Forbidden，禁止访问\n    + 404, Not Found，未发现指定网址\n    + 500, Internal Server Error，服务器发生错误\n\n+ `timeout`和`ontimeout`：\n    XMLHttpRequest.timeout属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。\n\n    XMLHttpRequestEventTarget.ontimeout属性用于设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。\n    ```js\n    var xhr = new XMLHttpRequest();\n    var url = '/server';\n\n    xhr.ontimeout = function () {\n        console.error('The request for ' + url + ' timed out.');\n    };\n\n    xhr.onload = function() {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n            // 处理服务器返回的数据\n            } else {\n            console.error(xhr.statusText);\n            }\n        }\n    };\n\n    xhr.open('GET', url, true);\n    // 指定 10 秒钟超时\n    xhr.timeout = 10 * 1000;\n    xhr.send(null);\n    ```\n\n+ 事件的监听属性\n    + XMLHttpRequest.onloadstart：loadstart 事件（HTTP 请求发出）的监听函数\n    + XMLHttpRequest.onprogress：progress事件（正在发送和加载数据）的监听函数\n    + XMLHttpRequest.onabort：abort 事件（请求中止，比如用户调用了abort()方法）的监听函数\n    + XMLHttpRequest.onerror：error 事件（请求失败）的监听函数\n    + XMLHttpRequest.onload：load 事件（请求成功完成）的监听函数\n    + XMLHttpRequest.ontimeout：timeout 事件（用户指定的时限超过了，请求还未完成）的监听函数\n    + XMLHttpRequest.onloadend：loadend 事件（请求完成，不管成功或失败）的监听函数\n\n+ `withCredentials`：表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为false，即向example.com发出跨域请求时，不会发送example.com设置在本机上的 Cookie（如果有的话）\n\n+ `upload`：\n    XMLHttpRequest 不仅可以发送请求，还可以发送文件，这就是 AJAX 文件上传。发送文件以后，通过XMLHttpRequest.upload属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：loadstart、loadend、load、abort、error、progress、timeout。\n    ```js\n    function upload(blobOrFile) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('POST', '/server', true);\n        xhr.onload = function (e) {};\n\n    var progressBar = document.querySelector('progress');\n    xhr.upload.onprogress = function (e) {\n        if (e.lengthComputable) {\n        progressBar.value = (e.loaded / e.total) * 100;\n        // 兼容不支持 <progress> 元素的老式浏览器\n        progressBar.textContent = progressBar.value;\n        }\n    };\n\n    xhr.send(blobOrFile);\n    }\n\n    upload(new Blob(['hello world'], {type: 'text/plain'}));\n    ```\n\n#### 实例方法\n+ `open()`：指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象\n```js\n// method：表示 HTTP 动词方法，比如GET、POST、PUT、DELETE、HEAD等。\n// url: 表示请求发送目标 URL。\n// async: 布尔值，表示请求是否为异步，默认为true。如果设为false，则send()方法只有等到收到服务器返回了结果，才会进行下一步操作。该参数可选。由于同步 AJAX 请求会造成浏览器失去响应，许多浏览器已经禁止在主线程使用，只允许 Worker 里面使用。所以，这个参数轻易不应该设为false。\n// user：表示用于认证的用户名，默认为空字符串。该参数可选。\n// password：表示用于认证的密码，默认为空字符串。该参数可选。\nvar xhr = new XMLHttpRequest(method、url、async、user、password);\nxhr.open('POST', encodeURI('someURL'));\n```\n\n+ `send()`：用于实际发出`HTTP`请求\n    **GET**请求：\n    ```js\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET',\n        'http://www.example.com/?id=' + encodeURIComponent(id),\n        true\n    );\n    xhr.send(null);\n    ```\n    **PSOT**请求：\n    ```js\n    var xhr = new XMLHttpRequest();\n    var data = 'email='\n        + encodeURIComponent(email)\n        + '&password='\n        + encodeURIComponent(password);\n\n    xhr.open('POST', 'http://www.example.com', true);\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    xhr.send(data);\n    ```\n+ `setRequestHeader()`：设置浏览器发送的 HTTP 请求的头信息\n+ `overrideMimeType()`：指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理\n+ `getResponseHeader()`：返回 HTTP 头信息指定字段的值，没有则返回`null`\n+ `abort()`：终止已经发出的 HTTP 请求。调用这个方法以后，readyState属性变为4，status属性变为0。\n\n#### 实例的事件\n+ `readyStateChange` 事件\n\n    `readyState`属性的值发生改变，就会触发 `readyStateChange` 事件。\n\n    我们可以通过`onReadyStateChange`属性，指定这个事件的监听函数，对不同状态进行不同处理。尤其是当状态变为4的时候，表示通信成功，这时回调函数就可以处理服务器传送回来的数据。\n\n+ `progress` 事件:上传文件时，`XMLHttpRequest` 实例对象本身和实例的`upload`属性，都有一个`progress`事件，会不断返回上传的进度\n+ `load` 事件、`error` 事件、`abort` 事件\n    ```js\n    // load 事件表示服务器传来的数据接收完毕，error 事件表示请求出错，abort 事件表示请求被中断（比如用户取消请求）。\n    var xhr = new XMLHttpRequest();\n\n    xhr.addEventListener('load', transferComplete);\n    xhr.addEventListener('error', transferFailed);\n    xhr.addEventListener('abort', transferCanceled);\n\n    xhr.open();\n\n    function transferComplete() {\n        console.log('数据接收完毕');\n    }\n\n    function transferFailed() {\n        console.log('数据接收出错');\n    }\n\n    function transferCanceled() {\n        console.log('用户取消接收');\n    }\n    ```\n+ `loadend` 事件：`abort`、`load`和`error`这三个事件，会伴随一个`loadend`事件，表示请求结束，但不知道其是否成功。\n+ `timeout` 事件：服务器超过指定时间还没有返回结果，就会触发 timeout 事件","tags":["浏览器"],"categories":["浏览器模型"]},{"title":"JSON理解","url":"%2F2019%2F02%2F03%2FJS--JSON%E7%90%86%E8%A7%A3%2F","content":"\n#### 概述\n`JSON`全称是`JSON(JavaScript Object Notation) `：\n1. 一种轻量级的**数据交换格式**\n2. 是**独立的语言**\n3. 使用 `JavaScript` 语法\n\n`JSON` 虽然使用 `JavaScript` 语法，但是 JSON 格式仅仅是一个**文本**。\n文本可以被任何编程语言读取及作为数据格式传递。\n\n#### 相关函数\n`js`内置了`JSON`对象，因此可以通过该对象去进行`JSON`的相关操作\n+  `JSON.parse()`：将符合`JSON`~`规则的字符串转换成一个JS对象\n    ```js\n    var jsonstr = '{\"a\":[1,3,4,5,6]}'\n    JSON.parse(jsonstr)  // {a: Array(5)}\n    ```\n+ `JSON.stringify()`：将`JavaScript` 值转换为 `JSON` 字符串\n    ```js\n    var jsonstr = {\"a\":[1,3,4,5,6]}\n    JSON.stringify(jsonstr)  //\"{\"a\":[1,3,4,5,6]}\"\n    ```\n#### 扩展\n`JSON`的其他用处\n+ `string`转换`boolean`\n    ```js\n    var str = 'false';\n    console.log(JSON.parse(str));  //false\n    ```\n\n+ 浅拷贝（部分数据类型）\n    ```js\n    var obj = {\n        a: 1,\n        b: {\n            c: 1,\n            d: function () {},  //引用类型，无法拷贝\n            e: null,\n            f: undefined        //无法拷贝\n        }\n    }\n    console.log(JSON.stringify(obj)); //{\"a\":1,\"b\":{\"c\":1,\"e\":null}}\n    ```\n\n","tags":["json"],"categories":["JS出深入浅"]},{"title":"DOMContentLoaded触发时机","url":"%2F2019%2F02%2F02%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B--DOMContentLoaded%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA%2F","content":"页面解析完成（生成`DOM TREE`）之后将会触发 `DOMContentLoaded`事件。\n\n下面是几种触发`DOMContentLoaded`事件的情况：\n\n#### 没有`CSS`和`JS`\n![283b220.png](https://miao.su/images/2019/02/13/283b220.png)\n在解析完`Dom`之后触发\n\n#### 有`CSS`无`JS`\n![38dd687.png](https://miao.su/images/2019/02/13/38dd687.png)\n渲染树的生成是基于`DOM`和`CSSOM`的,`DOMContentLoaded`的触发和`CSSOM`无关\n\n#### 有`JS`\n![4865ad5.png](https://miao.su/images/2019/02/13/4865ad5.png)","tags":["优化"],"categories":["浏览器模型"]},{"title":"浏览器环境","url":"%2F2019%2F02%2F01%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B--%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%2F","content":"\n#### 浏览器的组成\n浏览器的核心是两部分：渲染引擎和 `JavaScript` 解释器（又称 `JavaScript` 引擎）\n\n+ 渲染引擎：将网页代码渲染为平面文档\n\n    不同浏览器有不同的渲染引擎：\n    + Firefox：Gecko 引擎\n    + Safari：WebKit 引擎\n    + Chrome：Blink 引擎\n    + IE: Trident 引擎\n    + Edge: EdgeHTML 引擎\n\n    渲染引擎处理页面通常分为四个阶段：\n    1. 解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。\n    2. 对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。\n    3. 布局：计算出渲染树的布局（layout）。\n    4. 绘制：将渲染树绘制到屏幕。\n    > 四个阶段**并非按顺序**执行\n\n\n+ 重流和重绘\n\n    渲染树转换为网页布局，称为“布局流”`（flow）`\n\n    布局显示到页面的这个过程，称为“绘制”`（paint）`\n\n    脚本操作、样式表操作和用户的交互会触发**重流**和**重绘**\n\n    重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；**改变元素的布局，则会导致重绘和重流**。\n\n    ```js\n    var foo = document.getElementById('foobar');\n\n    foo.style.color = 'blue';\n    foo.style.marginTop = '30px';\n\n    // 只会导致一次重绘，因为浏览器会累积 DOM 变动，然后一次性执行\n    ```\n    优化技巧：\n    + 读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。\n    + 缓存 DOM 信息。\n    + 不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。\n    + 使用documentFragment操作 DOM\n    + 动画使用absolute定位或fixed定位，这样可以减少对其他元素的影响。\n    只在必要时才显示隐藏元素。\n    + 使用window.requestAnimationFrame()，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流。\n    + 使用虚拟 DOM（virtual DOM）库。\n    ```js\n    // 重绘代价高\n    function doubleHeight(element) {\n        var currentHeight = element.clientHeight;\n        element.style.height = (currentHeight * 2) + 'px';\n    }\n\n    all_my_elements.forEach(doubleHeight);\n\n    // 重绘代价低\n    function doubleHeight(element) {\n        var currentHeight = element.clientHeight;\n\n        window.requestAnimationFrame(function () {\n            element.style.height = (currentHeight * 2) + 'px';\n        });\n    }\n\n    all_my_elements.forEach(doubleHeight);\n    ```\n\n#### `script`元素\n脚本的加载，会**阻塞**网页的渲染。\n\n正常的网页加载流程：\n1. 浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。\n2. 解析过程中，浏览器发现`<script>`元素，就暂停解析，把网页渲染的控制权转交给 `JavaScript` 引擎。\n3. 如果`<script>`元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。\n4. `JavaScript` 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 `HTML` 网页\n\n+ `defer` 属性：延迟脚本的执行，等到 `DOM` 加载生成后，再执行脚本\n    用了这个属性，脚本不会阻塞浏览器的渲染，下载的脚本在`DOMContentLoaded`事件**触发前**执行\n\n+ `async` 属性：使用另一个进程下载脚本，下载时不会阻塞渲染\n    1. 浏览器开始解析 HTML 网页。\n    2. 解析过程中，发现带有async属性的script标签。\n    3. 浏览器继续往下解析 HTML 网页，同时并行下载`<script>`标签中的外部脚本。\n    4. 脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。\n    5. 脚本执行完毕，浏览器恢复解析 HTML 网页。\n\n    > async虽然不会阻塞浏览器渲染，但是会影响脚本的执行顺序\n    > 如果脚本不是互相依赖，用async\n\n+ 动态加载脚本\n    这种方式不会阻塞页面的渲染，但是需要注意脚本的加载顺序\n\n    ```js\n    function loadScript(src, done) {\n        var js = document.createElement('script');\n            js.src = src;\n            js.async = false;  // 避开脚本加载顺序问题\n        js.onload = function() {\n            done();\n        };\n        js.onerror = function() {\n            done(new Error('Failed to load script ' + src));\n        };\n        document.head.appendChild(js);\n    }\n    ```\n\n","tags":["优化"],"categories":["浏览器模型"]},{"title":"Navigator 对象，Screen 对象","url":"%2F2019%2F02%2F01%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B--Navigator%20%E5%AF%B9%E8%B1%A1%EF%BC%8CScreen%20%E5%AF%B9%E8%B1%A1%2F","content":"\n#### `navigator`\n指向一个包含浏览器和系统信息的 `Navigator` 对象。脚本通过这个属性了解用户的**环境信息**。\n##### 属性\n+ `userAgent`：浏览器的 User Agent 字符串，表示浏览器的厂商和版本信息。\n    ```js\n    // 粗略判断\n    var ua = navigator.userAgent.toLowerCase();\n    if (/mobi/i.test(ua)) {\n    // 手机浏览器\n    } else {\n    // 非手机浏览器\n    }\n    ```\n+ `plugins `：类数组对象，浏览器安装的插件\n+ `platform `：用户的操作系统信息\n+ `onLine`：用户是否在线\n+ `geolocation`：用户的地理位置信息，只在HTTPS协议下可用\n+ `cookieEnabled`：表示浏览器的 Cookie 功能是否打开\n\n##### 方法\n+ `javaEnabled()`：表示浏览器是否能运行 Java Applet 小程序\n+ `sendBeacon()`：用于向服务器异步发送数据\n\n#### `Screen`对象\n当前窗口所在的屏幕，提供显示设备的信息\n+ `height`：浏览器窗口所在的屏幕的高度（单位像素）；缩放网页并不会改变分辨率。\n+ `width`：浏览器窗口所在的屏幕的宽度（单位像素）\n+ `availHeight`：浏览器窗口可用的屏幕高度（单位像素）\n+ `availWidth`：浏览器窗口可用的屏幕宽度（单位像素）\n+ `pixelDepth`：表示屏幕的色彩位数\n+ `orientation`：屏幕的方向\n    ```js\n    window.screen.orientation\n    // { angle: 0, type: \"landscape-primary\", onchange: null }\n\n    // landscape-primary：横放，\n    // landscape-secondary：颠倒的横放，\n    // portrait-primary：竖放，\n    // portrait-secondary：颠倒的竖放\n    ```\n\n","tags":["浏览器"],"categories":["浏览器模型"]},{"title":"常用操作","url":"%2F2019%2F01%2F22%2FJS--%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F","content":"\n#### 宿主环境\n\n+ 判断安卓和苹果终端\n\n  ```js\n  var u = navigator.userAgent;\n  var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1; //android终端\n  var isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端\n  ```\n\n+ 判断是否ie\n\n  ```js\n  isie: /MSIE \\d+\\.\\d+/.test(navigator.userAgent) && parseInt(/MS(IE) (\\d+\\.\\d+)/.exec(navigator.userAgent)[2]) <= 9\n  ```\n\n+ 判断是否移动端\n\n  ```js\n  if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {\n      window.location =\"mobile.html\"; //可以换成http地址\n  }\n  ```\n\n  \n\n#### 对象操作\n\n+ 对象数组化\n\n  ```js\n  function demo() {\n    return [].slice.call(arguments);\n  }\n  console.log(demo(1,2));  \t//[1, 2] \n  console.log(demo({1:2}));   //[{1: 2}]\n  ```\n\n+ 类数组对象\n\n  ```js\n  var o = {};\n  var arry = ['p','a'];\n  Array.prototype.push.apply(o,arry)\n  console.log(o);   //{0: \"p\", 1: \"a\", length: 2}\n  ```\n\n+ 判断对象属于哪一种内置类型\n\n  ```js\n  function getType(obj) {\n      return Object.prototype.toString.call(obj).match(/\\s([a-z|A-Z]+)/)[1].toLowerCase();\n  };\n  ```\n\n#### 正则操作\n\n+ 保留字符\n\n  ```js\n  var encodeHTMLRules = {\n      \"&\": \"&#38;\",\n      \"<\": \"&#60;\",\n      \">\": \"&#62;\",\n      '\"': \"&#34;\",\n      \"'\": \"&#39;\",\n      \"/\": \"&#47;\"\n  };\n  var matchHTML = /&(?!#?\\w+;)|<|>|\"|'|\\//g;\n  var code = '&<>123';\n  var ss = code.toString().replace(matchHTML, function (m) {\n      return encodeHTMLRules[m] || m;\n  })\n  ```\n\n#### 模块化\n\n+ 输出全局变量\n\n  ```js\n  _globals = (function () {\n      return this || (0, eval)(\"this\");\n  }());\n  \n  /* istanbul ignore else */\n  if (typeof module !== \"undefined\" && module.exports) {\n      module.exports = doT;\n  } else if (typeof define === \"function\" && define.amd) {\n      define(function () {\n          return doT;\n      });\n  } else {\n      _globals.doT = doT;\n  }\n  ```\n\n#### 动画函数\n\n```js\n/*\n * Easing Functions - inspired from http://gizma.com/easing/\n * only considering the t value for the range [0, 1] => [0, 1]\n */\nEasingFunctions = {\n  // no easing, no acceleration\n  linear: function (t) { return t },\n  // accelerating from zero velocity\n  easeInQuad: function (t) { return t*t },\n  // decelerating to zero velocity\n  easeOutQuad: function (t) { return t*(2-t) },\n  // acceleration until halfway, then deceleration\n  easeInOutQuad: function (t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t },\n  // accelerating from zero velocity \n  easeInCubic: function (t) { return t*t*t },\n  // decelerating to zero velocity \n  easeOutCubic: function (t) { return (--t)*t*t+1 },\n  // acceleration until halfway, then deceleration \n  easeInOutCubic: function (t) { return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 },\n  // accelerating from zero velocity \n  easeInQuart: function (t) { return t*t*t*t },\n  // decelerating to zero velocity \n  easeOutQuart: function (t) { return 1-(--t)*t*t*t },\n  // acceleration until halfway, then deceleration\n  easeInOutQuart: function (t) { return t<.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t },\n  // accelerating from zero velocity\n  easeInQuint: function (t) { return t*t*t*t*t },\n  // decelerating to zero velocity\n  easeOutQuint: function (t) { return 1+(--t)*t*t*t*t },\n  // acceleration until halfway, then deceleration \n  easeInOutQuint: function (t) { return t<.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t }\n}\n```\n\n#### 类型转换\n\n+ `string`转`boolean`\n\n  ```js\n  JSON.parse('false')\n  ```\n\n#### 兼容操作\n\n+ 适配不同浏览器\n\n  ```js\n  function prefixedEventListener(element, type, callback) {\n      var pfx = [\"webkit\", \"moz\", \"MS\", \"o\", \"\"];\n      for (var p = 0; p < pfx.length; p++) {\n          if (!pfx[p]) type = type.toLowerCase();\n          element.addEventListener(pfx[p] + type, callback, false);\n      }\n  }\n  \n  prefixedEventListener(document.getElementById('container'), \"Transitionend\", function(e) {\n  \t// do something\n  });\n  ```\n\n+ 判断页面加载完成\n\n  ```js\n  function init() {\n      var ref;\n      this.element = window.document.documentElement;\n      if ((ref = document.readyState) === \"interactive\" || ref === \"complete\") {\n          this.start();\n      } else {\n          this.util().addEvent(document, 'DOMContentLoaded', this.start);\n      }\n      return this.finished = [];\n  };\t\t\n  ```\n\n+ `bind`\n\n  ```js\n  bind = function(fn, me) {\n      return function() {\n          return fn.apply(me, arguments);\n      };\n  },\n  ```\n\n+ `indexOf`\n\n  ```js\n      indexOf = [].indexOf || function(item) {\n      for (var i = 0, l = this.length; i < l; i++) {\n          if (i in this && this[i] === item) return i;\n      }\n      return -1;\n  };\n  ```\n\n  ","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"window.matchMedia()","url":"%2F2019%2F01%2F13%2FBom--window.matchMedia()%2F","content":"该属性是css媒体查询列表转化成一个 MediaQueryList 实例，用js去操作\n\n```js\nvar mdl = window.matchMedia('(min-width: 400px)');\nmdl instanceof MediaQueryList // true\n```\n\n### MediaQueryList 接口的实例属性\n\n+ **MediaQueryList.media**\n\n  `MediaQueryList.media`属性返回一个字符串，表示对应的 MediaQuery 条件语句。\n\n  ```\n  var mql = window.matchMedia('(min-width: 400px)');\n  mql.media // \"(min-width: 400px)\"\n  ```\n\n+ **MediaQueryList.matches**\n\n  属性返回一个布尔值，表示当前页面**是否符合**指定的 MediaQuery 条件语句。\n\n  ```\n  if (window.matchMedia('(min-width: 400px)').matches) {\n    /* 当前视口不小于 400 像素 */\n  } else {\n    /* 当前视口小于 400 像素 */\n  }\n  ```\n\n  可以用该属性动态加载css样式表\n\n  ```js\n  var result = window.matchMedia(\"(max-width: 700px)\");\n  //如果匹配\n  if (result.matches){\n    var linkElm = document.createElement('link');\n    linkElm.setAttribute('rel', 'stylesheet');\n    linkElm.setAttribute('type', 'text/css');\n    linkElm.setAttribute('href', 'small.css');\n  \n    document.head.appendChild(linkElm);\n  }\n  ```\n\n+ **MediaQueryList.onchange**\n\n  指定`change`事件的监听函数。该函数的参数是`change`事件对象（MediaQueryListEvent 实例），该对象与 MediaQueryList 实例类似，也有`media`和`matches`属性。\n\n  ```js\n  var mql = window.matchMedia('(max-width: 600px)');\n  \n  mql.onchange = function(e) {\n    if (e.matches) {\n      /* 视口不超过 600 像素 */\n    } else {\n      /* 视口超过 600 像素 */\n    }\n  }\n  ```\n\n#### MediaQueryList 接口的实例方法\n\n`MediaQueryList.addListener()`和`MediaQueryList.removeListener()`，用于添加或删除监听函数。\n\n```js\nvar mql = window.matchMedia('(max-width: 600px)');\n\n// 指定监听函数\nmql.addListener(mqCallback);\n// mql.removeListener(mqCallback);\nfunction mqCallback(e) {\n    console.log('屏幕小于900px啦');\n}\n```","tags":["Bom解析"],"categories":["Bom解析"]},{"title":"DOMContentLoaded和load","url":"%2F2019%2F01%2F12%2FBom--DOMContentLoaded%E5%92%8Cload%2F","content":"\nDOMContentLoaded：当初始的 HTML 文档被**完全加载和解析完成**之后触发，而无需等待样式表、图像和子框架的完成加载。\n\nload：检测一个**完全加载**的页面，当一个资源及其依赖资源已完成加载时，将触发load事件。\n\n### HTML文档的加载与页面的首次渲染\n\n当我们输入一个页面地址时：\n\n- 1、浏览器首先下载该地址所对应的 html 页面。\n\n- 2、浏览器解析 html 页面的 DOM 结构。\n\n- 3、开启下载线程对文档中的所有资源按优先级排序下载。\n\n- 4、主线程继续解析文档，到达 head 节点 ，head 里的外部资源无非是外链样式表和外链 js。\n\n  - 发现有外链 css 或者外链 js，如果是外链 js ，则停止解析后续内容，等待该资源下载，下载完后立刻执行。如果是外链 css，继续解析后续内容。\n\n- 5、解析到 body\n\n  > body 里的情况比较多，body 里可能只有 DOM 元素，可能既有 DOM、也有 css、js 等资源，js 资源又有可能异步加载 图片、css、js 等。DOM 结构不同，浏览器的解析机制也不同，我们分开来讨论。\n\n  - 只有 DOM 元素\n    - 这种情况比较简单了，DOM 树构建完，页面首次渲染。\n  - 有 DOM 元素、外链 js。\n    - 当解析到外链 js 的时候，该 js 尚未下载到本地，则 js 之前的 DOM 会被渲染到页面上，同时 js 会阻止后面 DOM 的构建，即后面的 DOM 节点并不会添加到文档的 DOM 树中。所以，js 执行完之前，我们在页面上看不到该 js 后面的 DOM 元素。\n  - 有 DOM 元素、外链 css\n    - 外链 css 不会影响 css 后面的 DOM 构建，但是会**阻碍渲染**。简单点说，外链 css 加载完之前，页面还是白屏。\n  - 有 DOM 元素、外链 js、外链 css\n    - 外链 js 和外链 css 的顺序会影响页面渲染，这点尤为重要。当 body 中 js 之前的外链 css 未加载完之前，页面是不会被渲染的。\n    - **当body中 js 之前的 外链 css 加载完之后，js 之前的 DOM 树和 css 合并渲染树，页面渲染出该 js 之前的 DOM 结构**。\n\n- 6、文档解析完毕，页面重新渲染。当页面引用的所有 js 同步代码执行完毕，触发 DOMContentLoaded 事件。\n\n- 7、html 文档中的图片资源，js 代码中有异步加载的 css、js 、图片资源都加载完毕之后，load 事件触发。\n\n> DOMContentLoaded 在文档解析完毕后加载，load是在DOMContentLoaded 的基础上继续完全加载外部资源后触发\n>\n> css不影响页面的解析，但是影响页面的渲染\n\n常用于自定义js框架的启动\n\n```js\nif ((ref = document.readyState) === \"interactive\" || ref === \"complete\") {\n    this.start();\n} else {\n    this.util().addEvent(document, 'DOMContentLoaded', this.start);\n}\n```\n\n","tags":["Bom解析"],"categories":["Bom解析"]},{"title":"Thunk函数和Generator函数","url":"%2F2019%2F01%2F04%2FNodejs--Thunk%E5%87%BD%E6%95%B0%E5%92%8CGenerator%E5%87%BD%E6%95%B0%2F","content":"#### Thunk\n\nThunk用于传名调用，即把参数放进一个临时函数中，再将这个临时函数传入函数体。\n\n```js\nfunction f(m){\n  return m * 2;     \n}\n\nf(x + 5);\n\n// 等同于\nvar thunk = function () {\n  return x + 5;\n};\nfunction main(thunk){\n  return thunk() * 2;\n}\n```\n\nx是参数，将其放进临时函数中，真正用需要的时候才调用，传入main函数中,典型的函数式编程思想。\n\n在 JS 中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受**回调函数作为参数**，实质是**函数的柯里化**。\n\n```js\nfunction Thunk(fn){\n    return function (){\n        //闭包保存函数的参数\n        var args = Array.prototype.slice.call(arguments);\n        //返回一个函数，参数只有callback\n        return function (callback){\n            //参数列表增加回调函数\n            args.push(callback);\n            return fn.apply(this, args);\n        }\n    };\n};\n```\n\n仅仅是Thunk并没有多大用处，需要结合Generator进行流程管理。\n\n#### Generator\n\n生成器函数，返回一个迭代器Iterator对象，我们可以通过这个迭代器，手动地遍历相关的值、状态，保证正确的执行顺序。生成器函数有next方法。\n\n通过next函数，可以执行对应的yield表达式，且next()函数还可以带参数，该参数可以作为上一次yield表达式的返回值，因为yield本身是没有返回值的，**如果next()中不带参数，则yield每次运行之后的返回值都是为undefined**\n\n```js\nfunction* gen() {\n  // ...\n}\n\nvar g = gen();\nvar res = g.next();\n\nwhile(!res.done){\n  console.log(res.value);\n  res = g.next();\n}\n//执行next会返回{value: \"one\", done: false}\n```\n\nGenerator函数只是返回一个指针，指向里面迭代的对象，一般情况下，需要我们主动触发next()来执行，所以仅仅只有Generator并不适合进行异步操作。\n\n>`yield`关键字使生成器函数执行暂停，`yield`关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的`return`关键字。\n>`yield`关键字实际返回一个`IteratorResult`对象，它有两个属性，`value`和`done`。`value`属性是对`yield`表达式求值的结果，而`done`是`false`，表示生成器函数尚未完全完成。\n>\n>如果将可选值传递给生成器的`next()`方法，则该值将成为生成器当前`yield`操作返回的值\n\n#### Thunk 函数的自动流程管理\n\nThunk 函数真正的威力，在于可以**自动执行 Generator 函数**\n\n```js\nfunction run(fn) {\n  var gen = fn();\n\n  function next(err, data) {\n    var result = gen.next(data);/*将指针移动到Generator函数的下一步*/\n    if (result.done) return;/*判断是否结束*/\n    result.value(next);/*递归,把next放进.value中*/\n      //经过thunk的函数，参数只有callback，这里就是next函数！！，\n  }\n\n  next();\n}\n\nvar g = function* (){\n  var f1 = yield readFile('fileA');\n  var f2 = yield readFile('fileB');\n  // ...\n  var fn = yield readFile('fileN');\n};\n\nrun(g);\n```\n\n next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出","tags":["Nodejs疯狂试探"],"categories":["Nodejs疯狂试探"]},{"title":"Express框架","url":"%2F2019%2F01%2F03%2FNodejs--Express%E7%9A%84%E4%BD%BF%E7%94%A8%2F","content":"Express 是一个简洁而灵活的 `node.js Web应用框架`, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。\n\n使用 Express 可以快速地搭建一个完整功能的网站。\n\n#### 搭建服务器\n\n```js\n//引入express\nvar express = require('express');\nvar app = express();\n\n//引入服务器模块，监听端口\napp.listen('18000',function () {\n    console.log('访问地址'+ this.address().address + this.address().port);\n});\n\n//配置路由\napp.get('/',function (req,res) {\n    res.send('hello welcome'); //传送http响应\n});\n```\n\n#### 请求和响应\n\n使用回调函数的参数： **request** 和 **response** 对象来处理请求和响应的数据\n\n**Request 对象** - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：\n\n+ `req.app`：当callback为外部文件时，用req.app访问express的实例\n\n+ `req.baseUrl`：获取路由当前安装的URL路径\n\n+ `req.body / req.cookies`：获得「请求主体」/ Cookies\n+ `req.fresh / req.stale`：判断请求是否还「新鲜」\n+ `req.hostname / req.ip`：获取主机名和IP地址\n+ `req.originalUrl`：获取原始请求URL\n+ `req.params`：获取路由的parameters\n+ `req.path`：获取请求路径\n+ `req.protocol`：获取协议类型\n+ `req.query`：获取URL的查询参数串\n+ `req.route`：获取当前匹配的路由\n+ `req.subdomains`：获取子域名\n+ `req.accepts()`：检查可接受的请求的文档类型\n+ `req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages`：返回指定字符集的第一个可接受字符编码\n+ `req.get()`：获取指定的HTTP请求头\n+ `req.is()`：判断请求头Content-Type的MIME类型\n\n**Response 对象** - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：\n\n+ `res.app`：同req.app一样\n+ `res.append()`：追加指定HTTP头\n+ `res.set()`：在res.append()后将重置之前设置的头\n+ `res.cookie(name，value [，option])`：设置Cookie\n+ `opition: domain / expires / httpOnly / maxAge / path / secure / signed`\n+ `res.clearCookie()`：清除Cookie\n+ `res.download()`：传送指定路径的文件\n+ `res.get()`：返回指定的HTTP头\n+ `res.json()`：传送JSON响应\n+ `res.jsonp()`：传送JSONP响应\n+ `res.location()`：只设置响应的Location HTTP头，不设置状态码或者close response\n+ `res.redirect()`：设置响应的Location HTTP头，并且设置状态码302\n+ `res.render(view,[locals],callback)`：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。\n+ `res.send()`：传送HTTP响应\n+ `res.sendFile(path [，options][，fn])`：传送指定路径的文件 -会自动根据文件extension设定Content-Type\n+ `res.set()`：设置HTTP头，传入object可以一次设置多个头\n+ `res.status()`：设置HTTP状态码\n+ `res.type()`：设置Content-Type的MIME类型\n\n#### 路由\n\n路由决定了由谁(指定脚本)去**响应客户端请求**。\n\n在HTTP请求中，我们可以通过路由**提取出请求的URL以及GET/POST参数**。\n\n```js\n//  POST 请求\napp.post('/', function (req, res) {\n   console.log(\"主页 POST 请求\");\n   res.send('Hello POST');\n})\n\n//实现页面GET请求\napp.get('/list_user', function (req, res) {\n   console.log(\"/list_user GET 请求\");\n   res.send('用户列表页面');\n});\n```\n\nexpress提供的三种**路由处理方法**：`path`、`Router`和`route`\n\n+ path\n\n  比如经常使用的get和post方式\n\n  ```js\n  app.get('/list_user', function (req, res) {\n     console.log(\"/list_user GET 请求\");\n     res.send('用户列表页面');\n  });\n  ```\n\n+ Router\n\n  如果一个路由下有**多个子路由**，可以使用Router定义\n\n```js\n//引入rooter，一般用于多组路径\nvar Router = express.Router();\nRouter.get('/add',function (req,res) {\n    res.send('add')\n})\nRouter.get('/list',function (req,res) {\n    res.send('list');\n})\n//写入app配置里面\napp.use('/post',Router);\n```\n\n+ route\n\n```js\n//指定基础路由\napp.route('/article')\n    .get(function(req, res) {\n        res.send('get方式')\n    })\n    .post(function(req, res) {\n        res.send('post方式')\n    })\n```\n\n进行访问\n\n```js\n# curl -X POST http://localhost:18000/article\n// post方式\n# curl -X GET http://localhost:18000/article\n// get方式\n```\n\n#### 路由参数\n\n通过`router.param(req,res,next,name)`方法传参\n\n```js\n//配置路由，当用户访问/news/，后面的name是参数\napp.get('/news/:name',function (req,res) {\n    //显示返回的name\n    res.end('name:'+ req.name);\n})\n//获取路由参数name，然后\napp.param('name',function (req,res,next,name) {\n    req.name = name;\n    next();\n})\n```\n\n#### 静态文件\n\n在express中使用**中间件**来定义静态文件目录\n\n```js\n//定义静态文件的入口\napp.use(express.static('public'));\n//当前的静态文件默认访问路径 http://ip:port/\n//静态文件都存储在public文件夹里面\n```\n\n#### 中间件\n\n中间件(MiddleWare)可以理解为一个对用户请求进行过滤和预处理的东西，它一般不会直接对客户端进行响应，而是将处理之后的结果传递下去。就是分层实现，分层处理。\n\n\n\n","tags":["Nodejs疯狂试探"],"categories":["Nodejs疯狂试探"]},{"title":"创建web服务器","url":"%2F2019%2F01%2F02%2FNodejs--%E5%88%9B%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8%2F","content":"Web服务器的功能：\n\n+ 接受HTTP请求（GET、POST、UPDATE、DELETE、PUT、PATCH）\n\n+ 处理HTTP请求（自己处理，或请求别的程序处理）\n\n+ 做出响应（返回页面、文件、各类数据等）\n\n常见请求种类：\n\n+ 请求文件：包括静态文件（网页、图片、前端JavaScript文件、css文件……），及由程序处理得到的文件\n\n+ 完成特定的操作：如登陆、获取特定数据\n\n使用`nodejs`可以搭建web服务器而且不依赖其他服务器软件（IIS、Apache、Nginx）\n\n#### 使用node核心模块创建web服务\n\n```js\n//创建一个web服务器\n//引入http模块\nvar http = require('http');\n//响应\nvar requestHandler = function (req,res) {\n    //响应结束后返回一个hello\n    res.end('hello');\n};\n//创建一个http服务然后监听端口\nvar web = http.createServer(requestHandler);\nweb.listen(18000);  //监听端口\n```\n\n#### 使用express创建web服务\n\n```js\n//引入express模块\nvar express = require('express');\n\n//创建一个express实例\nvar app = express();\napp.listen(18000,function afterListen() {\n    console.log('you are visiting 18000');\n})\n```\n\n`express`是用过路由来返回响应\n\n```js\n//通过路由配置响应\napp.get('/',function (req,res) {\n    res.end('welcome');\n});\n```\n\n+ #### 除了手动设置之外，还可以使用`express`提供的模板\n\n```js\n# npm install -g express-generator  //全局安装\n//cd你的目录，然后使用 express [expressname]创建\n//下面是文件结构\n-rw-r--r-- 1 root root 1075 Dec 24 19:04 app.js\ndrwxr-xr-x 2 root root 4096 Dec 24 19:04 bin\n-rw-r--r-- 1 root root  293 Dec 24 19:04 package.json\ndrwxr-xr-x 5 root root 4096 Dec 24 19:04 public\ndrwxr-xr-x 2 root root 4096 Dec 24 19:04 routes\ndrwxr-xr-x 2 root root 4096 Dec 24 19:04 views\n```\n\n查看`package.json`配置文件\n\n```json\n{\n  \"name\": \"hello\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node ./bin/www\"\n  },\n  \"dependencies\": {\n    \"cookie-parser\": \"~1.4.3\",\n    \"debug\": \"~2.6.9\",\n    \"express\": \"~4.16.0\",\n    \"http-errors\": \"~1.6.2\",\n    \"jade\": \"~1.11.0\",\n    \"morgan\": \"~1.9.0\"\n  }\n```\n\n可以看到启动文件是bin里面的ww，使用`# node bin/www `启动服务，默认监听端口3000\n\n```js\n# curl http://localhost:3000\n//返回一段html代码段\n// <!DOCTYPE html><html><head><title>Express</title><link rel=\"stylesheet\" href=\"/stylesheets/style.css\"></head><body><h1>Express</h1><p>Welcome to Express</p></body></html>[root@instance-leir0hxx ~]# \n```\n\n+ #### 创建静态文件服务\n\n  让浏览器能请求静态图片（比如网页，纯文本，图片，js代码css等）\n\n  我们在服务器里创建一个纯文本文件book.txt\n\n  ```js\n  # vim public/book.txt\n  // this is a test\n  ```\n\n  创建静态服务\n\n  ```js\n  //引入express模块\n  var express = require('express');\n  \n  //创建一个express实例\n  var app = express();\n  //使用中间件\n  app.use(express.static('./public')); //定向目录\n  \n  app.listen(18000,function afterListen() {\n      console.log('you are visiting 18000');\n  });\n  ```\n\n  用户就可以访问`poublic`里面的静态目录了。\n\n  比如我们在里面放了一个book.txt，然后访问\n\n  ```js\n  # curl http://localhost:18000/book.txt\n  // this is a test\n  ```\n\n  > 要注意的是 `http://localhost:18000/`后面没有public","tags":["Nodejs疯狂试探"],"categories":["Nodejs疯狂试探"]},{"title":"开发环境的搭建","url":"%2F2019%2F01%2F01%2FNodejs--%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%2F","content":"\n1. 采用`linux`系统部署服务器，使用`xshell`连接。\n\n   ```js\n   $ ssh root@ip port\n   ```\n\n2. 安装`nodejs`\n\n```js\n$ yum install nodejs\n$ node -v  //检查node版本\n```\n\n切换镜像源：\n\n```js\n$ npm config set strict-ssl false //取消严格模式\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org/\n```\n\n3. 安装`nodemon`\n\n   监视启动目录中的文件，如果有任何文件更改，`nodemon`将自动重新启动`node`应用程序，相当于热更新\n\n   ```js\n   $ npm isntall -g nodemon  //全局安装\n   \n   //常用操作\n   $ nodemon [your node app]  //启动应用\n   $ nodemon -h   //使用帮助\n   $ nodemon --debug ./server.js 80   //debug调试\n   ```\n\n4. 安装`pm2`\n\n   系统进程管理工具\n\n   ```js\n   $ npm install -g pm2   //全局安装\n   \n   //常用操作\n   $ pm2 start app.js\t\t//最简单的启用一个应用\n   $ pm2 stop app_name|app_id\t\t//停止\n   $ pm2 delete app_name|app_id\t\t//删除\n   $ pm2 restart app_name|app_id\t\t//重启\n   $ pm2 stop all\t\t//停止所有\n   $ pm2 list\t\t//查看所有的进程\n   $ pm2 status\t\t//查看所有的进程状态\n   $ pm2 describe app_name|app_id\t\t//查看某一个进程的信息\n   ```\n\n5. `sftp`关联服务器文件\n\n   ```json\n   {\n       \"type\": \"sftp\",\n       \"host\": \"\",\n       \"username\": \"\",\n       \"password\": \"\",\n       \"port\": 22,\n       \"remotePath\": \"/home/hello/\",\n       \"uploadOnSave\": false\n   }\n   ```\n\n   `remotePath`就是关联上传的路径。\n\n","tags":["Nodejs疯狂试探"],"categories":["Nodejs疯狂试探"]},{"title":"DOM载入事件","url":"%2F2018%2F11%2F30%2FDom--DOM%E8%BD%BD%E5%85%A5%E4%BA%8B%E4%BB%B6%2F","content":"\n`DOM`就绪和渲染结束。\n\n- *DOM就绪*是指浏览器已经接收到整个HTML并且DOM解析完成；\n- *渲染结束*是指浏览器已经接收到HTML中引用的所有样式文件、图片文件、以及Iframe等资源并渲染结束。\n\n`DOM API` 在页面载入问题上主要提供了三个接口：\n\n- `DOMContentLoaded`事件；\n- `load`事件；\n- `document.readyState`属性，及其对应的`readystatechange`事件。\n\n#### DOMContentLoaded\n\n页面文档（DOM）完全加载并解析完毕之后，会触发`DOMContentLoaded`事件， HTML文档不会等待样式文件，图片文件，Iframe页面的加载。 此时DOM元素可能还未渲染结束，位置大小等状态可能不正确， 但DOM树已被创建，多数JavaScript已经操作DOM并完成功能了\n\n```js\ndocument.addEventListener(\"DOMContentLoaded\", function(event) {\n    console.log(\"DOM ready!\");\n});\n```\n\n> 考虑到IE8及以下不支持该事件，因此我们需要后面的两个 DOM 事件作为Fallback。\n\n#### load\n\n页面完全载入时触发`load`事件，此时所有的图片等资源文件都已完全接收并完成渲染。 因此`load`总是在`DOMContentLoaded`之后触发。 `load`事件没有任何兼容性问题。`load`常常被作为最终的Fallback。\n\n```js\nwindow.addEventListener(\"load\", function(event) {\n    console.log(\"All resources finished loading!\");\n});\n```\n\n#### document.readyState\n\n`ocument.readyState`属性用来表征DOM的加载状态， 该属性值发生变化时会触发`redystatechange`事件，他有三种状态。\n\n- `\"loading\"`：DOM在加载过程中；\n- `\"interactive\"`：DOM就绪但资源仍在加载中；\n- `\"complete\"`：DOM加载完成。\n\n> 注意IE8以前的IE不支持`document.readyState`属性。 可以执行 `document.documentElement.doScroll(\"left\")`， 当DOM未就绪时执行该方法会抛出错误，以此检测DOM是否就绪。\n\n综上，整合DOM加载完成的判断函数\n\n```js\n\nif ( document.readyState === \"complete\" ||\n    ( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n    // Handle it asynchronously to allow scripts the opportunity to delay ready\n    window.setTimeout( jQuery.ready );\n} else {\n    // Use the handy event callback\n    document.addEventListener( \"DOMContentLoaded\", completed );\n    // A fallback to window.onload, that will always work\n    window.addEventListener( \"load\", completed );\n}\n```\n\n","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"Document节点","url":"%2F2018%2F11%2F29%2FDom--Document%E8%8A%82%E7%82%B9%2F","content":"\n`document`节点代表存在的网页，继承了`EventTarget`接口、`Node`接口、`ParentNode`接口。这意味着，这些接口的方法都可以在`document`对象上调用。除此之外，`document`对象还有很多自己的属性和方法。获取方式：\n\n+ 正常网页，`document`或`window.document`\n+ `iframe`框架里面的网页，使用`iframe`节点的`contentDocument`属性\n+ Ajax 操作返回的文档，使用`XMLHttpRequest`对象的`responseXML`属性。\n+ 内部节点的`ownerDocument`属性\n\n#### 快捷方式属性\n\n指向文档内部的某个节点的快捷方式。\n\n+ **document.defaultView** ：返回`document`对象所属的`window`对象\n\n  ```js\n  document.defaultView === window // true\n  ```\n\n+ **document.doctype** ：返回文档类型节点\n\n+ **document.documentElement** ：返回当前文档的根元素节点，一般都是`html`节点\n\n+ **document.body，document.head**：返回`body`和`head`节点\n\n+ **document.activeElement**： 获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是`<input>`、`<textarea>`、`<select>`等表单元素，如果当前没有焦点元素，返回`<body>`元素或`null`\n\n+ **document.fullscreenElement**：返回当前以全屏状态展示的 DOM 元素\n\n  ```js\n  if (document.fullscreenElement.nodeName == 'VIDEO') {\n    console.log('全屏播放视频');\n  }\n  ```\n\n#### 节点集合属性\n\n返回一个`HTMLCollection`实例，表示文档内部特定元素的集合\n\n+ **document.links** ：返回当前文档所有设定了`href`属性的`<a>`及`<area>`节点\n\n  ```js\n  //打印文档的所有链接\n  var links = document.links;\n  for(var i = 0; i < links.length; i++) {\n    console.log(links[i]);\n  }\n  ```\n\n+ **document.forms**：返回所有`<form>`表单节点\n\n+ **document.images**：返回页面所有`<img>`图片节点\n\n  ```js\n  var imglist = document.images;\n  for(var i = 0; i < imglist.length; i++) {\n     console.log(imglist[i]);\n      if (imglist[i].src === 'banner.gif') {\n      // ...找寻某张图片\n    }\n  }\n  ```\n\n+ **document.embeds，document.plugins** ：返回所有`<embed>`节点\n\n+ **document.scripts**：返回所有`<script>`节点\n\n+ **document.styleSheets**：返回文档内嵌或引入的样式表集合\n\n#### 文档静态信息属性\n\n返回文档信息\n\n+ **document.documentURI，document.URL**：返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，`documentURI`继承自`Document`接口，可用于所有文档；`URL`继承自`HTMLDocument`接口，只能用于 HTML 文档。\n\n+ **document.domain**：返回当前文档的域名，不包含协议和接口\n\n+ **document.location**：`Location`对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法\n\n+ **document.lastModified**：返回一个字符串，表示当前文档最后修改的时间\n\n  ```js\n  //判断网页是否修改\n  var lastVisitedDate = Date.parse('01/01/2018');\n  if (Date.parse(document.lastModified) > lastVisitedDate) {\n    console.log('网页已经变更');\n  }\n  ```\n\n+ **document.title**：返回当前文档的标题，可以修改\n\n+ **document.characterSet**：返回当前文档的编码\n\n+ **document.referrer**：返回一个字符串，表示当前文档的访问者来自哪里\n\n+ **document.compatMode**：返回浏览器处理文档的模式\n\n+ **document.dir**：返回一个字符串，表示文字方向\n\n#### 文档状态属性\n\n+ **document.hidden**：返回布尔值，表示当前网页是否可见\n\n+ **document.visibilityState**：返回文档的可见状态\n  + `loading`：加载 HTML 代码阶段（尚未完成解析）\n\n  + `interactive`：加载外部资源阶段\n\n  + `complete`：加载完成\n\n#### document.cookie\n\n操作浏览器 Cookie\n\n#### document.designMode\n\n控制当前文档是否可编辑。该属性只有两个值`on`和`off`，默认值为`off`。一旦设为`on`，用户就可以编辑整个文档的内容。\n\n#### document.implementation\n\n返回一个`DOMImplementation`对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。\n\n- `DOMImplementation.createDocument()`：创建一个 XML 文档。\n- `DOMImplementation.createHTMLDocument()`：创建一个 HTML 文档。\n- `DOMImplementation.createDocumentType()`：创建一个 DocumentType 对象。\n\n#### 方法\n\n+ **document.open()，document.close()**\n\n  `document.open`方法清除当前文档所有内容，使得文档处于可写状态，供`document.write`方法写入内容。\n\n  `document.close`方法用来关闭`document.open()`打开的文档\n\n+ **document.write()，document.writeln()**\n\n  向当前文档写入内容，字符串会被当做html代码不被转义\n\n+ **document.querySelector()，document.querySelectorAll() **\n\n  接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回`null`\n\n  `document.querySelectorAll`方法与`querySelector`用法类似，区别是返回一个`NodeList`对象，包含所有匹配给定选择器的节点。\n\n  这两个api支持复杂的 CSS 选择器。\n\n  ```js\n  // 选中 data-foo-bar 属性等于 someval 的元素\n  document.querySelectorAll('[data-foo-bar=\"someval\"]');\n  \n  // 选中 myForm 表单中所有不通过验证的元素\n  document.querySelectorAll('#myForm :invalid');\n  \n  // 选中div元素，那些 class 含 ignore 的除外\n  document.querySelectorAll('DIV:not(.ignore)');\n  \n  // 同时选中 div，a，script 三类元素\n  document.querySelectorAll('DIV, A, SCRIPT');\n  ```\n\n  > `querySelectorAll`的返回结果不是动态集合，不会实时反映元素节点的变化\n\n+ **document.getElementsByTagName()**\n\n  搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（`HTMLCollection`实例），可以实时反映 HTML 文档的变化\n\n  这个方法不仅可以在`document`对象上调用，也可以在任何**元素节点**上调用。\n\n  ```js\n  var firstPara = document.getElementsByTagName('p')[0];\n  var spans = firstPara.getElementsByTagName('span');\n  ```\n\n+ **document.getElementsByClassName()**\n\n  类似数组的对象（`HTMLCollection`实例），包括了所有`class`名字符合指定条件的元素，元素的变化实时反映在返回结果中。\n\n  这个方法不仅可以在`document`对象上调用，也可以在任何**元素节点**上调用。\n\n+ **document.getElementsByName()**\n\n  选择拥有`name`属性的 HTML 元素，返回一个类似数组的的对象（`NodeList`实例），因为`name`属性相同的元素可能不止一个\n\n+ **document.getElementById()**\n\n  返回匹配指定`id`属性的元素节点。如果没有发现匹配的节点，则返回`null`\n\n  > 参数区分大小写\n  >\n  > 只能在`document`对象上使用，不能在其他元素节点上使用\n  >\n  > 效率兼容性优于`document.querySelector()`\n\n+ **document.createElement()**\n\n  生成元素节点并返回该节点\n\n  ```js\n  document.createElement('<div>');\n  document.createElement('foo');\n  ```\n\n  > 对大小写不敏感\n  >\n  > 可以是自定义的标签\n\n+ **document.createTextNode()**\n\n  生成文本节点（Text实例）并且返回该节点。\n\n  ```js\n  var div = document.createElement('div');\n  div.appendChild(document.createTextNode('<span>Foo & bar</span>'));\n  ```\n\n  这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击\n\n  ```js\n  console.log(newDiv.innerHTML)\n  // &lt;span&gt;Foo &amp; bar&lt;/span&gt;\n  ```\n\n  上面代码中，`createTextNode`方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。\n\n  需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。\n\n+ **document.createAttribute()**\n\n  生成新的属性节点（Attr实例）并返回他。\n\n  ```js\n  var node = document.getElementById('div1');\n  \n  var a = document.createAttribute('my_attrib');\n  a.value = 'newVal';\n  \n  node.setAttributeNode(a);\n  // 或者\n  node.setAttribute('my_attrib', 'newVal');\n  ```\n\n+ **document.createComment()**\n\n  生成注释节点并返回。\n\n+ **document.createDocumentFragment()**\n\n  生成空白的文档片段，相当于一个`document`节点，拥有相同的属性和方法。\n\n  该方法常常用于解决频繁操作`dom`的需求，他不属于当前文档，任何操作不会引起页面的渲染，也就是虚拟dom操作。\n\n  ```js\n  var docfrag = document.createDocumentFragment();\n  \n  [1, 2, 3, 4].forEach(function (e) {\n    var li = document.createElement('li');\n    li.textContent = e;\n    docfrag.appendChild(li);\n  });\n  \n  var element  = document.getElementById('ul');\n  element.appendChild(docfrag);\n  ```\n\n+ **document.addEventListener()，document.removeEventListener()，document.dispatchEvent()**\n\n  用于处理`document`节点的事件。它们都继承自`EventTarget`接口\n\n  ```js\n  // 添加事件监听函数\n  document.addEventListener('click', listener, false);\n  \n  // 移除事件监听函数\n  document.removeEventListener('click', listener, false);\n  \n  // 触发事件\n  var event = new Event('click');\n  document.dispatchEvent(event);\n  ```\n\n+ **document.hasFocus()**\n\n  返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。\n\n  有焦点的文档必定被激活（active），反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"StyleSheet 接口","url":"%2F2018%2F11%2F28%2FDom--StyleSheet%20%E6%8E%A5%E5%8F%A3%2F","content":"\n`StyleSheet`代表网页的一张样式表，其中可以是`<link>`元素加载的样式表和`<style>`元素内嵌的样式表\n\n#### 获取StyleSheet\n\n可以使用`document`对象的`styleSheets`属性，返回当前页面所有的`StyleSheet`(类数组，有`length`)\n\n```js\nvar sheets = document.styleSheets;\nvar sheet = document.styleSheets[0];\nsheet instanceof StyleSheet // true\n```\n\n如果是`<style>`元素嵌入的样式表，还有另一种获取`StyleSheet`实例的方法，就是这个节点元素的`sheet`属性。\n\n```js\n// HTML 代码为 <style id=\"myStyle\"></style>\nvar myStyleSheet = document.getElementById('myStyle').sheet;\nmyStyleSheet instanceof StyleSheet // true\n```\n\n#### 实例属性\n\n+ **StyleSheet.disabled**\n\n  设置该样式表是否禁用\n\n+ **Stylesheet.href**\n\n  只读，返回样式表的网址\n\n+ **StyleSheet.title**\n\n  返回title属性\n\n+ **StyleSheet.type**\n\n  返回type属性\n\n+ **StyleSheet.ownerNode**\n\n  返回该样式表所载的Dom节点，通常是`<link>`或`<style>`\n\n+ **CSSStyleSheet.cssRules**\n\n  `CSSStyleSheet.cssRules`属性指向一个类似数组的对象（`CSSRuleList`实例），里面每一个成员就是当前样式表的一条 CSS 规则。使用该规则的`cssText`属性，可以得到 CSS 规则对应的字符串。\n\n  ```js\n  var sheet = document.querySelector('#styleElement').sheet;\n  \n  sheet.cssRules[0].cssText\n  // \"body { background-color: red; margin: 20px; }\"\n  \n  sheet.cssRules[1].cssText\n  // \"p { line-height: 1.4em; color: blue; }\"\n  ```\n\n  每条 CSS 规则还有一个`style`属性，指向一个对象，用来读写具体的 CSS 命令。\n\n  ```js\n  cssStyleSheet.cssRules[0].style.color = 'red';\n  cssStyleSheet.cssRules[1].style.color = 'purple';\n  ```\n\n#### 实例方法\n\n+ **CSSStyleSheet.insertRule()**\n\n  在当前样式表中插入新的css规则\n\n  ```js\n  var sheet = document.querySelector('#styleElement').sheet;\n  sheet.insertRule('#block { color: white }', 0);\n  ```\n\n+ **CSSStyleSheet.deleteRule()**\n\n  移除规则\n\n  ```js\n  document.styleSheets[0].deleteRule(1);\n  ```\n\n#### 添加样式表\n\n可以添加两种：内置和外部\n\n+ 内置，添加`<style>`节点\n\n  ```js\n  // 写法一 : 创建元素节点，往元素节点里面增加文本节点\n  var style = document.createElement('style');\n  style.setAttribute('media', 'screen');\n  style.innerHTML = 'body{color:red}';\n  document.head.appendChild(style);\n  \n  // 写法二 ： 创建元素节点，然后插入规则\n  var style = (function () {\n    var style = document.createElement('style');\n    document.head.appendChild(style);\n    return style;\n  })();\n  style.sheet.insertRule('.foo{color:red;}', 0);\n  ```\n\n+ 外部，添加`<link>`节点\n\n  ```Js\n  var linkElm = document.createElement('link');\n  linkElm.setAttribute('rel', 'stylesheet');\n  linkElm.setAttribute('type', 'text/css');\n  linkElm.setAttribute('href', 'reset-min.css');\n  \n  document.head.appendChild(linkElm);\n  ```","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"CSS操作","url":"%2F2018%2F11%2F26%2FDom--CSS%E6%93%8D%E4%BD%9C%2F","content":"\n`css`负责页面的视觉效果，除了自身的`api`，还可以用`js`去操作\n\n#### CSSStyleDeclaration 接口\n\n该接口提供给js操作元素的样式，三个地方可以调用该接口\n\n+ 元素节点的`style`属性(`Element.style`)\n+ `CSSStyle`实例的`style`属性\n+ `window.getComputedStyle()`的返回值\n\n```js\nvar divStyle = document.querySelector('div').style;\ndivStyle.backgroundColor = 'red';\n```\n\n上面的`divStyle`就是`CSSStyleDeclaration` 实例，这个对象包含该元素节点的属性。\n\n> 读取属性时，连词号编程骆驼拼写发，属性值都是字符串，必须包括单位\n>\n> CSSStyleDeclaration 接口针对的是元素的**行内样式**\n\n#### CSSStyleDeclaration 实例属性\n\n+ **CSSStyleDeclaration.cssText**\n\n  用来读写当前规则的所有样式声明文本\n\n  ```js\n  var divStyle = document.querySelector('div').style;\n  divStyle.cssText = 'background-color: red;'\n    + 'border: 1px solid black;'\n    + 'height: 100px;'\n    + 'width: 100px;';\n  \n  //删除一个元素的所有样式\n  divStyle.cssText = '';\n  ```\n\n+ #### **CSSStyleDeclaration.length**\n\n  返回当前规则包含有多少条样式声明，只能获取**行内样式**\n\n+ **CSSStyleDeclaration.parentRule**\n\n  返回当前规则所属的那个样式块\n\n#### CSSStyleDeclaration 实例方法\n\n+ **CSSStyleDeclaration.getPropertyPriority()**\n\n  检测属性是否有含有`!important`，有就返回`!important`，无返回空字符串\n\n+ **CSSStyleDeclaration.getPropertyValue()**\n\n  检查属性值，无则返回空字符串\n\n+ **CSSStyleDeclaration.removeProperty()**\n\n  移除属性\n\n+ **CSSStyleDeclaration.setProperty()**\n\n  设置属性，三个参数：属性名，属性值，优先级（可选，合法值是`important`）\n\n#### CSS模块的检测\n\n从上面可以知道，检测是浏览器是否支持某个浏览器模块，可以通过判断CSSStyleDeclaration 实例里面的属性，返回的值是否是**空字符串**。\n\n```JS\ntypeof element.style.animationName === 'string';\ntypeof content.style['webkitAnimation'] === 'string'\n```\n\n> 如果不支持，表示属性不存在，返回`undefined`，没有设置则会返回空字符串\n>\n> 要考虑不同浏览器的css前缀\n\n检测函数示例：\n\n```js\nfunction isPropertySupported(property) {\n    //in 可以用来检测属性是否存在一个对象里面\n    if (property in document.body.style) return true;\n    var prefixes = ['Moz', 'Webkit', 'O', 'ms', 'Khtml'];\n    //驼峰写法\n    var prefProperty = property.charAt(0).toUpperCase() + property.substr(1);\n    for (var i = 0; i < prefixes.length; i++) {\n        if ((prefixes[i] + prefProperty) in document.body.style) return true;\n    }\n    return false;\n}\n```\n\n#### window.getComputedStyle()\n\n该bom接口用于读取元素的最终样式，包括行内和样式表的样式。\n\n它接受一个节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的最终样式信息。\n\n```js\nvar div = document.querySelector('div');\nvar styleObj = window.getComputedStyle(div);\n```\n\n> 用该接口获取的属性时**只读的**\n\n#### 伪元素\n\n伪元素一般用于生成和页面无关的内容，比如元素的装饰。`:`兼容低版本`ie`\n\n可以用`window.getComputedStyle()`获取元素的伪元素\n\n```js\nvar test = document.querySelector('#test');\n\nvar result = window.getComputedStyle(test, ':before').content;\nvar color = window.getComputedStyle(test, ':before').color;\n```\n\n","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"属性操作","url":"%2F2018%2F11%2F25%2FDom--%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%2F","content":"\n`HTML`的属性就是若干**键值对**的集合。\n\n#### 标准属性\n\n在标准中定义的属性，会自动成为元素节点对象的属性，通过`.`或者`[]`获取\n\n    <div class=\"box\" id=\"box\"></div>\n\n\n```js\nvar box = document.querySelector('#box');\nconsole.log(box.id);  \t  //box\nconsole.log(box['id']);   //box\n```\n#### 自定义属性\n\n区别于标准属性，属于用自行添加的属性，不会自动成为元素节点对象属性\n\n```HTML\n<div class=\"box\" id=\"box\" data-name='boxing'></div>\n```\n\n\n```j\nvar box = document.querySelector('#box');\nconsole.log(box['data-name']); //undefined\n```\n> 使用标准提供的`data-*`属性来添加自定义属性\n\n#### 属性的操作\n\n常用的属性操作有四种，均可以操作标准属性和自定义属性\n\n- `getAttribute()`\n\n  获取属性，返回**字符串。**\n\n- `setAttribute()`\n\n  设置属性（直接使用`class`作为属性名，不用写成`className`）。\n\n- `hasAttribute()`\n\n  返回一个**布尔值**，表示当前元素节点是否包含指定属性。\n\n- `removeAttribute()`\n\n  从当前元素节点移除属性。\n\n#### dataset \n\n`HTMLElement.dataset`属性允许无论是在读取模式和写入模式下访问在 HTML或 DOM中的元素上设置的所有[自定义数据属性](https://developer.mozilla.org/en/HTML/Global_attributes#attr-data-*)(*data-\\**)集。\n\n```js\nvar box = document.querySelector('#box');\n//获取\nconsole.log(box.dataset.name); //boxing\n\n//修改\nbox.dataset.name = 'hello';\nconsole.log(box.dataset.name); //hello\n```\n\n> 注意，`data-`后面的属性名有限制，只能包含字母、数字、连词线（`-`）、点（`.`）、冒号（`:`）和下划线（`_`)。而且，属性名不应该使用`A`到`Z`的大写字母，比如不能有`data-helloWorld`这样的属性名，而要写成`data-hello-world`。","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"Element节点","url":"%2F2018%2F11%2F23%2FDom--Element%E8%8A%82%E7%82%B9%2F","content":"\n`Node`节点的一种，对应网页的`HTML`元素。每一个元素节点都会创建一个`Elment`节点对象。除了继承`Node`属性和方法之外，每种元素节点含有各自构造函数的属性和方法。\n\n#### 实例属性\n\n+ 元素特性相关(`id,tagName,dir,accessKey,draggable,lang,tabIndex,title`)\n\n  ```js\n  var span = document.getElementById('myspan');\n  span.id \t\t // \"myspan\"  id\n  span.tagName\t // \"SPAN\"    返回指定元素的大写标签名\n  span.accessKey \t // \"h\"       快捷键\n  span.draggable   //true    \t  是否可以拖动\n  span.lang        //en         语言设置，可读写\n  span.tabIndex\n  span.title       //title属性，可读写\n  ```\n\n+ 元素状态相关\n\n  ```js\n  var mydiv = document.getElementById('mydiv');\n  mydiv.hidden // true  布尔值，表示元素的hidde属性，和css属性相互对立\n  \n  //设置元素内容是否可以编辑\n  mydiv.contentEditable  \n  mydiv.isContentEditable   \n  \n  \n  //返回当前元素节点的所有属性节点\n  var attrs = mydiv.attributes  \n  for (var i = attrs.length - 1; i >= 0; i--) {\n      //遍历mydiv元素的所有属性\n    console.log(attrs[i].name + '->' + attrs[i].value);\n  }\n  \n  \n  //设置元素的class\n  var div = document.getElementById('myDiv');\n  div.className // \"one two three\"\n  div.classList  //{0: \"one\",1: \"two\",2: \"three\",length: 3}\n  //classList的方法\n  div.classList.add('myCssClass');   \n  div.classList.add('foo', 'bar');\t //增加多个\n  div.classList.remove('myCssClass');  //移除\n  div.classList.toggle('myCssClass');  // 如果 myCssClass 不存在就加入，否则移除\n  div.classList.contains('myCssClass'); //是否包含\n  div.classList.item(0); \t\t\t\t// 返回第一个 Class\n  div.classList.toString();\n  \n  \n  //自定义属性\n  // <article id=\"foo\" data-columns=\"3\" data-index-number=\"12314\" data-parent=\"cars\">\n  var article = document.getElementById('foo');\n  article.dataset.columns // \"3\"\n  article.dataset.indexNumber // \"12314\"\n  article.dataset.parent // \"cars\"\n  /*\n  \tHTML 代码中，data-属性的属性名，只能包含英文字母、数字、连词线（-）、点（.）、冒号（:）和下划线（_）。它们转成 JavaScript 对应的dataset属性名，规则如下。\n     · 开头的data-会省略。\n     · 如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。\n     · 其他字符不变。\n  */\n  \n  \n  //属性获取元素的html代码①\n  // HTML代码如下 <p id=\"para\"> 5 > 3 </p>\n  document.getElementById('para').innerHTML   // 5 &gt; 3 \n  /*\n  \t读取属性值的时候，如果文本节点包含&、小于号（<）和大于号（>），innerHTML属性会将它们转为实体形式&amp;、&lt;、&gt;。如果想得到原文，建议使用element.textContent属性。\n  \t插入的文本包含html标签，会被自动转换为节点对象插入DOM\n  \t如果只是插入纯文本，应该使用element.textContent\n  */\n  \n  \n  //属性获取元素的html代码②\n  // <div id=\"d\"><p>Hello</p></div>\n  var d = document.getElementById('d');\n  d.outerHTML  // '<div id=\"d\"><p>Hello</p></div>'\n  // Element.outerHTML属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。可读写，尤其注意，如果当前节点没有父节点，改写改属性会报错\n  var div = document.createElement('div');\n  div.outerHTML = '<p>test</p>';// DOMException: This element has no parent node.\n  \n  \n  //元素宽高相关\n  /*\n  \t元素的内容高度\n  \tElement.clientHeight = content+padding - 滚动条高度 \n  \t\n  \t元素的边框\n  \tElement.clientLeft = 元素节点左边框（left border）的宽度\n  \t...其他相似\n  \t\n  \t总高度（不包含溢出）\n  \tElement.offsetHeight = content+padding+border+滚动条高度\n  \t\n  \t\n  \t实际总高度（包含溢出部分）\n  \tElement.scrollHeight = content+padding+伪元素（高度）- 滚动条高度 \n  */\n  // 返回网页的总高度,溢出的也会计算在内\n  document.documentElement.scrollHeight\n  document.body.scrollHeight\n  \n  \n  //元素滚动的距离\n  /*\n  \tElement.scrollLeft = 前元素的水平滚动条向右侧滚动的像素数量\n  \tElement.scrollTop = 当前元素的垂直滚动条向下滚动的像素数量\n  */\n  //查看整张网页的水平和垂直滚动距离\n  document.documentElement.scrollLeft\n  document.documentElement.scrollTop\n  \n  \n  //获取最近的position非静态的上策元素 Element.offsetParent\n  /*\n      <div style=\"position: absolute;\">\n        <p>\n          <span>Hello</span>\n        </p>\n      </div>\n      \n      span元素的 Element.offsetParent = div\n  */\n  \n  \n  \n  //元素的偏移\n  function getElementPosition(e) {\n    var x = 0;\n    var y = 0;\n    while (e !== null)  {\n      x += e.offsetLeft;   //当前元素左上角相对于Element.offsetParent节点的水平位移\n      y += e.offsetTop;\n      e = e.offsetParent;\n    }\n    return {x: x, y: y};\n  }\n  \n  \n  //节点元素之间的获取\n  // Element.children  返回所有子元素节点，区别于 childNodes返回所有节点\n  // Element.childElementCount  获取的数量\n  // Element.firstElementChild 返回当前元素的第一个元素子节点\n  // Element.lastElementChild 返回最后一个元素子节点\n  // Element.nextElementSibling 返回当前元素节点的后一个同级元素节点\n  // Element.previousElementSibling 返回当前元素节点的前一个同级元素节点\n  ```\n\n#### 实例方法（属性）\n\n+ 元素节点提供六个方法，用来操作属性。\n\n  - `getAttribute()`：读取某个属性的值\n  - `getAttributeNames()`：返回当前元素的所有属性名\n  - `setAttribute()`：写入属性值\n  - `hasAttribute()`：某个属性是否存在\n  - `hasAttributes()`：当前元素是否有属性\n  - `removeAttribute()`：删除属性\n\n+ 元素节点的获取\n\n  + **Element.querySelector()和Element.querySelectorAll()**\n\n    均接受css选择器作为参数，可多个，用逗号隔开\n\n    `Element.querySelectorAll()`返回一个`NodeList`实例\n\n  + **Element.getElementsByClassName()**返回一个`HTMLCollection`实例，成员是当前元素节点的所有具有指定 class 的子元素节点\n\n  + **Element.getElementsByTagName()**\n\n    返回一个`HTMLCollection`实例\n\n  + **Element.closest()**\n\n    接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）\n\n  + **Element.matches()**\n\n    返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器\n\n    ```js\n    if (el.matches('.someClass')) {\n      console.log('Match!');\n    }\n    ```\n\n#### 实例方法（事件）\n\n元素节点继承了了`EventTarget`接口\n\n- `Element.addEventListener()`：添加事件的回调函数\n- `Element.removeEventListener()`：移除事件监听函数\n- `Element.dispatchEvent()`：触发事件\n\n元素节点的事件存在很多浏览器兼容性问题，所以不一一列举\n\n","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"Node关系接口","url":"%2F2018%2F11%2F22%2FDom--Node%E5%85%B3%E7%B3%BB%E6%8E%A5%E5%8F%A3%2F","content":"\n节点除了继承`Node`接口方法，如果当前节点是父节点，会继承`ParentNode`接口方法，如果是子节点，会继承方法`ChildNode`接口方法。\n\n#### ParentNode 接口\n\n只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承`ParentNode`接口\n\n+ `ParentNode.children`\n\n  返回`HTMLCollection`实例，成员是当前节点的所有元素子节点。该属性只读。\n\n+ `ParentNode.firstElementChil`和`ParentNode.lastElementChild`\n\n  分别返回当前节点的第一个元素子节点和最后一个元素节点，没有则返回`null`。\n\n+ `ParentNode.childElementCount`\n\n  返回所有元素子节点的数目\n\n+ `ParentNode.append()，ParentNode.prepend()`\n\n  分别指在当前节点最后一个元素子节点后面和第一个元素子节点的前面追加节点。\n\n#### ChildNode 接口\n\n有父节点，就继承`ChildNode`接口\n\n+ `ChildNode.remove()`\n\n  从父节点中移除当前节点\n\n+ `ChildNode.before()`和`ChildNode.after()`\n\n  分别指在当前节点的前面和当前节点的后面，插入一个或多个同级节点\n\n+ `ChildNode.replaceWith()`\n\n  替换当前节点\n\n  ```js\n  var span = document.createElement('span');\n  el.replaceWith(span);\n  ```\n","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"Node接口","url":"%2F2018%2F11%2F21%2FDom--Node%E6%8E%A5%E5%8F%A3%2F","content":"\n`Node`是`DOM`的最小单位，所有的`DOM`节点都继承了`Node`接口的属性和方法。\n\n#### 属性\n\n+ Node.prototype.nodeType\n\n  ```js\n  document.nodeType\n  ```\n\n  返回节点类型，常用的属性：\n\n  + 元素节点（element）：1，对应常量`Node.ELEMENT_NODE`\n  + 属性节点（attr）：2，对应常量`Node.ATTRIBUTE_NODE`\n  + 文本节点（text）：3，对应常量`Node.TEXT_NODE`\n\n+ Node.prototype.nodeName\n\n  返回属性节点的名称，不同节点的`nodeName`属性值如下：\n\n  + 文档节点（document）：`#document`\n\n  + 元素节点（element）：大写的标签名\n\n  + 属性节点（attr）：属性的名称\n\n  + 文本节点（text）：`#text`\n\n  + 文档片断节点（DocumentFragment）：`#document-fragment`\n\n  + 文档类型节点（DocumentType）：文档的类型\n\n  + 注释节点（Comment）：`#comment`\n\n+ Node.prototype.nodeValue\n\n  返回一个字符串，便是当前节点本身的文本值。只有**文本节点（text）、注释节点（comment）和属性节点（attr）**有文本值，因此这三类节点的`nodeValue`可以返回结果，其他类型的节点一律返回`null`。同样的，也只有这三类节点可以设置`nodeValue`属性的值，其他类型的节点设置无效。\n\n  ```js\n  // HTML 代码如下\n  // <div id=\"d1\">hello world</div>\n  var div = document.getElementById('d1');\n  div.nodeValue // null  div是元素节点，返回null\n  div.firstChild.nodeValue // \"hello world\"\n  ```\n\n+ Node.prototype.textContent\n\n  属性返回当前节点和它的所有后代节点的文本内容，可读写。就像jq里面的text。\n\n  ```js\n  // HTML 代码为\n  // <div id=\"divA\">This is <span>some</span> text</div>\n  \n  document.getElementById('divA').textContent\n  // This is some text\n  ```\n\n  > 如果要读取整个文档的内容，可以使用`document.documentElement.textContent`\n\n+ Node.prototype.baseURI\n\n  返回一个字符串，表示当前网页的绝对路径\n\n+ Node.prototype.ownerDocument\n\n  返回当前节点所在的顶层文档对象，即`document`对象\n\n+ Node.prototype.nextSibling\n\n  返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回`null`\n\n  ```js\n  // HTML 代码如下\n  // <div id=\"d1\">hello</div><div id=\"d2\">world</div>\n  var d1 = document.getElementById('d1');\n  var d2 = document.getElementById('d2');\n  \n  d1.nextSibling === d2 // true\n  ```\n\n  `nextSibling`属性可以用来遍历所有子节点。\n\n  ```js\n  var el = document.getElementById('div1').firstChild;\n  \n  while (el !== null) {\n    console.log(el.nodeName);\n    el = el.nextSibling;\n  }\n  ```\n\n+ Node.prototype.previousSibling\n\n  返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回`null`\n\n+ Node.prototype.parentNode\n\n  返回当前节点的父节点\n\n+ Node..prototype.parentElement \n\n  返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回`null`\n\n+ Node..prototype.firstChild和Node..prototype.lastChild\n\n  `firstChild`属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回`null`，\n\n  `lastChild`属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回`null`\n\n+ **Node.prototype.childNodes**\n\n  返回一个类似数组的对象（`NodeList`集合），成员包括当前节点的所有子节点\n\n  >通过`node.childNodes`获得节点只是下一级的节点，比如里面有`<p> <span>1</span> </p>`\n  >\n  >换行符的也是文本节点\n\n+ Node.prototype.isConnected\n\n  属性返回一个布尔值，表示当前节点是否在文档之中\n\n  ```js\n  var test = document.createElement('p');\n  test.isConnected // false\n  \n  document.body.appendChild(test);\n  test.isConnected // true\n  ```\n\n#### 方法\n\n+ Node.prototype.appendChild()\n\n  接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。\n\n  ```js\n  var p = document.createElement('p');\n  document.body.appendChild(p);\n  ```\n\n  > 如果参数节点是 DOM 已经存在的节点，`appendChild`方法会将其从原来的位置，移动到新位置\n\n+ Node.prototype.hasChildNodes()\n\n  返回一个布尔值，表示当前节点是否有子节点\n\n  判断一个节点有没有子节点，有许多种方法，下面是其中的三种。\n\n  - `node.hasChildNodes()`\n  - `node.firstChild !== null`\n  - `node.childNodes && node.childNodes.length > 0`\n\n+ Node.prototype.cloneNode()\n\n  克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点\n\n  > 克隆的节点只有属性，会丧失`addEventListener`方法和`on-`属性（即`node.onclick = fn`），添加在这个节点上的事件回调函数\n\n+ Node.prototype.insertBefore(newNode, referenceNode)\n\n  将某个节点插入父节点内部的指定位置。第一个参数是所要插入的节点`newNode`，第二个参数是父节点`parentNode`内部的一个子节点`referenceNode`。\n\n  ```js\n  var p = document.createElement('p');\n  document.body.insertBefore(p, document.body.firstChild);\n  ```\n\n  > `newNode`将插在`referenceNode`这个子节点的前面\n\n+ Node.prototype.removeChild()\n\n  接受一个子节点作为参数，用于从当前节点移除该子节点，返回移除的节点\n\n  ```js\n  var divA = document.getElementById('A');\n  divA.parentNode.removeChild(divA);\n  ```\n\n  > 必须在父节点上调用\n\n+ Node.prototype.replaceChild(newChild, oldChild)\n\n  将一个新的节点，替换当前节点的某一个子节点\n\n  ```js\n  var divA = document.getElementById('divA');\n  var newSpan = document.createElement('span');\n  newSpan.textContent = 'Hello World!';\n  divA.parentNode.replaceChild(newSpan, divA);\n  ```\n\n+ Node.prototype.contains()\n\n  返回一个参数，是否满足下面三个条件之一\n\n  + 参数节点为当前节点。\n  + 参数节点为当前节点的子节点。\n  + 参数节点为当前节点的后代节点\n\n  ```js\n  document.body.contains(node)   //检查node是否包含在当前文档之中\n  ```\n\n+ Node.prototype.compareDocumentPosition()\n\n  返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。\n\n  | 二进制值 | 十进制值 | 含义                                               |\n  | -------- | -------- | -------------------------------------------------- |\n  | 000000   | 0        | 两个节点相同                                       |\n  | 000001   | 1        | 两个节点不在同一个文档（即有一个节点不在当前文档） |\n  | 000010   | 2        | 参数节点在当前节点的前面                           |\n  | 000100   | 4        | 参数节点在当前节点的后面                           |\n  | 001000   | 8        | 参数节点包含当前节点                               |\n  | 010000   | 16       | 当前节点包含参数节点                               |\n  | 100000   | 32       | 浏览器内部使用                                     |\n\n  ```js\n  // HTML 代码如下\n  // <div id=\"mydiv\">\n  //   <form><input id=\"test\" /></form>\n  // </div>\n  \n  var div = document.getElementById('mydiv');\n  var input = document.getElementById('test');\n  \n  div.compareDocumentPosition(input) // 20\n  input.compareDocumentPosition(div) // 10\n  ```\n\n+ Node.prototype.isEqualNode()和Node.prototype.isSameNode()\n\n  `isEqualNode`方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。\n\n  `isSameNode`方法返回一个布尔值，表示两个节点是否为同一个节点。\n\n+ Node.prototype.normalize()\n\n  清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点\n\n+ Node.prototype.getRootNode()\n\n  返回当前节点所在文档的根节点，与`ownerDocument`属性的作用相同\n\n","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"回掉函数，同步异步","url":"%2F2018%2F11%2F20%2FJS--%E5%9B%9E%E6%8E%89%E5%87%BD%E6%95%B0%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%2F","content":"\n#### 回掉函数\n\n函数和普通对象一样可以当作参数传递。当函数用于**传参**时，该函数就是回掉函数。\n> A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.\n\n#### 同步和异步\n\njs是**单线程**执行的，所以如果遇到阻塞操作，他并不会傻傻等待阻塞操作执行完，而是把这个操作放到循环队列中，等线程有空闲再执行。\n浏览器是**多线程**的，除了处理js之外还需要处理图形等。\n\n+ 同步\n并不是所有的回掉函数都是异步的，看一下一个例子：\n```js\n    // 函数a\n    function a(fn) {\n        //函数是参数\n        fn();\n        console.log(1);\n    }\n    //函数b\n    function b() {console.log(2);}\n    a(b);  //2 ,1\n```\nb函数并非在a执行后执行，因为b函数的执行并不是**阻塞**的，所以他会在js的主线程直接运行下去。\n+ 异步\n所以，如果b函数是阻塞操作，则不会在js主线程运行:\n```js\n     // 函数a\n    function a(fn) {\n        //函数是参数\n        setTimeout(function () {\n            fn();\n        }, 0);\n        console.log(1);\n    }\n    //函数b\n    function b() {console.log(2);}\n    a(b);  //1 ,2   \n```\n可以看到，尽管b函数在前，但是由于计时器是**阻塞操作**，所以在js主线程结束后才会执行b函数\n\n#### JS常见的异步操作（阻塞操作）：\n> 回调函数\n事件监听\n发布/订阅\npromise\ngenerator（ES6）\nasync/await(ES7)","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"集合接口","url":"%2F2018%2F11%2F20%2FDom--Node%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3%2F","content":"\n`NodeList`和`HTMLCollection`包含多个节点，两者区别在于，`NodeList`包含各种类型的节点，`HTMLCollection`只包含HTML元素节点。\n\n#### NodeList 接口\n\n类数组，有`length`属性和`forEach`方法，可以通过以下方式获得：\n\n```js\n// Node.childNodes\ndocument.element.childNodes   \ndocument.querySelectorAll()   //等节点搜索方法\n```\n\n继承的属性和方法：\n\n+ `NodeList.prototype.length`返回所有节点数量\n\n+ `NodeList.prototype.forEach()`遍历 NodeList 的所有成员\n\n  ```js\n  var children = document.body.childNodes;\n  children.forEach(function f(item, i, list) {\n    // ...\n  }, this);\n  ```\n\n+ `NodeList.prototype.item()`接受一个整数值作为参数，表示成员的位置，返回该位置上的成员\n\n  ```js\n  document.body.childNodes.item(0)\n  ```\n\n+ `NodeList.prototype.keys()`，`NodeList.prototype.values()`，`NodeList.prototype.entries()`返回一个 ES6 的遍历器对象，可以通过`for...of`循环遍历获取每一个成员的信息。`keys()`返回键名的遍历器，`values()`返回键值的遍历器，`entries()`返回的遍历器同时包含键名和键值的信息\n\n  ```js\n  var children = document.body.childNodes;\n  \n  for (var key of children.keys()) {\n    console.log(key);\n  }\n  // 0\n  // 1\n  // 2\n  // ...\n  \n  for (var value of children.values()) {\n    console.log(value);\n  }\n  // #text\n  // <script>\n  // ...\n  \n  for (var entry of children.entries()) {\n    console.log(entry);\n  }\n  // Array [ 0, #text ]\n  // Array [ 1, <script> ]\n  // ...\n  ```\n\n但是，他不能使用数组方法，通过数组化可以改变\n\n```js\nvar children = document.body.childNodes;\nvar nodeArr = Array.prototype.slice.call(children);\n```\n\n> 包含所有节点类型\n>\n> 类数组\n\n#### HTMLCollection接口\n\n`HTMLCollection`是一个节点对象的集合，只能包含元素节点（element），虽然也是类数组，但是没有`forEach`方法。他和`NodeList`，拥有`length`和`item()`，还有自身独有的`namedItem()`,参数是一个字符串，表示`id`属性或`name`属性的值，返回对应的元素节点。如果没有对应的节点，则返回`null`\n\n```js\n// HTML 代码如下\n// <img id=\"pic\" src=\"http://example.com/foo.jpg\">\n\nvar pic = document.getElementById('pic');\ndocument.images.namedItem('pic') === pic // true\n```\n\n","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"Document和DocumentFragment","url":"%2F2018%2F11%2F20%2FDom--Document%E5%92%8CDocumentFragment%2F","content":"\n#### Document\n\n表示在浏览器中已经加载好的网页，提供一个接口用于操作网页，他是**真实的DOM**，每一次的DOM操作会引起DOM树的**重新渲染**\n\n属性继承自**Node**，节点类型是`Node.DOCUMENT_NODE`\n\n#### DocumentFragment \n\n表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 [`Document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document) 使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因它**不是真实DOM树的一部分**，它的变化不会引起DOM树的重新渲染的操作([reflow](https://developer.mozilla.org/en-US/docs/Glossary/reflow)) ，且不会导致性能等问题。常用于`virtual dom`技术。\n\n属性继承自**Node**，节点类型是`Node.DOCUMENT_FRAGMENT_NODE`\n\n> Document和DocumentFragment 的属性都继承自Node\n>\n> Document是真实的DOM，而DocumentFragment是虚拟的\n\n#### 应用\n\n使用文档片段（DocumentFragment）作为参数，这种情况下被添加(append)或被插入(inserted)的是片段的所有子节点, 而非片段本身。因为所有的节点会被一次插入到文档中，而这个操作仅发生一个重渲染的操作，而不是每个节点分别被插入到文档中，因为后者会发生多次重渲染的操作。\n\n```js\n//转化为碎片文档\nfunction node2Fragment(el) {\n    //获取元素节点，类数组，有length\n    var el = document.querySelector(el);\n    //创建一个碎片文档\n    var fragment = document.createDocumentFragment();\n    //网碎片文档里添加节点\n    [].slice.call(el).forEach((node)=>{\n        fragment.appendChild(node)\n    })\n    return fragment;\n}\n```\n\n","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"参与者模式","url":"%2F2018%2F11%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8F%82%E4%B8%8E%E8%80%85%E6%A8%A1%E5%BC%8F%2F","content":"\n在特定的**作用域**中执行给定的函数，并将**参数**原封不动地传递。\n\n我们在写兼容浏览器的绑定函数时，没有考虑参数的传递\n```js\n    //事件绑定方法\n    var A = {};\n    A.event.on = function (dom,type,fn) {\n        // w3c标准事件\n        if(dom.addEventListener){\n            dom.addEventListener(type,fn,false);\n            //ie浏览器\n        }else if (dom.attachEvent) {\n            dom.attachEvent('on'+type,fn);\n            //DOM级事件绑定\n        }else {\n            dom['on' + type,fn];\n        }\n    }\n```\n因为addEventListener不能传递参数，所以可以在**回掉函数**中做文章\n```js\n    //事件绑定方法\n    var A = {};\n    A.event.on = function (dom,type,fn,data) {\n        // w3c标准事件\n        if(dom.addEventListener){\n            dom.addEventListener(type,function (e) {\n                    fn.call(dom,e,data)\n            },false);\n            //ie浏览器\n        }\n        ...                                      \n    }\n```\n\n#### 柯里化\n把一个多参数的函数，转化为单参数的函数\n```js\n    //柯里化之前\n    function add(x,y) {\n        return x + y;\n    }\n    // 柯里化之后\n    function addX(y) {\n        //输入第一个参数，返回一个函数\n      return function (x) {\n          //输入第二个参数，返回x+y\n          //改匿名函数是闭包，引用了父函数的y\n        return x + y;\n      };\n    }\n    console.log(addX(1)); //ƒ (x) {return x + y;}\n    console.log(addX(1)(2)); //3\n```\n\n使用柯里化的思想，完善bind方法\n```js\n    if (Function.prototype.bind == undefined) {\n        Function.prototype.bind = function (context) {\n            //缓存数组\n            var Slice = [].slice,\n                // 参数数组化\n                args = Slice.call(arguments,1),\n                //保存当前函数引用\n                that = this;\n            //返回新函数\n            return function () {\n                  // 参数数组化\n                  var addArgs = Slice.call(arguments),\n                      // 拼接参数，传入的参数放入了后面\n                      allArgs = args.concat(addArgs),\n                  //对当前函数装饰并返回\n                  return that.apply(context,allArgs);\n            }\n        }\n    }\n```","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"DOM 概述","url":"%2F2018%2F11%2F20%2FDom--%E6%A6%82%E8%BF%B0%2F","content":"\n`DOM` 是 `JavaScript` 操作网页的**接口**，全称为“文档对象模型”`（Document Object Model）`。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\n\n浏览器会根据` DOM `模型，将结构化文档（比如 `HTML` 和` XML`）解析成一系列的节点，再由这些节点组成一个树状结构`（DOM Tree）`。所有的节点和最终的树状结构，都有规范的对外接口。\n\n> DOM 只是一个**接口规范**，可以用各种语言实现\n>\n> 浏览器会根据DOM规范，将文档解析成节点（Node），生成DOM Tree（由各种Node组成）\n\n#### 节点（Node）\n\n`DOM `的最小组成单位叫做节点`（node）`。文档的树形结构`（DOM 树）`，就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。\n\n节点的类型有七种。\n\n- `Document`：整个文档树的顶层节点\n- `DocumentType`：`doctype`标签（比如`<!DOCTYPE html>`）\n- `Element`：网页的各种HTML标签（比如`<body>`、`<a>`等）\n- `Attribute`：网页元素的属性（比如`class=\"right\"`）\n- `Text`：标签之间或标签包含的文本\n- `Comment`：注释\n- `DocumentFragment`：文档的片段\n\n浏览器提供一个原生的节点对象`Node`，上面这七种节点都继承了`Node`，因此具有一些共同的属性和方法。他们的关系如下：\n\n![图片描述](https://segmentfault.com/img/bVPx26?w=1081&h=439)\n\n> Node是dom的最小单位\n>\n> 常见的标签Element只是Node的其中一种\n>\n> 各个节点之间经常**相互包含**，比如`Element`里面存在`Text`\n\n#### 节点树\n\n浏览器原生提供`document`节点，代表整个文档吗，如下图所示\n\n ![DOM结构图](https://segmentfault.com/img/bVPx06?w=514&h=241)\n\n`Document`接口表示任何在浏览器中已经加载好的**网页**，并作为一个**入口**去操作网页内容（也就是[DOM tree](https://developer.mozilla.org/en-US/docs/Using_the_W3C_DOM_Level_1_Core)）\n\n","tags":["Dom编程艺术"],"categories":["Dom编程艺术"]},{"title":"惰性模式","url":"%2F2018%2F11%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E6%83%B0%E6%80%A7%E6%A8%A1%E5%BC%8F%2F","content":"\n用于减少每次代码执行时的**重复性的分支判断**，通过对对象重定义来屏蔽原对象中分支判断。\n比如我们在判断浏览器兼容性时，会有多个分支，每次执行时如果都重新进行判断，无疑是对资源的浪费，这就可以通过惰性模式来优化。\n有**两种**实现方法：立即执行和惰性执行\n### 立即执行\n当对象初始化的时候就立即执行，重写对象的方法\n```js\n    //添加绑定事件方法on\n    A.on = function(dom, type, fn) {\n        //如果支持addEventListener方法\n        if (document.addEventListener) {\n            //返回新定义方法\n            A.on = function() {\n                dom.addEventListener(type, fn, false);\n            //如果支持attachEvent方法\n        } else if (document.attachEvent) {\n            //返回新定义的方法\n            return function(dom, type, fn) {\n                dom.attachEvent('on' + type, fn);\n            }\n        } else {\n            //返回新的方法\n            return function(dom, type, fn) {\n                dom['on' + type] = fn;\n            }\n        }\n    };\n```\n页面执行的时候进行判断然后重新对象，不过在初始化的时候会消耗一些资源\n\n### 惰性执行\n在有需要的时候才对对象进行重写。\n```js\n    //添加绑定事件方法on\n    A.on = function(dom, type, fn) {\n        //如果支持addEventListener方法\n        if (document.addEventListener) {\n            //返回新定义方法\n            A.on =  function() {\n                dom.addEventListener(type, fn, false);\n            }\n            //如果支持attachEvent方法\n        } else if (document.attachEvent) {\n            //返回新定义的方法\n            A.on =  function(dom, type, fn) {\n                dom.attachEvent('on' + type, fn);\n            }\n        } else {\n            //返回新的方法\n            A.on =  function(dom, type, fn) {\n                dom['on' + type] = fn;\n            }\n        }\n        //执行重新定义的on方法\n        A.on(dom,type,fn);\n    };\n```\n文档加载后on方法还没有重新定义，当为某一个元素使用on方法时候对on方法进行**重写**，同时末尾**执行重写后的on方法**","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"节流模式","url":"%2F2018%2F11%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%8A%82%E6%B5%81%E6%A8%A1%E5%BC%8F%2F","content":"\n节流模式用于**性能优化**，比如js中的resize，mousemove等是会不间断触发的，我们就可以这么优化：\n```js\n    //简单的节流模式\n    //method ：方法\n    //context ：上下文\n    function throttle(method,context){\n        //清除定时器\n        clearTimeout(method.tId);\n        //300ms时间间隔后执行函数\n        method.tId=setTimeout(function(){\n            method.call(context)\n        },300)\n    }\n    //让函数执行延迟300毫秒，在300毫秒内如果有函数又被调用则删除上一次调用\n```\n 函数节流的基本思想是设置一个定时器，在**指定时间间隔**内运行代码时清除上一次的定时器，并设置另一个定时器，直到函数请求停止并超过时间间隔才会执行。\n\n#### 节流模式延迟加载图片\n监听页面的scroll与resize事件并且节流处理。将所有图片做缓存，检测每张图片是否在页面的可视范围内，如果在可视范围就将图片加载，并且将此图片从图片的缓存中清楚。\n```js\n    //延迟加载图片\n    /*\n    param id 延迟加载图片的容器id\n    图片格式如下 <img src=\"img/loading.gif\" alt=\"\" data-src=\"img/1.jpg\"/>\n    */\n    function LazyLoad(id) {\n        //需要获取截留延迟加载图片的容器\n        this.container = document.getElementById(id);\n        //缓存图片\n        this.imgs = this.getImgs();\n        //执行逻辑\n        this.init();\n    }\n    LazyLoad.prototype = {\n        //初始化\n        init:function () {},\n        //获取延迟加载的图片\n        getImgs:function () {},\n        //加载图片\n        update:function () {},\n        //判断图片是否在可视范围中\n        shouldShow:function (i) {},\n        //获取元素页面中的纵坐标位置\n        pageY:function (element) {},\n        //绑定事件（简化版）\n        on:function (element,type,fn) {},\n        //为窗口绑定resize事件与scroll事件\n        bindEvent:function () {}\n    }\n```\ninit初始化要做两件事，初始化图片加载（即执行update方法）和为窗口绑定事件（bindEvent方法）\n```js\n    //初始化\n    init:function () {\n        //加载当前视图图片\n        this.update();\n        //绑定事件\n        this.bindEvent();\n    },\n```\n获取容器内图片方法时，为了方便操作获取的图片元素集合，需要将其转换成数组\n```js\n    //获取延迟加载的图片\n    getImgs:function () {\n        //新数组容器\n        var arr = [];\n        //获取图片\n        var imgs = this.container.getElementsByTagName('img');\n        //将获取的图片转化为数组\n        for (var i = 0; i < imgs.length; i++) {\n            arr.push(imgs[i])\n        }\n        return arr;\n    },\n```\n加载图片的update方法，需要遍历每一个图片元素，如果处在可视区域内则加载并将其在图片中的缓存清除\n```js\n    //加载图片\n    update:function () {\n        //如果图片都加载完成，返回\n        if (!this.imgs.length) {\n            return;\n        }\n        //获取图片长度\n        var i = this.imgs.length;\n        //遍历图片\n        for (--i; i >=0; i--) {\n            //如果图片在可视范围内\n            if (this.shouldShow(i)) {\n                //加载图片\n                this.img[i].src = this.img[i].getAttribute('data-src');\n                //清楚此图片的缓存\n                this.imgs.splice(i,1);\n            }\n        }\n    },\n```\n对于图片是否在可视范围内，是判断图片的上下边左边位置是否符合下列条件：图片底部高度大于可视视图顶部高度并且图片底部高度小于可视视图底部高度，或者图片顶部高度大于可视视图顶部高度并且图片顶部高度小于可视试图底部高度。\n```js\n    //判断图片是否在可视范围中\n    shouldShow:function (i) {\n        //获取当前图片\n        var img = this.imgs[i],\n        //可视范围内顶部高度(页面滚动条top值)\n        scrollTop = document.documentElement.scrollTop || document.body.scrollTop,\n        //可视范围内底部高度\n        scrollBottom = scrollTop + document.documentElement.clientHeight;\n        //图片顶部位置\n        imgTop = this.pageY(img),\n        //图片底部位置\n        imgBottom= imgTop+ img.offsetHeight;\n        //进行判断\n        if (imgBottom>scrollTop && imgBottom<scrollBottom || (imgTop>scrollTop && imgTop<scrollBottom)) {\n            return true;\n        }else {\n            return false;\n        }\n    }\n```\n取元素的纵坐标是通过元素一级一级遍历其父元素，并累加每一级元素offsetTop值获取\n```js\n    //获取元素页面中的纵坐标位置\n    pageY:function (element) {\n        //如果有父元素\n        if (element.offsetParent {\n            //返回元素 + 父元素高度\n            return element.offsetTop + this.pageY(element.offsetParent);\n        }else {\n            //返回元素的高度\n            return element.offsetTop;\n        }\n    },\n```\n简化on事件\n```js\n    //绑定事件（简化版）\n    on:function (element,type,fn) {\n        if (element.addEventListener) {\n            addEventListener(type,fn,false);\n        }else {\n            element.attachEvent('on'+type,fn,false)\n        }\n    },\n```\n最后是节流器优化加载，通过bindEvent绑定页面的scroll和resize时间，节流处理\n","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"迭代器模式","url":"%2F2018%2F11%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F","content":"\n在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。\n常用于解决臃肿的**循环问题**。\n\n#### 创建一个迭代器\n```js\n    //迭代器\n    var Iterator = function(container,items) {\n        //如果父容器不存在获取document\n        var container = container && document.getElementById(container) || document,\n            //获取元素和长度\n            items = container.getElementsByTagName(items),\n            length = items.length,\n            //当前索引值 默认0\n            index = 0;\n            //缓存原生数组splice方法\n        var splice = [].splice;\n        //返回接口\n        return {\n            //第一个\n            first:function () {},\n            //最后一个\n            last:function () {},\n            //上一个\n            prev:function () {},\n            //下一个\n            next:function () {},\n            //指定元素\n            get:function () {},\n            //对每一个元素执行某一个方法\n            deelEach:function () {},\n            //对某一个元素执行方法\n            deelItem:function () {},\n            //排他方式处理某一个元素\n            exclusive:function () {},\n        }\n    }\n```\n#### 方法的实现\n对于前四个比较容易实现\n```js\n    first:function () {\n        indexo = 0;           //矫正索引\n        return items[index];   //获取第一个元素\n    },\n    //最后一个\n    last:function () {\n        index = length-1;      //矫正索引\n        return items[index];    //获取最后一个元素\n    },\n    //上一个\n    prev:function () {\n        if(--index>0){               //如果上一张不是头\n            return items[index]       //获取元素\n        }else {\n            index = 0;               //索引值为0\n            return null;             // 返回为空\n        }\n    },\n    //下一个\n    next:function () {\n        if (++index<length) {        //如果不是尾巴\n            return items[index];      //获取元素\n        }else {\n            index = length-1;        //索引值为尾巴\n            return null;             //返回空\n        }\n    },\n```\n获取某一个元素\n```js\n    //指定元素\n    get:function (num) {\n        //如果num大于等于0再获取正向获取，否则逆向获取\n        index = num>=0 ? num%length : num%length +length;\n        return items[index];          //返回元素\n    },\n```\n对每一个元素执行某一方法是通过访问者模式使用回掉函数在每一个元素的**作用域中执行一次**。\n如果传入的参数大于一个，则将多余参数作为回掉函数的参数传递。\n```js\n    //对每一个元素执行某一个方法\n    deelEach:function (fn) {\n        //第二个参数开始为回掉函数中的参数\n        var args = splice.call(arguments,1);\n        //遍历元素\n        for (var i = 0; i < length; i++) {\n            //对元素执行回掉函数\n            fn.apply(items[i],args);\n        }\n    },\n```\n对于处理某一个元素的方法，需要将回掉函数执行时候的**作用域**变为该元素即可。\n如果参数大于两个，多余参数作为回掉函数的参数传递。\n```js\n    //对某一个元素执行方法\n    deelItem:function (num,fn) {\n        //对元素执行回掉函数\n        // 第三个参数开始为回掉函数中的参数\n        // 通过this.get方法设置index 的索引值\n        fn.apply(this.get(num),splice.call(arguments,2))\n    },\n```\n排他方法处理某一个元素用deelEach和deelItem方法\n```js\n    //排他方式处理某一个元素\n    exclusive:function (num,allFn,numFn) {\n        //对所有元素执行回掉函数\n        this.deelEach(allFn);\n        //如果num是数组\n        if (Object.prototype.toString.call(num) === '[object Array]') {\n            //遍历num数组\n            for (var i = 0; i < num.length; i++) {\n                //分别处理数组中的每一个元素\n                this.deelItem(num[i],numFn)\n            }\n        }else {\n            // 处理单个元素的情况\n            this.deelItem(num,numFn)\n        }\n    },\n```\n\n#### 使用方法\n比如要操作id为container的ul元素中的4个li元素\n```js\n        var demo = new Iterator('container','li');\n        // 处理某一个\n        demo.deelItem(1,function () {\n            this.style.background = 'red';\n        })\n        //处理所有元素\n        demo.deelEach(function () {\n            this.style.color = 'green'\n        })\n        //处理排他元素3和4\n        demo.exclusive([2,3],function () {\n            this.innerHTML = '排除中'\n        },function () {\n            this.innerHTML = '选中'\n        })\n```\n\n#### 数组迭代器\n兼顾低版本浏览器，依次对数组中每一个元素遍历，并将该元素的索引与索引值传入回掉函数中。\n```js\n    //数组迭代器\n    var eachArray = function(arr,fn) {\n        var i = 0,len = arr.length;\n        //遍历数组\n        for (; i < len; i++) {\n            //一次执行回掉函数，注意回掉函数中传入的参数第一个为索引，第二个为该索引对应的值\n            if (fn.call(arr[i],i,arr[i]) === false) {\n                break;\n            }\n        }\n    }\n```\n#### 对象迭代器\n与数组迭代器类似，但传入回掉函数中的为对象的**键值对**\n```js\n    var eachObject = function (obj,fn) {\n        for(var i in obj){\n            if (fn.call(obj[i],i,obj[i]) === false) {\n                break;\n            }\n        }\n    }\n```","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"命令模式（绘图命令）","url":"%2F2018%2F11%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%BB%98%E5%9B%BE%E5%91%BD%E4%BB%A4%EF%BC%89%2F","content":"\n命令模式也可以用于**解耦**，比如使用canvas会经常调用一下内置方法，需要不停使用canvas元素的上下文引用，在多人项目开发中耦合度高，如果有人不小心改动了canvas的上下文，后果将无法估计。\n命令对象的内部，如果有人想要绘图，直接通过**命令对象书写命令**调用内部封装的方法完成即可。使用命令模式将**canvas上下文引用对象**安全封装在一个命令对象的内部。\n```js\n    //创建一个命令\n    var CanvasCommand = (function () {\n        //获取canvas\n        var canvas = document.getElementById('canvas'),\n        //canvas元素的上下文引用对象缓存在命令对象内部\n        ctx = canvas.getContext('2d');\n        //内部对象方法\n        var Action = {\n            //填充色彩\n            fillStyle:function(c){\n                ctx.fillStyle = c;\n            },\n            //填充矩阵\n            fillRect:function (x,y,width,height) {\n                ctx.fillRect(x,y,width,height);\n            },\n            //描边色彩\n            strokeStyle:function (c) {\n                ctx.strokeStyle = C;\n            },\n            //描边矩阵\n            strokeRect:function (x,y,width,height) {\n                ctx.strokeRect(x,y,width,height)\n            }\n        }\n        //返回命令\n        return {\n            excute:function (msg) {\n                //如果没有命令参数，则返回\n                if (!msg)\n                    return;\n                if (msg.length) {\n                    //遍历执行多个命令\n                    for (var i = 0; i < msg.length; i++) {\n                        // arguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，返回正被执行的 Function 对象，\n                        //也就是所指定的 Function 对象的正文，这有利于匿名函数的递归或者保证函数的封装性\n                        arguments.callee(msg[i])\n                    }\n                }else {\n                    //如果msg.param不是一个数组。将其转化为数组，apply第二个参数要求格式\n                    msg.param = Object.prototype.toString.call(msg.param) === '[object Array]'?msg.param:[msg.param];\n                    Action[msg.command].apply(Action,msg.param);\n                }\n            }\n        }\n    })()\n```\n有了这个对象，绘制图像不需要依赖canvas，只要按照命令对象就结构给出的命令格式写命令即可，比如：\n```js\n    //设置填充色彩为红色，并绘制一个矩形\n    CanvasCommand.excute([\n        {command:'fillStyle',param:'red'},\n        {command:'fillRect',param:[20,20,100,100]},\n    ]);\n```","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"命令模式（视图模板）","url":"%2F2018%2F11%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A7%86%E5%9B%BE%E6%A8%A1%E6%9D%BF%EF%BC%89%2F","content":"\n将**请求和实现解耦**并封装成**独立的对象**，从而使得不同的请求对客户端的实现参数化。   \n他将**创建模块的逻辑**封装在一个对象里，这个对象提供一个**参数化的请求接口**，请求部分比较简单，只需要按照给定的参数格式书写指令即可。\n```js\n//模板实现的模块\nvar viewCommand = (function() {\n    //方法集合\n    var Action = {\n        //创建方法\n        creat:function() {},\n        //展示方法\n        display:function() {}\n    }\n    //返回命令接口\n    return function excete() {}\n})()\n```\n比如我们要实现自由化创建视图，根据传入参数不同创建不同视图\n#### 视图创建\n创建页面单纯用dom操作很消耗内存，可以使用格式化字符串模板来创建，所以需要一个**格式化字符串模板**的方法formateString\n```js\n    //模块实现的模块\n    var viewCommand = (function () {\n        var tpl = {\n            product:[\n                '<div>',\n                    '<img src=\"{{src}}\"/>',\n                    '<p>{{text}}</p>',\n                '</div>'\n            ].join(''),\n            title:['<h2>{{title}}</h2>'].join('')\n        },\n        //用于缓存解析的字符串\n        html = '';\n        //格式化字符串 <div>{{title}}</div>里面的内容用{title:'demo'}替换为  <div>title</div>\n        //解析字符串函数\n        function foramteString(str,data,i) {\n            // str模板类型 data：命令创建的参数\n            return str.replace(/\\{\\{(\\w+)\\}\\}/g,function (match,key) {\n                //key就是{{}}里面的内容\n                // match = {{xxxx}} ，key = xxxx\n                // str = <div><img src=\"{{src}}\"/><p>{{text}}</p></div>\n                //回掉函数在找到几组后就执行几次 ，比如这里找到了 {{src}} 和 {{text}},\n                // 第一次 src 会被替换为 data[i][src]\n                // 第二次 text会被替换为 data[i][text]\n                return  data[i][key]     //返回要替换的值\n            })\n        };\n        // 方法集合\n        var Action = {\n            // 解析数据\n            // data参数是传入给模块的数据，view则制订了模块类型。比如tpl里面的product或者title\n            creat:function (data,view) {\n                // 判断传入的数据是否是数组\n                console.log(data);\n                if (data.length) {\n                    //便利数组\n                    for (var i = 0; i < data.length; i++) {\n                        //将格式化之后的字符串缓存到html中\n                        html += foramteString(tpl[view],data)\n                    }\n                }\n            },\n        }\n        //命令接口\n        return  function excute(msg) {\n            //解析命令，如果msg.param不是数组则将其转化为数组（apply方法要求第二个参数是数组）\n            msg.param = Object.prototype.toString.call(msg.param) === '[object Array]'?\n            msg.param:[msg.param];\n            //Action 内部调用的方法引用this，所以此处保证作用于this执行传入Action\n            Action[msg.command].apply(Action,msg.param)\n        }\n    })();\n```\n#### 视图展示\n```js\n            //展示方法 ： 容器，数据 ，模板类型\n            display:function (container,data,view) {\n                //如果传入数据\n                if (data) {\n                    //根据制定的view创建视图\n                    this.creat(data,view);\n                }\n                //展示模块\n                document.getElementById(container).innerHTML = html;\n                //清空缓存\n                html = '';\n            }\n```\n\n#### 命令接口\n在上面已经创建了视图模块和展示试图模块，接下来就要实现命令接口了。\n接口参数有两个部分，第一部分是命令对象内部的方法名称，第二部分是命令对象内部方法对应的参数。\n```js\n        //命令接口\n        return  function excute(msg) {\n            //解析命令，如果msg.param不是数组则将其转化为数组（apply方法要求第二个参数是数组）\n            msg.param = Object.prototype.toString.call(msg.param) === '[object Array]'?\n            msg.param:[msg.param];\n            //Action 内部调用的方法引用this，所以此处保证作用于this执行传入Action\n            Action[msg.command].apply(Action,msg.param)\n        }\n```\n#### 使用方法\n定义虚构的数据，然后调用模板命令\n```js\n\n    //数据测试\n    var productData = [\n        {\n            src: '11.png',\n            text:'1111111111'\n        },\n        {\n            src: '2.jpg',\n            text:'2222222222'\n        },\n        {\n            src: '3.png',\n            text:'33333333'\n        }\n    ]\n    viewCommand({\n        //creat\n        command:'display',\n        //param\n        param:['div',productData,'product']\n    })\n    \n    // 结果输出三组模板 img+p\n```\n完整的代码示例\n```js\n    //模块实现的模块\n    var viewCommand = (function () {\n        //模板类型\n        var tpl = {\n            //图片\n            product:[\n                '<div>',\n                    '<img src=\"{{src}}\"/>',\n                    '<p>{{text}}</p>',\n                '</div>'\n            ].join(''),\n            //标题\n            title:['<h2>{{title}}</h2>'].join('')\n        },\n        //用于缓存解析的字符串\n        html = '';\n        //解析字符串函数\n        function foramteString(str,data,i) {\n            // str模板类型 data：命令创建的参数\n            return str.replace(/\\{\\{(\\w+)\\}\\}/g,function (match,key) {\n                //  /g表示替换所有匹配的子串，如果没有，只替换第一个\n                //key就是{{}}里面的内容\n                // match = {{xxxx}} ，key = xxxx\n                // str = <div><img src=\"{{src}}\"/><p>{{text}}</p></div>\n                //回掉函数在找到几组后就执行几次 ，比如这里找到了 {{src}} 和 {{text}},\n                // 第一次 src 会被替换为 data[i][src]\n                // 第二次 text会被替换为 data[i][text]\n                return  data[i][key]     //返回要替换的值\n            })\n        };\n        // 方法集合\n        var Action = {\n            // 解析数据\n            // data参数是传入给模块的数据，view则制订了模块类型。比如tpl里面的product或者title\n            creat:function (data,view) {\n                // 判断传入的数据是否是数组\n                if (data.length) {\n                    //便利数组\n                    for (var i = 0; i < data.length; i++) {\n\n                        //将格式化之后的字符串缓存到html中\n                        html += foramteString(tpl[view],data,i)\n                    }\n                }\n            },\n            //展示方法 ： 容器，数据 ，模板类型\n            display:function (container,data,view) {\n                //如果传入数据   'div',productData,'product'\n                if (data) {\n                    //根据制定的view创建视图\n                    this.creat(data,view);\n                }\n                //展示模块\n                document.getElementById(container).innerHTML = html;\n                //清空缓存\n                html = '';\n            }\n        }\n        //命令接口\n        return  function excute(msg) {\n            //解析命令，如果msg.param不是数组则将其转化为数组（apply方法要求第二个参数是数组）\n            msg.param = Object.prototype.toString.call(msg.param) === '[object Array]'?\n            msg.param:[msg.param];\n            //Action 内部调用的方法引用this，所以此处保证作用于this执行传入Action\n            Action[msg.command].apply(Action,msg.param)\n        }\n    })();\n\n\n\n        //数据测试\n        var productData = [\n            {\n                src: '11.png',\n                text:'1111111111'\n            },\n            {\n                src: '2.jpg',\n                text:'2222222222'\n            },\n            {\n                src: '3.png',\n                text:'33333333'\n            }\n        ]\n\n        viewCommand({\n            //creat\n            command:'display',\n            //param\n            param:['div',productData,'product']   //display(container,data,view)\n        })\n```","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"策略模式","url":"%2F2018%2F11%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F","content":"\n和**状态模式类似**，能灵活管理分支结构，区别在于，策略模式内部不需要管理状态，各个状态间**没有依赖关系**。\n最常用的就是封装一系列的不会相互影响的功能，比如算法，在有需要的时候调用即可。\n```js\n    // 策略模式封装一个价格算法\n    var PriceStragtegy = function () {\n        var stragtegy = {\n            // 100返30\n            return30:function (preice) {\n                return +price+parseInt(pricec/100) *30;\n            },\n            //100返50\n            return50:function (preice) {\n                return +price+parseInt(pricec/100) *50;\n            },\n            // 9折\n            parcent90:function () {\n                // js在处理小树乘除法有bug，故运算前转化为整数\n                return price*100*90/10000;\n            }\n        }\n        return function (type,price) {\n            // 算法存在则调用，不存在返回\n            return stragtegy[type] && stragtegy[type]();\n        }\n    }\n    \n    //调用\n    var price = PriceStragtegy('return50','500');\n    console.log(price);  //750\n```\n> 策略模式封装一组代码，之间相互**独立**\n优化**分支判断**","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"状态模式","url":"%2F2018%2F10%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F","content":"\n当一个对象的内部状态发生改变时，会导致其行为的改变。状态模式用于解决分支判断语句的臃肿。\n将不同的判断结果封装在状态对象内，然后改状态对象返回一个可以被调用的接口方法。\n```js\n    //结果状态对象\n    var ResultState = (\n        function(){\n            //判断结构保存在内部状态中\n            var States = {\n                //每种状态作为一种独立方法保存\n                state0:function () {\n                    //处理结果为0\n                    console.log('这是第一种情况');\n                },\n                state1:function () {\n                    //处理结果为2\n                    console.log('这是第二种情况');\n                },\n                state2:function () {\n                    //处理结果为3\n                    console.log('这是第三种情况');\n                }\n            }\n            //获取某一种状态并且执行对应的方法\n            function show(result) {\n                States['state'+result] && States['state'+result]();\n            }\n            return {\n                //返回嗲用状态方法接口\n                show:show\n            }\n        }\n    )();\n    ResultState.show(1);   //这是第二种情况\n```\n#### 实现简易超级玛丽\n游戏中，角色会有很多不同的动作，如果这些都用分支判断语句去处理会显得很混乱，可以尝试使用状态模式。\n```js\n    var SupperMarry  = function () {\n        //内部私有变量\n        var _currentState = {};\n        //动作与状态的映射\n        var States = {\n            jump:function () {\n                console.log('Marry'+'jump');\n            },\n            move:function () {\n                console.log('Marry'+'move');\n            },\n            run:function () {\n                console.log('Marry'+'run');\n            }\n        };\n        //动作控制类\n        var Action = {\n            //改变状态方法\n            changeStates:function () {\n                //组合动作通过传递多个参数实现\n                var args = arguments;\n                //重置内部状态\n                _currentState = {};\n                //如果有动作就添加动作\n                if (args.length) {\n                    //遍历动作\n                    for(var i =0;i<args.length;i++){\n                        //向内部状态中添加动作\n                        _currentState[args[i]] = true;\n                    }\n                }\n                //返回控制类\n                return this;\n            },\n            //执行动作\n            goes:function () {\n                console.log('触发一次动作');\n                //遍历内部状态保存的动作\n                for (var i in _currentState) {\n                    //如果动作存在就执行\n                    States[i] && States[i]();\n                }\n                return this;\n            }\n        };\nhexokinase\n        return {\n            change: Action.changeStates,\n            goes:Action.goes\n        }\n    }\n    SupperMarry().change('jump','run')\n    .goes()\n//触发一次动作 \n// Marryjump\n// Marryrun\n```\n\n状态模式既是解决程序中臃肿的**分支判断语句问题**，将每个分支转化为一种状态独立出来，方便每种状态的管理又不至于每次执行时遍历所有的分支。\n\n","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"观察者模式","url":"%2F2018%2F10%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F","content":"\n观察者模式又被称为发布-订阅者模式或者消息机制。主要作用是定义了一种依赖关系，解决了主体对象与观察者之间的耦合。\n我们需要一个观察者对象，里面至少要包含一个消息容器和三个方法：订阅消息，取消订阅，发送订阅。\n\n```js\n    //将观察者放入闭包中，页面加载立即执行\n    var Observer = (function () {\n        // 消息容器，所有订阅的消息会放在这里\n        var _message = {}\n        return {\n            //添加订阅\n            regist:function () {},\n            // 删除订阅\n            remove:function () {},\n            // 发布订阅\n            fire:function () {}\n        }\n    })();\n```\n#### 添加订阅\n添加订阅就是将订阅者需要**订阅的消息推入到订阅队列里面**。\n\n就像在论坛关注了某个用户，当用户有最新的动态时，会自动通知关注者，而不会通知没有关注的人。\n因此我们需要接受两个参数：**订阅的类型**以及相对应的**处理动作**。\n\n如果添加的订阅**不存在**，则**创建该订阅**并且推入订阅列表，如果存在则应该将订阅执行动作推入订阅队列中，保证多个模块添加同一订阅能顺利执行。\n```js\n    //添加订阅\n    regist:function (type,fn) {\n        //如果订阅不存在就创建一个新的订阅\n        if (typeof _message [type] === 'undefined') {\n            //添加订阅\n            _message[type] = [fn]\n        }else {\n            //增加订阅\n            _message[type].push(fn);\n        }\n    }\n```\n\n#### 删除订阅\n和添加订阅相反，注销不需要的订阅。同样需要两个参数：**订阅类型**和**订阅执行方法**。\n防止误删，要校验订阅列表中**是否存在订阅**。\n```js\n    // 删除订阅\n    remove:function (type,fn) {\n        //如果订阅执行方法列队存在\n        if (_message[type] instanceof Array) {\n            //遍历所有订阅执行方法，找到要取消的动作后删除\n            var i = _message[typr].length -1;\n            for (; i >=0; i--) {\n                //如果存在该动作则移除\n                _message[type][i] === fn && _message[type].splice(i,1);\n            }\n        }\n    }\n```\n\n#### 发布订阅\n观察者发布一个订阅时，所有关注了该订阅的用户都会收到推送，即是将所有订阅者的订阅一次执行。\n接收两个参数，**订阅类型**以及动作执行时需要**传递的参数**。\n在执行订阅动作队列之前校验订阅的存在很有必要。然后便利订阅执行方法队列并且依次执行，然后将订阅类别以及传递的参数打包后一次传入订阅执行方法中。\n```js\n    // 发布订阅\n    fire:function (type,args) {\n        //如果不存在该订阅，则返回\n        if (!_message[type])\n            return ;\n        //定义订阅信息\n        var events = {\n            type:type,                 //订阅类型\n            args:args || {}            // 订阅执行动作的参数\n        },\n        i = 0;\n        len = _message[type].length;   //订阅执行动作的长度\n        //遍历订阅动作\n        for (; i < len; i++)\n            //依次执行订阅对应的动作\n            _message[type][i].call(this,events);\n        }\n```\n\n#### 使用\n```js\n    Observer.regist('test',function (e) {\n        console.log(e.type,e.args.mes);\n    })\n    Observer.fire('test',{mes:'订阅发布了'})   //test 订阅发布了\n```\n\n> 观察者模式主要用于解决类或对象之间的耦合，**解耦**两个互相依赖的对象，使其依赖于观察者的订阅机制","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"外观模式","url":"%2F2018%2F10%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F","content":"\n外观模式就是为一组复杂的子系统接口提供一个更高级的**统一接口**，通过这个接口可以使子系统接口更加容易访问\n比如我们在使用点击事件时，有多种方法，可以直接通过document绑定，可以通过监听事件进行绑定，然而并不是每个方法都实用，因为要考虑到**浏览器的兼容性问题**。\n我们可以使用外观模式对点击事件进行优化：\n```js\n    //外观模式 dom元素，type类型，fn回掉\n    function addEvent(dom,type,fn){\n        //处理支持 addEventListener 方法的浏览器\n        if (dom.addEventListener) {\n            dom.addEventListener(type,fn,false);\n            //对于不支持 addEventListener但是支持 attachEvent 方法的浏览器\n        }else if(dom.attachEvent){\n            dom.attachEvent('on',type,fn);\n            //对于不支持 addEventListener和attachEvent 方法的浏览器\n        }else {\n            dom['on'+type] = fn;\n        }\n    }\n    var div = document.createElement('div');\n    addEvent(div,'onclik',function () {\n        console.log('绑定了点击事件');\n    })\n```\n除了上面提到的点击事件，还有其他的底层接口\n```js\n    //获取事件对象\n    function getEvent(event) {\n        // 标准浏览器返回event，ie下返回window.event\n        return event || window.event;\n    }\n    //获取元素\n    function getTarget(event) {\n        var ev = getEvent();\n        // 标准浏览器下event.target ,ie下event.srcElement\n        return event.target || event.srcElement;\n    }\n    //阻止默认行为\n    function preventDafault(event) {\n        var ev = getEvent();\n        // 标准浏览器\n        if(ev.preventDefault){\n            ev.preventDefault();\n            //ie浏览器\n        }else {\n            ev.returnValue = fasle;\n        }\n    }\n```\n外观模式解决了浏览器的兼容问题，这只是外观模式应用的一部分。很多代码库通过外观模式来封装多个功能，简化底层操作。","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"原型模式","url":"%2F2018%2F10%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F","content":"\n原型模式使用**原型对象指向创建对象的类**，用于创建新的对象的类共享原型对象的属性以及方法。\n\n要点是将**可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中**。然后子类通过组合继承或者寄生组合继承而将方法和属性继承下来。\n对于子类中那些需要重写的方法进行重写，这样**子类创建的对象**既有**子类的属性和方法**也共享了**基类的原型方法**。\n来看一段代码：\n```js\n// 例如创建一个 Person 的构造函数, 让人有名字, 可以说话\nfunction Person ( name ) {\n  this.name = name;\n  // 可以说话, 需要有一个方法\n  this.sayHello = function () {\n      console.log( '你好, 我是 ' + this.name );\n  };\n}\nvar p1 = new Person( '小明' );\nvar p2 = new Person( '大伟' );\nconsole.log( p1.sayHello == p2.sayHello );  // false \n```\np1和p2都继承了sayHello方法，但是他们不相同，说明占用了不同的内存，造成资源的浪费。\n解决方法：使用prototype（原型）属性，将共享的方法绑定到 .prototype 原型上 即可\n```js\nfunction Person ( name ) {\n  this.name = name;\n}\n//公用的方法\nPerson.prototype.sayHello = function() {\n  console.log( '你好, 我是 ' + this.name );\n}\n\nvar p1 = new Person( '小明' );\nvar p2 = new Person( '大伟' );\nconsole.log( p1.sayHello == p2.sayHello );  // true\n```\np1和p2的sayHello方法指向都是相同的。\n\n#### 原型继承\n我们先创建一个原型对象的复制方法\n```js\n    //创建一个函数，用于原型继承\n    function prototypeExtend() {\n        var F = function(){},\n         args = arguments,  //缓存数组\n         argsLenght = args.length,\n         i = 0;\n        for ( i ; i < argsLenghth; i++) {\n            //遍历每个模板对象中的属性\n            for (var key in args[i]) {\n                F.prototype[key] = args[key]\n            }\n        }\n        //返回一个实例\n        return new F();\n    }\n```\n如果我们需要创建一个企鹅类，他拥有跳、跑等方法，就可以这么写：\n```js\n    var penguin = prototypeExtend(\n        \n        //其实这里的所有对象都会被存储到 F.prototype 里面，然后通过new F()返回达到继承的目的\n        {speed:20},\n        {jump:function () {\n            console.log('jump' + this.speed);\n        }},\n        {run:function () {\n            console.log('run' + this.speed);\n        }}\n    )\n    penguin.jump()  //jump20\n```","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"工厂模式","url":"%2F2018%2F10%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F","content":"\n与创建型模式类似，**工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类**。\n\n工厂模式定义一个用于创建对象的接口，这个接口由子类决定**实例化哪一个类**。\n```js\nvar productManager = {};\n//不同的类型\nproductManager.createProductA = function () {\n    console.log('ProductA');\n}\nproductManager.createProductB = function () {\n    console.log('ProductB');\n}\n//工厂模式\nproductManager.factory = function (typeType) {\n    //根据用户选择的typeType去对应生成相应的类\n    return new productManager[typeType];\n}\nproductManager.factory(\"createProductA\");\n```\n\n#### 安全的工厂模式\n在创建类时，如果没有使用new将会造成无可估量的后果，所以在使用工厂模式的同时可以结合安全模式。\n\n判断当前对象的this是不是**通过new关键字**创建的，如果不是则返回新创建的对象\n\n```js\n//安全模式下的工厂模式\nvar Factory = function(type,content) {\n  if(this instanceof Factory){\n      return new Factory[type](content);\n  }else{\n      return new Factory(type,content);\n  }\n}\n//设置所有对象类型的基类\nFactory.prototype = {\n    Java:function(content) {\n      // do something\n    },\n    javascript:function(content) {\n      // do something\n    },\n    Ui:function(content) {\n      this.content = content;\n      (function(content) {\n          var div = document.createElement('div');\n          div.innerHTML = content;\n          div.style.border = '1px solid red';\n          document.body.appendChild(div);\n      })(content)\n    },\n    ...\n}\n\n//创建\nvar js = new Factory('javascript','js是世界上第二好的语言')\n```\n#### 抽象工厂模式\n抽象类是一种不能使用的类，当你使用就会报错。当用户想创建抽象类时，我们应该做出相应措施。\n```js\nvar Car = function() {}\nCar.prototype={\n    getPrice:function() {\n      return new Error('抽象类方法不能调用')\n    }\n}\n```\n这种写法在继承上很有作用，因为定义了一种类和该类必备的方法，如果子类没有重写这些方法，那么当调用时能找到这些方法便会报错。\n```js\n//subType子类   superType父类\nvar VehicleFactory = function(subType,superType) {\n  //判断抽象工厂中是否含有该抽象类\n  if (typeof VehicleFactory[superType] === 'function'){\n      //缓存类\n      function F() {}\n      //继承父类属性和方法\n      F.prototype = new VehicleFactory[superType]();\n      //将子类的constructor指向子类\n      subType.constructor = subType;\n      //子类原型继承“父类”\n      subType.prototype = new F();\n      \n      //上面的操作其实就是链式继承 subType.prototype 等于 F.prototype 等于 VehicleFactory.Car.prototype\n      // 所有new subType创建的对象如果没有重写 VehicleFactory.Car.prototype里面的方法，就会沿着原型链去调用方法\n  } \n}\n\n//小汽车抽象类\nVehicleFactory.Car = function() {\n  this.type = 'car';\n}\nVehicleFactory.Car.prototype = {\n    getPrice:function() {\n      return new Error('抽象方法不能调用');\n    }\n}\n\n//公交车抽象类\nVehicleFactory.Bus = function() {\n  this.type = 'Bus';\n}\nVehicleFactory.Bus.prototype = {\n    getPrice:function() {\n      return new Error('抽象方法不能调用');\n    }\n}\n\n\n\n//使用方法（让子类集成父类）\n//宝马车系\nvar BMW = function(price) {\n  this.price = price;\n}\n//抽象工厂实现对Car抽象类的继承\nVehicleFactory(BMW,'Car');\nBMW.prototype.getPrice = function() {\n  return this.price;\n}\n\n\n\n                                 \n```\n抽象工厂本质是实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类（抽象类） 的名称，并且在抽象工厂方法中增加了一次对抽象类存在性的判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。\n继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，我们不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍俩复制构造函数中的属性和方法。\n##### 如果子类没有重写抽象类\n```js\nvar myBMW = new BMW(100)\nconsole.log(myBMW.getPrice());  //Error: 抽象方法不能调用\n//如果子类重写了getPrice才不会报错\n```\n##### 重写了抽象类\n```js\n\nBMW.prototype.getPrice = function() {\n  return this.price;\n}\n\nvar myBMW = new BMW(100)\nconsole.log(myBMW.getPrice());  //100  \n```\n#### 什么时候使用工厂模式\n+ 对象的构建十分复杂\n+ 需要依赖具体环境创建不同实例\n+ 处理大量具有相同属性的小对象\n\n####  什么时候不该用工厂模式\n\n不滥用运用工厂模式，有时候仅仅只是给代码增加了不必要的复杂度，同时使得测试难以运行下去。","tags":["JS设计模式"],"categories":["JS设计模式"]},{"title":"TWEEN补间动画","url":"%2F2018%2F10%2F01%2F3JS--TWEEN%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB%2F","content":"\n#### 使用方法\n\n首先要用一个对象将需要进行补间动画的值包含进来\n\n```js\nvar changeSrc = {positionZ:1180}\n```\n\n然后在tween中注册使用该对象并且设置相关参数 \n\n```js\nvar tween = new TWEEN.Tween(posSrc)     //注册\n.to({pos:640},3000)\t\t\t\t\t\t//补间结束值 3000是持续时间\n.easing(TWEEN.Easing.Sinusoidal.InOut)  //选择补间动画\n.onUpdate(function () {                 //更新动画\n    console.log(this.pos);              //这就是tween帮助我们进行补间动画的值\n    //动态改变camera.position.x的值\n    camera.position.z = this.pos;        //相机的z轴距离等于补间动画的值\n});;\n```\n\n在模型加载完之后激活动画\n\n```js\n//激活动画\ntween.start();\n```\n\nTween.js本身不会运行，你需要通过`update`方法明确的告诉它什么时候开始运行。推荐在动画主循环中使用该方法。你可以通过调用`requestAnimationFrame`方法来获得良好的图像性能。\n\n```js\nfunction run() {\n    TWEEN.update();   //启动补间动画\n    renderer.render(scene, camera);\n    requestAnimationFrame(run);\n}\n```\n\n#### 无限循环动画\n\n+ 通过chain来关联，头部结合无限循环\n\n```js\ntweenA.chain(tweenB);\ntweenB.chain(tweenA);\n```\n\n+ 使用repeat函数\n\n```js\ntween.repeat(10);        // repeats 10 times and stops\ntween.repeat(Infinity);  // repeats forever  不会回放\ntween.repeat(Infinity).yoyo(true)；    //增加回放，就像start和back使用chain串联起来\n```\n\n#### 事件触发补间动画\n\n例子中使用点击事件触发相机视角移动\n\n```js\ndocument.addEventListener( 'mousedown', onDocumentMouseDown, false );\nfunction onDocumentMouseDown( event ) {\n    event.preventDefault();\n    new TWEEN.Tween( camera.position ).to( {  y:30}, 1000 ).easing(TWEEN.Easing.Sinusoidal.InOut).start();\n}\n\n//必须\nfunction run() {\n    TWEEN.update();   //启动补间动画\n    renderer.render(scene, camera);\n    requestAnimationFrame(run);\n}\nrun（）;\n```","tags":["THREE"],"categories":["THREE.js"]},{"title":"dat.gui使用","url":"%2F2018%2F09%2F30%2F3JS--dat.gui%20%E4%BD%BF%E7%94%A8%2F","content":"\n\ndat.GUI 是一个轻量级的**图形用户界面库（GUI 组件）**，使用这个库可以很容易地创建出能够改变代码变量的界面组件。\n### 基本使用方法\n\n#### 引用路径\n\n```html\n<script src=\"https://cdn.bootcss.com/dat-gui/0.7.2/dat.gui.min.js\"></script>\n```\n\n#### 创建对象\n\n该对象用于存储需要动态改变的值。\n\n```JS\n//创建一个对象存储需要动态改变的值\nvar controls = {\n    cameraPositionX:30,\n    cameraPositionY:30\n}\n//初始化和注册插件\nvar gui = new dat.GUI();           //初始化插件\ngui.add(controls, 'cpx', 0, 30);  //添加值 gui.add(controls, 'cameraPositionX', 0, 30);   \n```\n\n#### 动态更新\n\n+ 放在渲染函数中\n\n    当你改变值的时候，renderer重新渲染\n\n```js\n//渲染函数\nfunction run() {\n    //使用dat.gui里面可以动态改变的值,，比如上面创建的controls.cameraPositionX\n    camera.position.x = controls.cameraPositionX;\n    cube.rotation.x +=0.02;\n    cube.rotation.y +=0.02;\n    cube.rotation.z +=0.02;\n    //重复调用\n    renderer.render(scene,camera);\n    requestAnimationFrame(run);\n}\nrun();\n```\n\n+ **监听值（推荐）**\n\n  ```js\n  gui.add(controls, 'cameraPositionZ', 0, 80).onChange(function (e) {\n      camera.position.z = e\n  });\n  ```\n\n\n### 各种类型的控件\n\ndat.gui会根据对象值自动识别和转化控件类型。\n\n##### 数字类型（Number）\n\n+ 没有设置任何条件，则是一个输入框\n\n  ```js\n  gui.add(controls, 'cpx');\n  ```\n\n+ 可以设置大小范围（变成slide滑动组件），或者单独设置最大最小（还是input输入框）\n\n  ```js\n  gui.add(controls, 'cpx', 0, 30);    //0--30\n  gui.add(controls, 'cpx', nim(0));   //最小0\n  gui.add(controls, 'cpx', min(30));  //最大30\n  ```\n\n+ 可以配置step限制步长\n\n   ```js\n    gui.add(controls, 'cpx', 0, 30).step(0.5);  //限制一步增加0.5\n   ```\n\n+ 可以固定只为几个值（变成下拉框）\n\n  ```js\n  gui.add(controls, 'cpx', {Stopped: 0, Slow: 0.02, Fast: 5});  \n  ```\n\n##### 字符串（String）\n\n+ 默认情况一个输入框\n+ 可以固定为几个值\n\n#### 布尔类型（Boolean）\n\n会自动变为复选框的形式\n\n```js\nvar controls = {\n    isHide:true\n}\nvar gui = new dat.GUI();\ngui.add(controls, 'isHide');\n```\n\n##### 函数（Function）\n\n会自动变成按钮触发\n\n```js\nvar controls = {\n    hello:function(){alert('hello')}\n}\nvar gui = new dat.GUI();\ngui.add(controls, 'hello');\n```\n\n##### 颜色值\n\n一共有四种类型css、rgb、rgba、hue，使用 addColor 方法添加控件。\n\n```js\nvar controls = {\n    color0 = \"#ffae23\"; // CSS string\n    color1 = [0, 128, 255]; // RGB array\n    color2 = [0, 128, 255, 0.3]; // RGB with alpha\n    color3 = {h: 350, s: 0.9, v: 0.3}; // Hue, saturation, value\n};\n \nvar gui = new dat.GUI();\ngui.addColor(controls, 'color0');\ngui.addColor(controls, 'color1');\ngui.addColor(controls, 'color2');\ngui.addColor(controls, 'color3');\n```\n\n### 事件监听\n\n对于面板中的每一个控制项，我们都可以设置` onChange` 和 `onFinishChange `监听事件。\n\n```js\nvar controls =  {\n    speed = 1;\n};\nvar gui = new dat.GUI();\nvar speedController = gui.add(controls, 'speed', 0, 5);\n//对应控制项值改变时响应（比如拖动滑块过程中）\nspeedController.onChange(function(value) {\n  console.log(\"onChange:\" + value);\n});\n//对应控制项值修改完毕响应\nspeedController.onFinishChange(function(value) {\n  console.log(\"onFinishChange\" + value);\n});\n```\n\n","tags":["THREE"],"categories":["THREE.js"]},{"title":"常用操作","url":"%2F2018%2F09%2F03%2F3JS--%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F","content":"\n#### 查找场景中的元素\n\n```javascript\nif (child instanceof THREE.PointCloud) {\n\t//do something\n}\n```\n\n#### 相机随着鼠标移动\n\n```js\nwindow.onmousemove = function (event) {\n    event = event || window.event;\n    //获取鼠标的位置\n    var mouseX = event.pageX/80;\n    var mouseY = event.pageY/80;\n    camera.position.set(mouseX,mouseY,camera.position.z);\n}\n```\n\n#### 画布自适应大小\n\n```js\nfunction onWindowResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n}\n```\n\n#### 相机围绕某个轴旋转\n\n```js\nvar radius = 600;\nvar theta = 0;\nfunction render() {\n   // rotate camera\n     theta += 0.1;\n    //相机围绕x轴旋转\n   // camera.position.x = radius * Math.sin( THREE.Math.degToRad( theta ) );\n     camera.position.y = radius * Math.sin( THREE.Math.degToRad( theta ) );\n     camera.position.z = radius * Math.cos( THREE.Math.degToRad( theta ) );\n     camera.lookAt( scene.position );\n     camera.updateMatrixWorld();\n     renderer.render( scene, camera );\n }\n```\n\n#### 判断鼠标选中了某个物体\n\n```js\nvar raycaster = new THREE.Raycaster();\nvar mouse = new THREE.Vector2();\n\nfunction onMouseMove( event ) {\n\n\t// calculate mouse position in normalized device coordinates\n\t// (-1 to +1) for both components\n\n\tmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\tmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n\n}\n\nfunction render() {\n\t// update the picking ray with the camera and mouse position\n\traycaster.setFromCamera( mouse, camera );\n\n\t// calculate objects intersecting the picking ray\n\tvar intersects = raycaster.intersectObjects( scene.children );\n\tfor ( var i = 0; i < intersects.length; i++ ) {\n\t\tintersects[ i ].object.material.color.set( 0xff0000 );\n\t}\n\trenderer.render( scene, camera );\n}\n\nwindow.addEventListener( 'mousemove', onMouseMove, false );\nwindow.requestAnimationFrame(render);\n```\n\n#### 使用纹理贴图\n\n```js\n//传入形状和材质\nfunction creatMesh(gemo,imageFile) {\n    var texture = THREE.ImageUtils.loadTexture(\"scene1/\"+imageFile);\n    var mat = new THREE.MeshPhongMaterial({map:texture,transparent :true});\n    return new THREE.Mesh(gemo,mat);\n}\n\nvar caodi = creatMesh(new THREE.PlaneGeometry(2400, 1184, 20, 20),'caodi.png');\ncaodi.position.set(15,-20,0);\n\nvar fangzi = creatMesh(new THREE.PlaneGeometry(811, 526, 20, 20),'fangzi.png');\nfangzi.position.set(-110,150,0);\n\n// add the plane to the scene\nscene.add(caodi,fangzi);\n```\n\n#### 判断是否支持3d\n\n```js\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mr.doob / http://mrdoob.com/\n */\nvar Detector = {\n\tcanvas: !! window.CanvasRenderingContext2D,\n\twebgl: ( function () {\n\t\ttry {\n\t\t\tvar canvas = document.createElement( 'canvas' ); return !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );\n \n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t} )(),\n\tworkers: !! window.Worker,\n\tfileapi: window.File && window.FileReader && window.FileList && window.Blob,\n\tgetWebGLErrorMessage: function () {\n\t\tvar element = document.createElement( 'div' );\n\t\telement.id = 'webgl-error-message';\n\t\telement.style.fontFamily = 'monospace';\n\t\telement.style.fontSize = '13px';\n\t\telement.style.fontWeight = 'normal';\n\t\telement.style.textAlign = 'center';\n\t\telement.style.background = '#fff';\n\t\telement.style.color = '#000';\n\t\telement.style.padding = '1.5em';\n\t\telement.style.width = '400px';\n\t\telement.style.margin = '5em auto 0';\n\t\tif ( ! this.webgl ) {\n\t\t\telement.innerHTML = window.WebGLRenderingContext ? [\n\t\t\t\t'Your graphics card does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">WebGL</a>.<br />',\n\t\t\t\t'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000\">here</a>.'\n\t\t\t].join( '\\n' ) : [\n\t\t\t\t'Your browser does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">WebGL</a>.<br/>',\n\t\t\t\t'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000\">here</a>.'\n\t\t\t].join( '\\n' );\n\t\t}\n\t\treturn element;\n\t},\n \n\taddGetWebGLMessage: function ( parameters ) {\n\t\tvar parent, id, element;\n\t\tparameters = parameters || {};\n\t\tparent = parameters.parent !== undefined ? parameters.parent : document.body;\n\t\tid = parameters.id !== undefined ? parameters.id : 'oldie';\n\t\telement = Detector.getWebGLErrorMessage();\n\t\telement.id = id;\n\t\tparent.appendChild( element );\n\t}\n};\n \n// browserify support\nif ( typeof module === 'object' ) {\n\tmodule.exports = Detector;\n}\n\n```\n\n#### 轨道控制器\n\n```js\n//创建相机控制\n //添加轨道控制器\n //新建一个轨道控制器\n orbitControls = new THREE.OrbitControls(camera);\n // orbitControls.target = new THREE.Vector3(0, 0, 0);//控制焦点\n orbitControls.autoRotate = false;//将自动旋转关闭\n clock = new THREE.Clock();//\n\n\n function render() {\n     delta = clock.getDelta();//获取时间差\n     orbitControls.update(delta);//更新时间\n\n     // render using requestAnimationFrame\n     requestAnimationFrame(render);\n     renderer.render(scene,camera);\n\n }\n render()\n```\n\n","tags":["THREE"],"categories":["THREE.js"]},{"title":"高级材质","url":"%2F2018%2F09%2F03%2F3JS--%E9%AB%98%E7%BA%A7%E6%9D%90%E8%B4%A8%2F","content":"\n### THREE.MeshLambertMaterial（朗伯材质）\n\n该材质用于创建暗淡并不光亮的表面，会有光源反应。除了材质的基础属性之外还有独有的属性：\n\n| 名称               | 描述                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| ambient（环境色）  | 材质的环境色，跟环境光一起作用，颜色相乘，默认白色           |\n| emissive（发射的） | 该材质发射的颜色                                             |\n| wrapAround         | true：启动lanbert光照技术。有了它，光下降得更微妙。如果网格有粗糙黑暗的地区，该属性可以将阴影变得柔和并且分布更加均匀 |\n| wrapRGB            | true:可以使用THREE.Vector3来控制光下降的速度                 |\n\n### THREE.MeshPhongMaterial\n\n和lambert材质类型，但是这种材质用于创建光亮的表面。额外的属性如下：\n\n| 名称               | 描述                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| ambient（环境色）  | 材质的环境色，跟环境光一起作用，颜色相乘，默认白色           |\n| emissive（发射的） | 该材质发射的颜色                                             |\n| specullar          | 材质的光亮程度和高光部分的颜色。如果将他设置成和color一样的颜色，将会得到类似金属的材质，如果设置成灰色（gray），材质看起来会更像塑料 |\n| shininess          | 指定高光部分的亮度，默认值30                                 |\n| wrapAround         | wrapAround                                                   |\n| wrapRGB            | true:可以使用THREE.Vector3来控制光下降的速度                 |\n\n### THREE.ShaderMeterial （着色器材质）\n\n常用属性大部分跟其他基础材质类似，有 wireframe、wireframeLinewidth、flatShading、fog、vertexColors 等。\n\n特别提一下vertexColors 属性，我们可以通过它为每一个顶点定义不同的颜色。它在 CanvasRenderer 下不起作用，只在 WebGLRenderer 下起作用。关于此属性可以参考后面提到的关于 LineBasicMaterial 的例子。\n\nShaderMaterial 还有几个特别的属性，使用它们你可以传入数据，定制你的着色器。但它们看起来不好理解，需要结合“GLSL 着色器语言”的相关知识，如下表所示：\n\n| 属性                          | 描述                                                         |\n| ----------------------------- | ------------------------------------------------------------ |\n| fragmentShader （像素着色器） | 这个着色器定义的是每个传入的像素的颜色                       |\n| vertexShader （顶点着色器）   | 这个着色器允许你修改每一个传入的顶点的位置                   |\n| uniforms （统一值）           | 通过这个属性可以向你的着色器发信息。同样的信息会发到每一个顶点和片段 |\n| defines                       | 这个属性的值可以转成 vertexShader 和 fragmentShader 里的 #define 代码。该属性可以用来设置着色器程序里的一些全局变量 |\n| attributes                    | 这个属性可以修改每个顶点和片段。通常用来传递位置数据与法向量相关的数据。如果要用这个属性，那么你要为几何体中的所有顶点提供信息 |\n| lights                        | 这个属性定义光照数据是否传递给着色器。默认值是 false         |\n\n 其中，最重要的部分就是：如果想要使用 ShaderMaterial 材质，就必须传入两个不同的着色器：\n\n- vertexShader：它会在几何体的每一个顶点上执行。可以用这个着色器通过改变顶点的位置来对几何体进行变换；\n- fragmentShader：它会在几何体的每一个像素上执行。在 vertexShader 里，我们会返回这个特定像素应该显示的颜色；","tags":["THREE"],"categories":["THREE.js"]},{"title":"粒子系统","url":"%2F2018%2F09%2F03%2F3JS--%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%2F","content":"使用粒子系统可以创建数量多的物体，例如烟花、火焰、雨滴、雪花、云朵等等。Threejs提供了Points和Sprite两种创建方式。\n\n#### Points粒子系统\n\npoints必须要通过**WebGLRenderer**渲染方式来创建。创建步骤：\n\n1. 创建一个几何对象Geometry（也可以是外部导入的模型）。\n   基于几何体自身的顶点集合geometry.vertices创建粒子（即将网格转化为粒子），每个顶点将代表粒子系统中的每个粒子。\n\n   ```js\n   var starsGeometry = new THREE.Geometry();\n   ```\n\n2. 创建粒子材质。\n   Points对应PointsMaterial，来实现每个粒子的图案，可以是纹理。\n\n   ```js\n   var starsGeometry = new THREE.Geometry();\n   \n   for ( var i = 0; i < 10000; i ++ ) {\n   \n   \tvar star = new THREE.Vector3();\n   \tstar.x = THREE.Math.randFloatSpread( 2000 );\n   \tstar.y = THREE.Math.randFloatSpread( 2000 );\n   \tstar.z = THREE.Math.randFloatSpread( 2000 );\n   \n   \tstarsGeometry.vertices.push( star );\n   \n   }\n   \n   var starsMaterial = new THREE.PointsMaterial( {\n       map: new THREE.TextureLoader().load( \"flower.png\" ),\n       transparent:true,\n       color:0x888888\n   } );\n   \n   ```\n\n3. 创建粒子\n\n   ```js\n   var starField = new THREE.Points( starsGeometry, starsMaterial );\n   scene.add( starField );\n   ```\n\n#### Sprite粒子系统\n\n精灵平面（Sprite）是一个在3D场景中总是面对着相机的平面，可以使用它创建**基于屏幕坐标**移动、定位和缩放的对象，而不影响三维场景中的其他物体（做到互不影响必须**单独创建**一个用于sprite对象的camera和render）。它没有投射阴影。创建步骤：\n\n1. 创建粒子材质,如果渲染器是canvasRender则可以直接引用canvas画布，另外也可以加载图片纹理和canvas纹理。\n\n   ```js\n   var spriteMaterial = new THREE.SpriteMaterial( { ... } );\n   // color - sprite的颜色。\n   // map - 纹理贴图\n   // rotation - sprite的旋转\n   // fog - 是否使用场景雾。\n   ```\n\n2. 创建\n\n   ```js\n   var map = new THREE.TextureLoader().load( \"sprite.png\" );\n   var material = new THREE.SpriteMaterial( { map: map, color: 0xffffff, fog: true } );\n   var sprite = new THREE.Sprite( material );\n   scene.add( sprite );\n   ```\n\n3. 另外还可以为粒子设置position（如果将每个粒子设置为一个几何体的每个顶点，则效果和point粒子系统相似）。\n\n   ```js\n   sprite.position.x = 0;\n   sprite.position.y = 0;\n   sprite.position.z = 0;\n   ```\n\n4. 为了方便控制，还可以将粒子加进同一个组内，变成一个粒子系统。\n\n\t```js\nfor ( var i = 0; i < len; i++ ) { //len表示粒子数目\n    ...\n    group.add( sprite );\n}\n\t```\n\n#### 粒子材质\n\n先说说每个粒子材质图形的创建，一般是通过canvas描绘或通过加载图片的方式来格式化粒子：\n\n1. 直接引用画布，当通过CanvasRenderer渲染时：\n\n  ```js\n  renderer = new THREE.CanvasRenderer();\n  ```\n\n  你可以直接在每个粒子的材质对象里直接引用HTML5画布。例如：\n\n  ```js\n  //画点\n  var PI2 = Math.PI * 2;\n  var program = function ( context ) {\n      context.beginPath();\n      context.arc( 0, 0, 0.5, 0, PI2, true );\n      context.fill();\n  };\n  //为每个点附上材质\n  var material = new THREE.SpriteCanvasMaterial( {\n      color: Math.random() * 0x808008 + 0x808080,\n      program: program\n  } );\n  ```\n\n> points对象只能通过WebGLRender进行渲染，所以pointsmaterial和这种方式是无缘了。WebGLRender渲染时的粒子如果需要用canvas实现，则必须加多一步将canvas转化为纹理，在通过map属性加载进来。\n\n2. 加载图片纹理：\n\n   ```js\n   var textureLoader = new THREE.TextureLoader();\n   var sprite = textureLoader.load( \"textures/sprites/snowflake.png\" );\n   var material = new THREE.PointsMaterial( { size: size, map: sprite, blending: THREE.AdditiveBlending, depthTest: false, transparent : true } );\n   ```\n","tags":["THREE"],"categories":["THREE.js"]},{"title":"基础材质","url":"%2F2018%2F09%2F03%2F3JS--%E5%9F%BA%E6%9C%AC%E6%9D%90%E8%B4%A8%2F","content":"\n### THREE.MeshBasicMaterial (基础材质)\n\n不受光照影响，会被渲染成简单的平面多边形，也可以显示几何体的线框，他还有其他属性\n\n| 名称                                | 描述                         |\n| ----------------------------------- | ---------------------------- |\n| color（颜色）                       | 材质颜色                     |\n| wireframe（线框）                   | 将材质渲染成线框             |\n| wireframeLinewidth（线框宽度）      | 线框宽度                     |\n| wireframeLinejoin（线框线段连接点） | 点如何连接                   |\n| shading（着色）                     | 如何着色                     |\n| vertexColors（定点颜色）            | 为每个顶点设置颜色           |\n| fog（雾化）                         | 设置材质是否受到全局雾化影响 |\n\n### THREE.MeshDepthMaterial （深度材质）\n\n该材质的物体外观不是由关照或者某个材质属性决定，而是由物体到摄像机的距离决定。所以，很适合用来实现**逐渐消失**的效果。他还有额外的属性：\n\n| 名称                           | 描述         |\n| ------------------------------ | ------------ |\n| wireframe（线框）              | 是否显示线框 |\n| wireframeLinewidth（线框宽度） | 线框宽度     |\n\n使用这个材质时候，其他配置都是默认值，比如材质颜色，无法直接传参改变。解决方法是使用联合材质来产生新效果。\n\n```js\nvar cubeGeometry = new THREE.BoxGeometry(10, 10, 10); //形状\nvar cubeDepthMaterial = new THREE.MeshDepthMaterial(); //深度材质\nvar colorMaterial = new THREE.MeshBasicMaterial({\n    color: 0x00ff00,\n    transparent: true,\n    opacity: 0.4,\n    wireframe: true,\n    blending: THREE.MultiplyBlending\n}); //基础材料的颜色\nvar cube1 = new THREE.SceneUtils.createMultiMaterialObject(cubeGeometry, [cubeDepthMaterial, colorMaterial]); //联合材质\ncube1.scale.set(0.99, 0.99, 0.99);\nvar cubeGeometry = new THREE.BoxGeometry(10, 10, 10);  //形状\nvar cubeDepthMaterial = new THREE.MeshDepthMaterial(); //深度材质\nvar colorMaterial = new THREE.MeshBasicMaterial({color:0x00ff00,transparent:true,opacity:0.4,wireframe:true});   //基础材料的颜色\nvar cube1 = new THREE.SceneUtils.createMultiMaterialObject(cubeGeometry,[cubeDepthMaterial,colorMaterial]);   //联合材质\n        cube1.scale.set(0.99,0.99,0.99);\n```\n\n要实现这种效果我们需要创建两种材质，对于`THREE.MeshBasicMaterial`需要指定一个融合模式。为了防止融合模式下渲染闪烁，需要缩小带有`THREE.MeshDepthMaterial`材质的网格：\n\n```js\n cube1.scale.set(0.99,0.99,0.99);\n```\n\n### MeshNormalMaterial （法向量材质）\n\n该材质是用于根据face(三角面)的法向量方向的不同系统会自动赋予不同的颜色，即当一个物体材质为法向量材质，物体旋转的时候由于各个面的法向量不断发生变化，所以物体的颜色也是不断发生变化。\n\n注意：平面与几何体有一定的区别，几何体不管怎么移动，内部的面是看不见的，材质可以赋值一面，但是对于平面来说，平面的旋转的时候两面是可以看到的，所以赋值材质时要设置成两面，否则但转到背面时，平面就不会显示。\n\n### MeshFaceMaterial（面材质）\n\n MeshFaceMaterial 材质其实就是一个材质数组。举个例子，假如我们在场景中加入一个立方体，这个立方体上有六个面，你可以通过定义一个长度为六的材质数组来为每一个面单独指定一种材质（比如不同的颜色）即可\n\n```js\nar matArray = [];\nmatArray.push(new THREE.MeshBasicMaterial({color: 0x009e60}));\nmatArray.push(new THREE.MeshBasicMaterial({color: 0x0051ba}));\nmatArray.push(new THREE.MeshBasicMaterial({color: 0xffd500}));\nmatArray.push(new THREE.MeshBasicMaterial({color: 0xff5800}));\nmatArray.push(new THREE.MeshBasicMaterial({color: 0xc41e3a}));\nmatArray.push(new THREE.MeshBasicMaterial({color: 0xffffff}));\n \nvar cube = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), matArray);\n```\n\n","tags":["THREE"],"categories":["THREE.js"]},{"title":"材质","url":"%2F2018%2F08%2F21%2F3JS--%E6%9D%90%E8%B4%A8%2F","content":"\n\n\n材质结合几何体可以构成网格。材质就是物体的皮肤，决定结合体外表的样子。常用材质如下：\n\n| 名称                                | 描述                                                     |\n| :---------------------------------- | :------------------------------------------------------- |\n| MeshBasicMaterial（网格基础材质）   | 基础材质                                                 |\n| MeshDepthMaterial（网格深度材质）   | 根据网格到相机的距离，这种材质决定如何给网格染色         |\n| MeshNormalMaterial（网格法向材质）  | 简单材质，根据物体表面的法向向量计算颜色                 |\n| MeshFaceMaterial（网格面材质）      | 这是一个容器，可以在容器里为物体的各个表面指定不同的颜色 |\n| MeshLambertMaterial（网格朗伯材质） | 材质考虑光照，可以用来创建颜色**暗淡、不光亮**的物体     |\n| MeshPhongMaterial（网格Phong材质）  | 材质考虑光照，可以用来创建颜色**光亮**的物体             |\n| ShaderMaterial（着色器材质）        | 材质允许使用自定义着色器程序                             |\n| LineBasicMaterial（直线基础材质）   | 用于`THREE.Line`（直线）几何体，从而创建着色的直线       |\n| LineDashedMaterial（虚线材质）      | 虚线效果                                                 |\n\n对于如此多材质，我们可以分为三类属性去使用：基础属性、融合属性、高级属性。\n\n#### 基础属性\n\n常用属性，控制物体的透明度，是否可见等等。\n\n| 属性                    | 描述                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| id（标识符）            | 第一个材质为0，以后新加一个值就加1                           |\n| uuid（通用唯一识别码）  | 生成的唯一ID，在内部使用                                     |\n| name（名称）            | 用于调试                                                     |\n| opacity（不透明度）     | 透明度0-1                                                    |\n| transparent（是否透明） | 为true，则物体会用指定的opacity去渲染；false这个物体不透明，只是着色更加明亮 |\n| overdraw（过度描绘）    | 物体有间隙，可以将这个设置为true调整                         |\n| visible（是否可见）     | 是否能看见这个物体                                           |\n| slide（侧面）           | 定义几何体的哪一面应用材质                                   |\n| needsUpdate（是否更新） | 属性更新后告诉THREE.js更新他的缓存                           |\n\n#### 融合属性\n\n融合决定了我们渲染的颜色如何与他们后面的颜色交互\n\n| 名称                      | 描述                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| blending（融合）          | 决定物体上的材质是否**和背景融合**。一般的融合模式是NormalBlending，在这种模式下只显示材质的上层 |\n| blendsrc（融合源）        | 定义了该物体如何与背景相互融合，默认使用alpha（透明度）通道进行融合 |\n| blend电视台（融合目标）   | 定义融合时候如何使用背景（目标）                             |\n| blendequation（融合公式） | 定义如何使用blendsrc和blenddst的值。                         |\n\n","tags":["THREE"],"categories":["THREE.js"]},{"title":"各种光源","url":"%2F2018%2F08%2F20%2F3JS--%E5%90%84%E7%A7%8D%E5%85%89%E6%BA%90%2F","content":"\n`THREE.js`提供了一系列的光源，各有用途：\n\n| 光源名称                     | 描述                                                 |\n| ---------------------------- | ---------------------------------------------------- |\n| AmbientLight（环境光源）     | 颜色会直接作用物体的当前颜色上                       |\n| PointLight（点光源）         | 一个点向所有方向                                     |\n| SpotLight（聚光灯）          | 聚光灯效果（范围）例如台灯                           |\n| DirectionalLight（方向光源） | 平行光源 例如太阳光                                  |\n| HemisphereLight（半球光）    | 创造自然室外光线，模拟反光和光线微弱的天空，太阳升降 |\n| AreaLight（面光源）          | 可指定光线的面                                       |\n| LensFlare（镜头眩光）        | 给光源添加眩光效果                                   |\n\n#### AmbientLight（环境光源）\n\n环境光可以说是场景的整体基调，它没有特定的来源，同时也不会影响阴影的产生。有点类似于滤镜，营造全局。\n\n```js\n// add subtle ambient lighting\nvar ambiColor = \"#0c0c0c\";    //浅色，弱化生硬的投影\nvar ambientLight = new THREE.AmbientLight(ambiColor);\nscene.add(ambientLight);\n```\n\n由于环境光无处不在，也就是说它是没有方向的，当然不能产生阴影。而且，它也不能作为环境中唯一的光源。\n\n#### PointLight（点光源）  \n\n可以将点光源想象成萤火虫一样发出的光。由于它的光线也发射到四面八方，在ThreeJS中它也是不能产生阴影的。常用的属性如下：\n\n| 属性                | 描述                |\n| ------------------- | ------------------- |\n| color（颜色）       | 光源颜色            |\n| intensity（强度）   | 光照强度，默认值是1 |\n| distance（距离）    | 光源照射的距离      |\n| position（位置）    | 光源所在的位置      |\n| visible（是否可见） | true打开，false关闭 |\n#### SpotLight（聚光灯）\n\n大概是最常用的光源，类比手电筒或灯笼。常用的属性如下：\n\n| 属性                                   | 描述                                                         |\n| -------------------------------------- | ------------------------------------------------------------ |\n| castShadow（阴影）                     | true则照射会产生yinying                                      |\n| shadowCameraNear（投影近点）           | 从距离光源的哪一点开始可以生成阴影                           |\n| shadowCameraFar（投影远点）            | 到距离光源的哪一点为止可以生成阴影                           |\n| shadowCameraFov（投影视场）            | 用于生成阴影的视场有多大                                     |\n| target（目标）                         | 决定光照的fang'xiang                                         |\n| shadowBias（阴影偏移）                 | 用来设置阴影的位置                                           |\n| angle（角度）                          | 光源射出的光柱有多宽。单位是弧度，默认值是Math.PI/3          |\n| exponent（光强衰减指数）               | 光照指向特定目标。在这个方向上距离光源越远，则光强度递减得越快。这个值觉得光照强度递减得有多快 |\n| onlyShadow（仅阴影）                   | true这个光源只会生成阴影而不会在场景                         |\n| shadowCameraFovVisible（投影方式可见） | true就可以看到光源在哪里以及如何生成光源                     |\n| shadowDarkness（阴影暗度）             | 默认值0.5。                                                  |\n| shadowMapWidth（引用映射宽度）         | 决定由多少像素来生成阴影。如果阴影的边缘参差不齐或看上去不那么平滑，可以增加这个值。 |\n| shadowMapHeight（引用映射高度）        | 决定由多少像素来生成阴影。如果阴影的边缘参差不齐或看上去不那么平滑，可以增加这个值。 |\n\n```js\nvar spotLight = new THREE.SpotLight(0xffffff);  //颜色\n    spotLight.position.set(0, 90, -50);    //光源位置\n    spotLight.castShadow = true;          //打开照射阴影\n    spotLight.target = plane;             //照射目标（照射于中心点）\n    spotLight.shadowCameraFovVisible = true;  //显示阴影的形成\n    scene.add(spotLight);\n```\n\n#### DirectionalLight（方向光源）\n\n方向光源可以看成是距离很远的光源，就像太阳光一样，达到地球的光线都可以看成是平行光。被方向光光源照亮的整个区域接收到的光强是一样的。\n\n由于模型的阴影渲染会消耗很多的性能，所以我们需要设置平行光相关的区域能够显示阴影，和阴影显示的良好程度。如下几个属性：\n\n```js\ndirectionalLight.shadow.camera.near = 20; //产生阴影的最近距离\ndirectionalLight.shadow.camera.far = 200; //产生阴影的最远距离\ndirectionalLight.shadow.camera.left = -50; //产生阴影距离位置的最左边位置\ndirectionalLight.shadow.camera.right = 50; //最右边\ndirectionalLight.shadow.camera.top = 50; //最上边\ndirectionalLight.shadow.camera.bottom = -50; //最下面\n\n//这两个值决定使用多少像素生成阴影 默认512\ndirectionalLight.shadow.mapSize.height = 1024;\ndirectionalLight.shadow.mapSize.width = 1024;\n```\n\n![pl6e21c.png](https://miao.su/images/2018/08/23/pl6e21c.png)\n\n由于所有光线是相互平行的，所以不会有光椎，却而代之的是一个方块。图中方块区域内的元素会显示阴影。\n\n#### HemisphereLight（半球光）\n\n使用半球光可以获得光加贴近自然的光照效果。\n\n当你使用环境光为场景提供基础色，现实中并非所有的光都来自天空，还有很多散射、地面的反射和其他物体的反射，所有他可以设置如下属性：\n\n| 属性        | 描述·                    |\n| ----------- | ------------------------ |\n| groundColor | 从地面发出的光线的颜色   |\n| Color       | 从天空中发出的光线的颜色 |\n| intensity   | 光照强度                 |\n\n#### LensFlare（镜头眩光）\n\n当你直接朝着太阳拍照时候就会出现镜头眩光，现实中虽然要必然这种现象，但是在游戏场景中，镜头眩光能使得场景更加真实。常用的属性如下：\n\n| 参数             | 描述                     |\n| ---------------- | ------------------------ |\n| texture（纹理）  | 眩光材质，决定炫光的样子 |\n| size（尺寸）     | 制定眩光的大小           |\n| distance（距离） | 光源（0）到相机（1）     |\n| blending（融合） | 丰富眩光的材质           |\n| color（颜色）    | 眩光的颜色               |\n\n```js\nvar textureFlare0 = THREE.ImageUtils.loadTexture(\"lensflare0.png\");  //加载纹理\nvar textureFlare3 = THREE.ImageUtils.loadTexture(\"lensflare3.png\");  //加载纹理\nvar flareColor = new THREE.Color(0xf0fa78);\nvar lensFlare = new THREE.LensFlare(textureFlare0, 350, 0.0, THREE.AdditiveBlending, flareColor); \n// new THREE.LensFlare(texture, size, distance, blending, color)\n\n\n//.add ( texture, size, distance, blending, color )\n// 添加一个光晕，和构造函数的配置一样\nlensFlare.add(textureFlare3, 60, 0.6, THREE.AdditiveBlending); \nlensFlare.add(textureFlare3, 70, 0.7, THREE.AdditiveBlending);\nlensFlare.add(textureFlare3, 120, 0.9, THREE.AdditiveBlending);\nlensFlare.add(textureFlare3, 70, 1.0, THREE.AdditiveBlending);\nlensFlare.position.copy(spotLight.position);  //让镜头眩光出现在点光源处\n\nscene.add(lensFlare);\n```\n\n![lenf2b614.png](https://miao.su/images/2018/08/23/lenf2b614.png)","tags":["THREE"],"categories":["THREE.js"]},{"title":"THREE 规范参考","url":"%2F2018%2F08%2F20%2F3JS--%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83%2F","content":"```js\nvar renderer;\nfunction initThree() {\n    width = document.getElementById('canvas-frame').clientWidth;\n    height = document.getElementById('canvas-frame').clientHeight;\n    renderer = new THREE.WebGLRenderer({\n        antialias : true\n    });\n    renderer.setSize(width, height);\n    document.getElementById('canvas-frame').appendChild(renderer.domElement);\n    renderer.setClearColor(0xFFFFFF, 1.0);\n}\n\nvar camera;\nfunction initCamera() {\n    camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);\n    camera.position.x = 600;\n    camera.position.y = 0;\n    camera.position.z = 600;\n    camera.up.x = 0;\n    camera.up.y = 1;\n    camera.up.z = 0;\n    camera.lookAt({\n        x : 0,\n        y : 0,\n        z : 0\n    });\n}\n\nvar scene;\nfunction initScene() {\n    scene = new THREE.Scene();\n}\n\nvar light;\nfunction initLight() {\n}\n\nvar cube;\nfunction initObject() {\n    var geometry = new THREE.CubeGeometry( 200, 100, 50,4,4);\n    var material = new THREE.MeshLambertMaterial( { color:0xFFFFFF} );\n    var mesh = new THREE.Mesh( geometry,material);\n    mesh.position = new THREE.Vector3(0,0,0);\n    scene.add(mesh);\n}\n\nfunction threeStart() {\n    initThree();\n    initCamera();\n    initScene();\n    initLight();\n    initObject();\n    renderer.clear();\n    renderer.render(scene, camera);\n}\n\n```\n\n另外一种规范参考\n\n```js\n(function () {\n    window.XW = {\n        //初始化canvas的宽高\n        initCanvasSize: function () {\n            let t = this;\n            t.canvasWidth = window.innerWidth;\n            t.canvasHeight = window.innerHeight;\n        },\n        //初始化场景\n        initScene: function () {\n            let t = this;\n            t.scene = new THREE.Scene();\n            t.scene.background = (new THREE.TextureLoader).load(\"img/scene1/sky.jpg\");\n            t.scene.fog = new THREE.Fog(47215, .1, 5400);\n            t.scene.add(new THREE.AxesHelper(25));\n        },\n        //初始化相机\n        initCamera: function () {\n            let t = this;\n            t.camera = new THREE.PerspectiveCamera(45, t.canvasWidth / t.canvasHeight, 0.1, 4000);\n            t.camera.position.set(10, 20, 20);\n            t.camera.lookAt(t.scene.position);\n        },\n        //初始化渲染器\n        initRender: function () {\n            let t = this;\n            t.renderer = new THREE.WebGLRenderer({antialias: true});\n            t.renderer.setSize(t.canvasWidth, t.canvasHeight);\n            t.renderer.setClearColor(0xffffff);\n            document.body.appendChild(t.renderer.domElement);\n        },\n        //持续动画\n        initAnimate: function () {\n            let t = this;\n            t.renderer.render(t.scene, t.camera);\n            //call和apply都是立即调用，而bind返回一个函数\n            requestAnimationFrame(t.initAnimate.bind(t))\n            //直接执行t.initAnimate（）里面的this指向window，用bind修改指向 ==》 t.(t.initAnimate)\n        },\n        //初始化灯光\n        initLight: function () {\n            this.scene.add(new THREE.AmbientLight(16777215));\n        },\n        //开启3D\n        threeStart: function () {\n            let t = this;\n            t.initCanvasSize();\n            t.initScene();\n            t.initCamera();\n            t.initLight();\n            t.initRender();\n            t.initAnimate();\n        }\n    }\n})();\nXW.threeStart();\n```\n\n","tags":["THREE"],"categories":["THREE.js"]},{"title":"THREE.Scene常用方法和属性","url":"%2F2018%2F08%2F18%2F3JS--%E5%9C%BA%E6%99%AF%E5%AF%B9%E8%B1%A1THREE.Scene%2F","content":"THREE.Scence 场景是所有对象的容器，所有对象和元素都会被放到场景中才能渲染。\n\n| 方法（属性）                    | 描述                                                         |\n| ------------------------------- | ------------------------------------------------------------ |\n| add(object)                     | 用于向场景中添加对象。使用该方法还可以创建对象组。           |\n| children                        | 用于返回一个场景中所有对象的列表，包括摄像机和光源。         |\n| getObjectByName(name,recursive) | 在创建对象时可以指定唯一的标识 name，使用该方法可以查找特定名字的对象。 当参数 recursive 设置为 false 时，在调用者子元素上查找当参数 recursive 设置为 true 时，在调用者的所有后代对象上查找 |\n| remove(object)                  | object 为场景中对象的引用，使用该方法可以将对象从场景中移除。 |\n| traverse(function)              | 该方法也可以遍历调用者和调用者的所有后代，function 参数是一个函数，被调用者和每一个后代对象调用 function 方法。 |\n| fog                             | 使用该属性可以为场景添加雾化效果，可以产生隐藏远处物体的浓雾效果。 |\n| overrideMaterial                | 使用该属性可以强制场景中的所有物体使用相同的材质。           |\n\n ```js\nvar scene = new THREE.Scene();  //初始化\n ```\n\n#### add（object）\n\n场景有了之后，我们需要在场景中放置我们的演员（对象），这里包括物体，相机和光源。\n\n```js\n    //绘制一个物体\n    var cubeShape = new THREE.BoxGeometry(4,4,4);\n    var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000, wireframe: true});\n    var cube = new THREE.Mesh(cubeShape, cubeMaterial);\n\t//把物体放置进场景中\n    scene.add(cube);    \n```\n\n#### children\n\n该属性用于返回`scene`中所有的对象，在控制台打印`scene`\n\n![sceneb6363.png](https://miao.su/images/2018/08/21/sceneb6363.png)\n\n可以可到`scene`中定义的各种属性。当我们往`scene`中添加对象，这些元素都会存储到`scene`中的`children`数组里面。\n\n所以移除场景中对象，就是除`children`数组中的值\n\n```js\nfunction removeEle(num) {\n    var allChildren = scene.children;\n    var lastObject = allChildren[num];\n    if (lastObject instanceof THREE.Mesh) {\n        scene.remove(lastObject);\n    }\n}\n```\n\n我们也可以为每一个对象添加属于他自己的`name` 属性\n\n```js\n//绘制一个立方体\nvar cubeShape = new THREE.BoxGeometry(4,4,4);\nvar cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000, wireframe: true});\nvar cube = new THREE.Mesh(cubeShape, cubeMaterial);\n// position the cube\ncube.name = '立方体'\n```\n![children3aefd.png](https://miao.su/images/2018/08/21/children3aefd.png)\n\n可以看到`name`属性成功添加到元素中，后续方便我们查找。\n\n#### getObjectByName(name,recursive)\n\n上面，`cube.name = '立方体'`，这个`name`也是该对象的标识符，通过`getObjectByName`可以找到该对象\n\n```js\nconsole.log(scene.getObjectByName('立方体'));\n//THREE.Mesh {uuid: \"B9454ABD-01EF-4333-A6DD-21FA30F8F843\", name: \"立方体\", type: \"Mesh\", parent: T…E.Scene, children: Array(0), …}\n//如果 recursive 为 true，则开启后代查询\n```\n\n### remove（object）\n\n查找到有标识符的对象，就可以对其进行操作，比如删除该对象:\n\n```js\nvar target = scene.getObjectByName('立方体');\nif (target instanceof THREE.Mesh) {\n    scene.remove(target);\n}\n```\n\n如此，`name`属性为'立方体'的对象就会从`scene`中删除。\n\n> 移除前我们还要检查下该对象是不是 THREE.Mesh 对象，这样做是为了**避免移除摄像机和光源**。\n\n#### traverse（function）\n\n我们可以将一个方法作为参数传递给 `traverse() `方法，这个传递过来的方法会在**每一个子对象上执行**。\n\n由于 THREE.Scene 对象存储的是对象树，所以如果子对象本身还有子对象，traverse() 方法会在所有的子对象上执行，直到遍历完场景树中的所有对象为止。\n\n比如我们给所有对象添加`name`：\n\n```js\nscene.traverse(function (e) {\n    if (e instanceof THREE.Mesh) {\n        e.name ='123'\n    }\n})\n```\n#### fog\n\n使用 fog 属性可以为整个场景添加雾化效果，即场景中的物体离得越远就会变得越模糊。具体样式有如下两种：\n\n（1）使用 THREE.Fog：该方法雾的浓度是线性增长的，它有三个参数：\n\n+ 第 1 个参数：雾的颜色\n\n+ 第 2 个参数：near（近处）属性的值，决定雾化开始的地方。\n\n+ 第 3 参数：far（远处）属性的值，决定雾化结束的地方。\n\n```js\n`scene.fog = ``new` `THREE.Fog(0xffffff, 0.015, 100);`\n```\n\n（2）使用 THREE.FogExp2：该方法雾的浓度不再是线性增长的，而是随着距离呈指数增长，它有两个参数：\n\n+ 第 1 个参数：雾的颜色\n\n+ 第 2 个参数：雾的浓度\n\n```js\n`scene.fog = ``new` `THREE.FogExp2( 0xffffff, 0.015 );`\n```\n\n#### overrideMaterial 属性\n\n（1）场景设置了 overrideMaterial 属性后，场景中所有的物体都会使用该属性指向的材质，即使物体本身也设置了材质。\n\n（2）上面的样例中我们使用的材质是 THREE.MeshLambertMaterial，该材质可以创建出不发光但是可以对场景中的光源产生反应的物体。\n\n```js\n`scene.overrideMaterial = ``new` `THREE.MeshLambertMaterial({color: 0xffffff});`\n```","tags":["THREE"],"categories":["THREE.js"]},{"title":"基本包装类型","url":"%2F2018%2F08%2F14%2FJS--%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%2F","content":"\njs数据类型分为两种，**基本数据类型**和**引用类型**。\n\n引用类型能拥有属性和方法，但是基本数据类型不能。然而有些时候，我们却能够对基本数据类型调用相关方法，其实，在基本数据类型中又包括有**基本包装类型**：**字符串，数字和布尔值**。他们对应的构造函数是**String，Number和Boolean**。\n\n来看一道题：\n\n```js\nvar str = 'string';\nconsole.log(str.length)\n```\n\n理论上，基本数据类型没有属性和方法，但是我们在控制台可以打印出6，为什么呢？\n\n实际上，对于基本包装类型，在调用改类型方法或者属性时，会自动创建一个**包装类型的对象**，然后调用**改对象的方法和属性**。听起来有点拗口，比如上面的代码流程如下：\n\n1. 创建String类型的一个实例\n2. 在实例上调用指定的方法\n3. 销毁这个实例\n\n所以，实际的执行代码就可以更改为：\n\n```js\nvar str = 'string';\nvar len = str.length;\nconsole.log(len); // 6\n\nvar str = 'string';\nvar _str = new String(str);  //为基本包装类型创建一个对象（_str）\nvar len = _str.length;\t\t //调用改对象上的方法和属性\n_str = null;\t\t\t\t //摧毁改对象（_str）\nconsole.log(len); // 6\n```\n\n所以我们在创建基本数据类型的时候，就能调用对应包装类型的方法，这样也会方便很多。\n\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"横竖屏","url":"%2F2018%2F07%2F14%2FTX--%E6%A8%AA%E7%AB%96%E5%B1%8F%2F","content":"\n如果页面不涉及软键盘，尽量使用css解决\n\n#### CSS\n\n```css\n\n@media all and (orientation : landscape ){\n    html,body  { position:relative; overflow:hidden;width:100%; height:100%;padding:0;margin:0;}\n    html::before {content: \"\"; position:fixed; top:0; left:0; height:100%; width:100%; background:#333; z-index:99999; }\n    html::after {content: \"为了更好的体验，请将手机竖过来哦~\";position:absolute; top:50%; left:0; height:30px; line-height:30px;\n    width:100%;z-index:99999; text-align:center; font-size:18px; color:#fff;  }\n}\n\n\n/*竖版*/\n@media all and (orientation : portrait ) and (max-width:600px){\n  html,body  { position:relative; overflow:hidden;width:100%; height:100%;margin:0;padding:0;}\n  html::before {position:fixed; z-index:99999; top:0; left:0; width:100%; height:100%; content: \"\"; background:#333; }\n  html::after {position:absolute; z-index:99999; top:50%; left:0; width:100%; height:30px; margin-top:30px; content: \"为了更好的体验，请将手机横过来~\";text-align:center; color:#fff;  font-size:16px; }\n  body::before  {position:absolute; z-index:99999; top:50%; left:50%; width:100px; height:200px; margin:-160px 0 0 -50px;  content: \"\"; color:#fff; background-size:100px auto;}\n}\n\n```\n\n#### JS\n\n方案不尽完整，忽略了软键盘弹出的影响。更深层的解决方案是通过`throttle+resize`的方案去判断。\n\n```JS\n   /* 横竖提示处理\n * isVertical：不传默认为false，即显示竖屏提示，（false: 提示用户横屏， true：提示用户竖屏）\n */\n    (function landscape(isVertical, config) {\n        var showWay = isVertical ? \"@media screen and (min-aspect-ratio: 12/7){#orientLayer{display:block;} }\" :\n            \"@media all and (orientation : portrait){#orientLayer{display: block;} }\";\n        var color = config && config.color ? config.color : \"#000\",\n            txt = isVertical ? \"为了更好的体验，请使用竖屏浏览\" : \"为了更好的体验，请使用横屏浏览\",\n            images = config && config.images ? config.images :\n                \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIYAAADaCAMAAABU68ovAAAAXVBMVEUAAAD29vb////x8fH////////x8fH5+fn29vby8vL////5+fn39/f6+vr////x8fH////////+/v7////09PT////x8fH39/f////////////////////x8fH///+WLTLGAAAAHXRSTlMAIpML+gb4ZhHWn1c2gvHBvq1uKJcC6k8b187lQ9yhhboAAAQYSURBVHja7d3blpowFIDhTUIAOchZDkre/zE7ycySrbUUpsRN2/1fzO18KzEqxEVgTiZNfgmmtxRc8iaR8HNe8x4BtjQePKayYCIoyBSgvNNE1AkNSHqZyLqk97EgUCCHBzZ5mkg7ScvIJuIyOyXBRFxgpqWZyGsAZLB1KjsJi8nutHU4JCRbFRH8tmirI9k8Jx2sqNs8K/m0LQkrktO2crgcgXGB4AiTEsB0hJfo9MGgX7CGcYiYwQxmMOOvZwRhBG8tCoMXjBDeXvWCEcHbi14wgCBmMIMZzGAGM5jxETNwzMAxA8cMHDNwzMAxA8cMHDNwzMAxA8cMHDNwzMAxY6E2rUQxnH2tz9cirlJFwFBJedaPnUv0M7++egPDE8iAJcIDmxwH5wwv9vUviw2kLbVO3TJU5uul/EyB0FoLp4x60PdGUd3qPurrWyjGGTc05u+1dcgI7/+tCCPARWGhH7o5Y7RCf+bH9ctXLp6v2BVDxfqz0oPXeSVaNtINo/1SXDv4dck8IIkbhtC2ol+iouEonTBCbYvVMnXOjxww6s/RFrBUpXHh/gw1rHj5d/qhYn9Gpk2FWh6xRBRX5Oj3Znh2Sq49/L6+y8pB26q9GbE2dbA2mVbx6I+7MfBglLCttm73ZQi7AD3iL4HqjFYJHSPRppqaUaJ3ATpGa+ckpGak2hRRMyqjGMkvl+xyFeSMwjAqcsZgGDdyhl0oNTnDN4yenJGZFGxNChP5/Y3efh6SM2rDOJMzboYxkDMqwyjIGcIw6F+io2FU1IxIm1JqRmgXSkvNKNCXeTpGrU0JNSO2c6LIGPgCS8AuDHz9ta0SXWDtxoDRH+MqlbC2Dt2G2JFRadtQZt2qq/orGowdGb2euxYiqWEpVWhTBnszoNAPdStuQwxqf0aocdWKW4Z+DfszIh8pxJqbuCE4YAC+4bm0evtipjpgJHeFnyyt1Ku2xa0bhjxr27p75rECNwyI9ZwvXkHq+7aTaMEV44YYy/spfgjgjNHaWW+GeUhGEX7tLlVinIFDDSgnOwhi1V6bU0b6tVS9eAERe863g4dRrtiHdc6o+nn5vtyVVgR79Cqt4uL6gfHPQyGqtP2vf7HADGbcYwaOGThm4JiBYwaOGThm4JiBYwaOGThm4JiBYwaOGThm4JiBYwaOGThm4JjhtOM+J/AgT008yDMkN/dPP9hzS8zAMQN3OEYeekp5YU7KOKXwVXqiY+QS7smcinGKABWdiBgpPJTSMHJ4KidhhPBUSMLw4CmPhKHgKUXCkHsygum71ftNSgCX6bsl8FQyfbcL5EdYsDk0R3j7aiA5wpt5AjKg/2gLJEBD/0Hf2OOf/vRrj6z/7GtP4B3nMKyjHA12kIPSjnJs3FEO0TvKkYJHOWCR+rjJH0Vn6fI5PjNbAAAAAElFTkSuQmCC\";\n        // style\n        var nodeStyle = document.createElement('style');\n        nodeStyle.setAttribute('type', 'text/css');\n        nodeStyle.innerHTML =\n            '@-webkit-keyframes rotation{10%{transform: rotate(90deg); -webkit-transform: rotate(90deg)} 50%, 60%{transform: rotate(0deg); -webkit-transform: rotate(0deg)} 90%{transform: rotate(90deg); -webkit-transform: rotate(90deg)} 100%{transform: rotate(90deg); -webkit-transform: rotate(90deg)} } @keyframes rotation{10%{transform: rotate(90deg); -webkit-transform: rotate(90deg)} 50%, 60%{transform: rotate(0deg); -webkit-transform: rotate(0deg)} 90%{transform: rotate(90deg); -webkit-transform: rotate(90deg)} 100%{transform: rotate(90deg); -webkit-transform: rotate(90deg)} } #orientLayer{display: none; z-index: 999999;} ' +\n            showWay +\n            ' .mod-orient-layer{display: none; position: fixed; height: 100%; width: 100%; left: 0; top: 0; right: 0; bottom: 0; background: ' +\n            color +\n            '; z-index: 9997} .mod-orient-layer__content{position: absolute; width: 100%; top: 45%; margin-top: -75px; text-align: center} .mod-orient-layer__icon-orient{background-image: url(' +\n            images +\n            '); display: inline-block; width: 67px; height: 109px; transform: rotate(90deg); -webkit-transform: rotate(90deg); -webkit-animation: rotation infinite 1.5s ease-in-out; animation: rotation infinite 1.5s ease-in-out; -webkit-background-size: 67px; background-size: 67px} .mod-orient-layer__desc{margin-top: 20px; font-size: 15px; color: #fff}'\n        document.getElementsByTagName('body')[0].appendChild(nodeStyle);\n        // dom\n        var nodeDom = document.createElement('div');\n        nodeDom.setAttribute('id', 'orientLayer');\n        nodeDom.setAttribute('class', 'mod-orient-layer');\n        nodeDom.innerHTML =\n            '<div class=\"mod-orient-layer__content\"> <i class=\"icon mod-orient-layer__icon-orient\"></i> <div class=\"mod-orient-layer__desc\">' +\n            txt + '</div> </div>';\n        document.getElementsByTagName('body')[0].appendChild(nodeDom);\n    }(1))\n```\n\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"Swiper3.0使用方法","url":"%2F2018%2F07%2F10%2FTX--Swiper3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F","content":"\n#### 基本结构\n`Swiper`: 整个滑动对象，有时特指滑块释放后仍然正向移动直到贴合边缘的过程(过渡)\n`container`: Swiper的容器，包括滑块（slides）、封套（wrapper)、分页器(pagination)、前进按钮等\n`wrapper`: 触控的对象，可触摸区域，移动的块的集合，过渡时会随slide切换产生位移\n`slider`: 切换的滑块，可以包含文字、图片、html元素或另外一个Swiper\n`pagination`: 分页器，指示slide的数量和当前活动的slide\n![](https://miao.su/images/2018/07/05/swiper2fc2b.png)\n\n#### 结构样式\n线上路径 <copy> \n```html\n<script src=\"//ossweb-img.qq.com/images/js/swiper/swiper-3.4.2.min.js\"></script>\n```\n\n页面结构 <copy> \n```html\n<div class=\"swiper-container\" id=\"swiper-container1\">\n  <div class=\"swiper-wrapper\">\n    <div class=\"swiper-slide\">Slide 1</div>\n    <div class=\"swiper-slide\">Slide 2</div>\n    <div class=\"swiper-slide\">Slide 3</div>\n  </div>\n  <!-- 如果需要分页器 -->\n  <div class=\"swiper-pagination\"></div>\n\n  <!-- 如果需要导航按钮 -->\n  <div class=\"swiper-button-prev\"></div>\n  <div class=\"swiper-button-next\"></div>\n\n  <!-- 如果需要滚动条 -->\n  <div class=\"swiper-scrollbar\"></div>\n</div>\n```\n基础样式 <copy>\n```css\n/* base */\n.swiper-wp8-horizontal {-ms-touch-action: pan-y;touch-action: pan-y;}\n.swiper-container {margin-left: auto;margin-right: auto;position: relative;overflow: hidden;/* Fix of Webkit flickering */z-index: 1;}\n.swiper-container-no-flexbox .swiper-slide {float: left;}\n.swiper-container-vertical > .swiper-wrapper {-webkit-box-orient: vertical;-moz-box-orient: vertical;-ms-flex-direction: column;-webkit-flex-direction: column;flex-direction: column;}\n.swiper-wrapper {position: relative;width: 100%;height: 100%;z-index: 1;display: -webkit-box;display: -moz-box;display: -ms-flexbox;display: -webkit-flex;display: flex;-webkit-transition-property: -webkit-transform;-moz-transition-property: -moz-transform;-o-transition-property: -o-transform;-ms-transition-property: -ms-transform;transition-property: transform;-webkit-box-sizing: content-box;-moz-box-sizing: content-box;box-sizing: content-box;}\n.swiper-container-android .swiper-slide,.swiper-wrapper {-webkit-transform: translate3d(0px, 0, 0);-moz-transform: translate3d(0px, 0, 0);-o-transform: translate(0px, 0px);-ms-transform: translate3d(0px, 0, 0);transform: translate3d(0px, 0, 0);}\n.swiper-container-multirow > .swiper-wrapper {-webkit-box-lines: multiple;-moz-box-lines: multiple;-ms-flex-wrap: wrap;-webkit-flex-wrap: wrap;flex-wrap: wrap;}\n.swiper-container-free-mode > .swiper-wrapper {-webkit-transition-timing-function: ease-out;-moz-transition-timing-function: ease-out;-ms-transition-timing-function: ease-out;-o-transition-timing-function: ease-out;transition-timing-function: ease-out;margin: 0 auto;}\n.swiper-slide {-webkit-flex-shrink: 0;-ms-flex: 0 0 auto;flex-shrink: 0;width: 100%;height: 100%;position: relative;}\n/* Auto Height */\n.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide {height: auto;}\n.swiper-container-autoheight .swiper-wrapper {-webkit-box-align: start;-ms-flex-align: start;-webkit-align-items: flex-start;align-items: flex-start;-webkit-transition-property: -webkit-transform, height;-moz-transition-property: -moz-transform;-o-transition-property: -o-transform;-ms-transition-property: -ms-transform;}\n\n/* 设置宽度和高度 */\n#swiper-container1{\n  width: 500px;\n  height: 500px;\n}\n.swiper-slide1{\n  background: red;\n}\n```\n初始化 <copy>\n```js\nvar mySwiper = new Swiper ('#swiper-container1', {\n  direction: 'vertical',\n  loop: true,\n// 如果需要分页器\n  pagination: '.swiper-pagination',\n\n// 如果需要前进后退按钮\n  nextButton: '.swiper-button-next',\n  prevButton: '.swiper-button-prev',\n\n// 如果需要滚动条\n  scrollbar: '.swiper-scrollbar',\n})\n```\n更多细节参考官网API:http://3.swiper.com.cn/api/index.html","tags":["Swiper3.0"],"categories":["TX-解决方案"]},{"title":"常用功能","url":"%2F2018%2F07%2F10%2FTX--%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%2F","content":"\n#### 复制文字\n\n```js\n//复制链接\nfunction copy(str) {\n    var save = function(e) {\n        e.clipboardData.setData('text/plain', str)\n        e.preventDefault();\n    }\n    document.addEventListener('copy', save)\n    document.execCommand('copy')\n    document.removeEventListener('copy', save)\n    alert('复制成功');\n    PTTSendClick('btn', 'success', '复制成功')\n}\n\nfunction copyUrl(_this) {\n    //找到要复制的对象（这里是'copy-link'）\n    var url = _this.parent('.pop').find('.copy-link').text()\n    if (window.clipboardData) {\n        window.clipboardData.setData(\"Text\", url)\n        alert('复制成功');\n        PTTSendClick('btn', 'success', '复制成功')\n    } else {\n        copy(url)\n    }\n}\n//复制按钮绑定事件\n$('.pop-copy').on('click', function(event) {\n    copyUrl($(this));\n    PTTSendClick('btn', 'copy', '复制链接');\n})\n```\n#### 判断滚动条文职\n\n```js\n$(window).scroll(function(event) {\n    var scrollTop = window.pageYOffset ||document.documentElement.scrollTop|| document.body.scrollTop || 0;\n    if (scrollTop > $('.part1').height()) {\n      \n    } else {\n      \n    }\n});\n```\n\n#### 导航按钮\n\n```js\n//pc端\nfunction bodyMove(num) {\n   $(\"html,body\").animate({\n      scrollTop: num\n   }, 400, function() {});\n}\n$('.nav').each(function(index, el) {\n  $(this).click(function(event) {\n    var href = $(this).attr('data-href');\n    bodyMove($(href).offset().top);\n  });\n});\n\n//zepto没有animate效果\nfunction bodyMove(num) {\n  $(\"html,body\").scrollTop(num);\n}\n```\n\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"Swiper3.0局部组件","url":"%2F2018%2F07%2F10%2FTX--Swiper3%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6%2F","content":"\n最好不要直接直接引用完整的swiper的css文件\n要根据页面中是否包括滑动块（slides）、分页器(pagination)、前进按钮和动画等进行**精简**\n\n#### 前进后退按钮 <copy>\n```css\n/* Arrows */\n.swiper-button-prev,.swiper-button-next {position: absolute;top: 50%;width: 27px;height: 44px;margin-top: -22px;z-index: 10;cursor: pointer;-moz-background-size: 27px 44px;-webkit-background-size: 27px 44px;background-size: 27px 44px;background-position: center;background-repeat: no-repeat;}\n.swiper-button-prev.swiper-button-disabled,.swiper-button-next.swiper-button-disabled {opacity: 0.35;cursor: auto;pointer-events: none;}\n.swiper-button-prev,.swiper-container-rtl .swiper-button-next {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");left: 10px;right: auto;}\n.swiper-button-prev.swiper-button-black,.swiper-container-rtl .swiper-button-next.swiper-button-black {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\");}\n.swiper-button-prev.swiper-button-white,.swiper-container-rtl .swiper-button-next.swiper-button-white {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\");}\n.swiper-button-next,.swiper-container-rtl .swiper-button-prev {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");right: 10px;left: auto;}\n.swiper-button-next.swiper-button-black,.swiper-container-rtl .swiper-button-prev.swiper-button-black {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\");}\n.swiper-button-next.swiper-button-white,.swiper-container-rtl .swiper-button-prev.swiper-button-white {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\");}\n/* 改变背景 */\n.swiper-button-next,.swiper-button-prev{\n  width: 0.65rem;\n  height: 0.65rem;\n  background:url(//game.gtimg.cn/images/cqby/cp/a20180110bycjm/arrow.png) no-repeat center;\n  background-size: 100%\n}\n.swiper-button-prev{\n  background:url(//game.gtimg.cn/images/cqby/cp/a20180110bycjm/arrow2.png) no-repeat center;\n  background-size: 100%\n}\n```\n#### 分页器 <copy>\n```css\n/* Pagination Styles */\n.swiper-pagination {position: absolute;text-align: center;-webkit-transition: 300ms;-moz-transition: 300ms;-o-transition: 300ms;transition: 300ms;-webkit-transform: translate3d(0, 0, 0);-ms-transform: translate3d(0, 0, 0);-o-transform: translate3d(0, 0, 0);transform: translate3d(0, 0, 0);z-index: 10;}\n/* Common Styles */\n.swiper-pagination-fraction,.swiper-pagination-custom,.swiper-container-horizontal > .swiper-pagination-bullets {z-index: 3;bottom: 14px;left: 0;width: 100%;}\n/* Bullets */\n.swiper-pagination-bullet {display: inline-block;border-radius: 100%;background: #000;opacity: 0.2;}\nbutton.swiper-pagination-bullet {border: none;margin: 0;padding: 0;box-shadow: none;-moz-appearance: none;-ms-appearance: none;-webkit-appearance: none;appearance: none;}\n.swiper-pagination-clickable .swiper-pagination-bullet {cursor: pointer;}\n.swiper-pagination-white .swiper-pagination-bullet {background: #fff;}\n.swiper-pagination-bullet-active {opacity: 1;background: #007aff;}\n.swiper-pagination-white .swiper-pagination-bullet-active {background: #fff;}\n.swiper-pagination-black .swiper-pagination-bullet-active {background: #000;}\n.swiper-container-vertical > .swiper-pagination-bullets {right: 10px;top: 50%;-webkit-transform: translate3d(0px, -50%, 0);-moz-transform: translate3d(0px, -50%, 0);-o-transform: translate(0px, -50%);-ms-transform: translate3d(0px, -50%, 0);transform: translate3d(0px, -50%, 0);}\n.swiper-container-vertical > .swiper-pagination-bullets .swiper-pagination-bullet {margin: 5px 0;display: block;}\n.swiper-container-horizontal > .swiper-pagination-bullets .swiper-pagination-bullet {margin: 0 5px;}\n/* 自定义进度条的样式 */\n.swiper-pagination-bullet{width: 2.2rem;height: 2.2rem;background: red;opacity:0.5;}\nspan.swiper-pagination-bullet.swiper-pagination-bullet-active{background: black;opacity: 1}\n```\n#### 分页器切换页面  <copy>\n```js\nvar mySwiper = new Swiper ('#swiper-container1', {\n  pagination : '.swiper-pagination',  //分页器\n  paginationClickable :true        //点击分页器自动切换\n})\n```","tags":["Swiper3.0"],"categories":["TX-解决方案"]},{"title":"KV视频使用方法","url":"%2F2018%2F07%2F10%2FTX--KV%E8%A7%86%E9%A2%91%2F","content":"基于`video`原生标签，用于`kv`视频展示\n参考结构\n\n```html\n<video autoplay=\"autoplay\" class=\"big-video\" loop>\n    Your browser does not support the video tag.\n</video>\n```\n\n参考样式\n\n```css\n.big-video {position: absolute;top: 0;left: 50%;width: 1920px;height: 1000px;margin-left: -960px;opacity: 1;filter: alpha(opacity=100);}\n```\n\n#### 使用方式\n\n`video`的`src`获取途径有两种\n\n+ 如果视频小于**5m**，则可以直接放在`ossweb-img`图片目录中\n\n+ 视频大于**5m**，则应该上传至蛛网\n\n  + 引用视频列表（动态更新，pm出获取，这里是个**参考链接**）\n\n  ```html\n  <script src='//ossweb-img.qq.com/images/spiderMediaData/xycq_new/mediaURLData.js'></script>\n  ```\n\n  + 添加视频\n\n  ```js\n  var videoSrc = mediaURLData[2906];    //获取id，pm处获取\n  $('.big-video').attr('src',videoSrc);\n  ```\n\n  + 参考实例\n\n  [炫舞版本专题体验](http://x5m.qq.com/cp/a20180709qybb/)\n\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"预加载","url":"%2F2018%2F07%2F10%2FTX--%E9%A2%84%E5%8A%A0%E8%BD%BD%2F","content":"\n当网页图片比较多的时候，使用预加载动画，可以提高用户体验\n\n#### 引用  <copy>\n\n预加载效果使用`loder.js`实现，[前往下载](http://dev.test.gdinsight.com/dev/yq/common%20plugin/js/loder.zip)\n\n```js\n<script src=\"js/loder.js\"></script>\n```\n\n#### 添加结构\n\n根据设计稿灵活添加结构和样式，比如我要实现一个数字动态增加的预加载效果，给数字一个类名，方便抓取 <copy>\n\n```html\n<!-- 参考样式 -->\n  <div id=\"loader\" class=\"loader\">\n    <div class=\"loader-cont\">\n      <p class=\"load_val starting\">0%</p>\n    </div>\n  </div>\n```\n\n> 在`loder.js`初始化时候默认加载动画的容器`id`是`loader`\n\n#### 添加动画元素 <copy>\n\n首先，要在`loder.js`里面对需要实现动态预加载效果的元素进行“注册”，修改`preloader.init`函数 \n\n```js\npreloader.init = function() {\n    preloader.visuals = {\n        loaded: $('#loader .starting'),  //获取加载动画需要动态改变的元素\n        unloaded: $('#loader .ending')\n    };\n    preloader.$slide = $('#loader');   //加载动画容器\n};\n```\n\n通过在`preloader.visuals`对象里面添加我们想要动态改变的元素，后面就可以通过``preloader.visuals.loaded``操作该元素\n\n## 添加动画效果\n\n预加载的动画效果在`preloader.fillVisuals `函数中  <copy>\n\n```js\npreloader.fillVisuals = function(fillAmount, callback) {\n    if (!callback) callback = function() {};\n    $(function() {\n        //动画区域开始-----------\n        preloader.visuals.loaded.html(parseInt(100*fillAmount)+'%');\n        callback();  //动画完成后的回掉函数（等于preloader.onload）\n        //动画区域结束-----------\n    });\n};\n```\n\n#### 执行预加载\n\n通过`preloader.start`函数初始化预加载动画，当动画结束后执行`preloader.onLoad` <copy>\n\n```js\n  preloader.start();  //预加载\n  preloader.onLoad = function() {\n    setTimeout(function() {\n      preloader.disable();   //预加载容器消失\n      //do something\n    }, 700);\n  };\n```\n\n[斗破苍穹预加载体验](http://dp.qq.com/cp/a20180525yyz/index_p.shtml)","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"Swiper3.0效果样式","url":"%2F2018%2F07%2F10%2FTX--Swiper3%E6%95%88%E6%9E%9C%E6%A0%B7%E5%BC%8F%2F","content":"整合提取各个效果对应的样式，按需所取，去除冗余\n\n#### 渐变样式 <copy>\n```css\n/* Fade */\n.swiper-container-fade.swiper-container-free-mode .swiper-slide {-webkit-transition-timing-function: ease-out;-moz-transition-timing-function: ease-out;-ms-transition-timing-function: ease-out;-o-transition-timing-function: ease-out;transition-timing-function: ease-out;}\n.swiper-container-fade .swiper-slide {pointer-events: none;-webkit-transition-property: opacity;-moz-transition-property: opacity;-o-transition-property: opacity;transition-property: opacity;}\n.swiper-container-fade .swiper-slide .swiper-slide {pointer-events: none;}\n.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active {pointer-events: auto;}\n.swiper-zoom-container {width: 100%;height: 100%;display: -webkit-box;display: -moz-box;display: -ms-flexbox;display: -webkit-flex;display: flex;-webkit-box-pack: center;-moz-box-pack: center;-ms-flex-pack: center;-webkit-justify-content: center;justify-content: center;-webkit-box-align: center;-moz-box-align: center;-ms-flex-align: center;-webkit-align-items: center;align-items: center;text-align: center;}\n.swiper-zoom-container > img,.swiper-zoom-container > svg,.swiper-zoom-container > canvas {max-width: 100%;max-height: 100%;object-fit: contain;}\n```\n添加JS：`effect:'fade'`\n\n#### 3D翻转\n+  公用样式 <copy>\n```css\n/* 3D Container */\n.swiper-container-3d {-webkit-perspective: 1200px;-moz-perspective: 1200px;-o-perspective: 1200px;perspective: 1200px;}\n.swiper-container-3d .swiper-wrapper,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-slide-shadow-bottom,\n.swiper-container-3d .swiper-cube-shadow {-webkit-transform-style: preserve-3d;-moz-transform-style: preserve-3d;-ms-transform-style: preserve-3d;transform-style: preserve-3d;}\n.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-slide-shadow-bottom {position: absolute;left: 0;top: 0;width: 100%;height: 100%;pointer-events: none;z-index: 10;}\n.swiper-container-3d .swiper-slide-shadow-left {background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));}\n.swiper-container-3d .swiper-slide-shadow-right {background-image: -webkit-gradient(linear, right top, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));}\n.swiper-container-3d .swiper-slide-shadow-top {background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));}\n.swiper-container-3d .swiper-slide-shadow-bottom {background-image: -webkit-gradient(linear, left bottom, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));}\n.swiper-container-coverflow .swiper-wrapper,.swiper-container-flip .swiper-wrapper {-ms-perspective: 1200px;}\n```\n+ cube翻转 <copy>\n```css\n/* Cube */\n.swiper-container-cube .swiper-slide {visibility: hidden;-webkit-transform-origin: 0 0;-moz-transform-origin: 0 0;-ms-transform-origin: 0 0;transform-origin: 0 0;width: 100%;height: 100%;}\n.swiper-container-cube.swiper-container-rtl .swiper-slide {-webkit-transform-origin: 100% 0;-moz-transform-origin: 100% 0;-ms-transform-origin: 100% 0;transform-origin: 100% 0;}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-prev,.swiper-container-cube .swiper-slide-next + .swiper-slide {pointer-events: auto;visibility: visible;}\n.swiper-container-cube .swiper-cube-shadow {position: absolute;left: 0;bottom: 0px;width: 100%;height: 100%;background: #000;opacity: 0.6;-webkit-filter: blur(50px);filter: blur(50px);z-index: 0;}\n```\n+ coverflow翻转 <copy>\n```css\n/* Coverflow */\n.swiper-container-coverflow .swiper-wrapper,.swiper-container-flip .swiper-wrapper {-ms-perspective: 1200px;}\n```\n#### 添加JS代码 <copy>\n```js\neffect : 'cube',\ncube: {\n  slideShadows: true,     //开启slide阴影。默认 true。\n  shadow: true,           //开启投影。默认 true。\n  shadowOffset: 100,      //投影距离。默认 20，单位px。\n  shadowScale: 0.6       //投影缩放比例。默认0.94。\n}\n//-------华丽的分割线------------\neffect : 'coverflow',\nslidesPerView: 3,\ncoverflow: {\n  rotate: 30,              //slide做3d旋转时Y轴的旋转角度。默认50。\n  stretch: 10,             //每个slide之间的拉伸值，越大slide靠得越紧。 默认0\n  depth: 60,               //slide的位置深度。值越大z轴距离越远，看起来越小。 默认100。\n  modifier: 2,             //epth和rotate和stretch的倍率，相当于depth*modifier、rotate*modifier、stretch*modifier，值越大这三个参数的效果越明显。默认1。\n  slideShadows : false     //阴影\n},\ncenteredSlides: true,\n```","tags":["Swiper3.0"],"categories":["TX-解决方案"]},{"title":"评论组件","url":"%2F2018%2F07%2F09%2FTX--%E5%BE%AE%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD%2F","content":"\n#### 使用方法\n\n结构\n+ html   \n```css   \n/*对应HTML*/\n<div class=\"share-guide-task\" style=\"display:none;\">\n    <p class=\"share-text title-text-color\">点击 “<i class=\"icon iconfont\">&#xe604;</i>” 按钮分享出去哦~</p>\n</div>\n\n```\n+ css  \n```css\n/* 分享 */\n.share-guide-task {position: fixed;z-index: 99;top: 0;left: 0;width: 100%;height: 100%;opacity: 0.8;background: #000;}\n.share-text {position: absolute;bottom: 10px;left: 12%;color: white;font-size: 18px;}\n.iconfont{font-family: \"ingame\";}\n@font-face {\n    font-family: 'ingame';\n    src: url('//game.gtimg.cn/images/sy/2016/miniweb/ingame/iconfont/v1/iconfont.eot');\n    src: url('//game.gtimg.cn/images/sy/2016/miniweb/ingame/iconfont/v1/iconfont.eot?#iefix') format('embedded-opentype'),\n    url('//game.gtimg.cn/images/sy/2016/miniweb/ingame/iconfont/v1/iconfont.svg#iconfont') format('svg'),\n    url('//game.gtimg.cn/images/sy/2016/miniweb/ingame/iconfont/v1/iconfont.woff') format('woff'),\n    url('//game.gtimg.cn/images/sy/2016/miniweb/ingame/iconfont/v1/iconfont.ttf') format('truetype');\n    font-weight: normal;\n    font-style: normal;\n}\n```\n+ js\n\n```js\n<script src=\"//ossweb-img.qq.com/images/js/bsCommonFiles/msdkshare/msdkshare.js\"></script>\n/*utf-8版本*/\n<script src=\"//ossweb-img.qq.com/images/js/bsCommonFiles/msdkshare/msdkshare-utf8.js\"></script>\n```\n\n####  给触发分享的按钮新增class：`shareBtn`，如\n\n```html\n<div class=\"shareBtn\">告诉好基友去</div>\n```\n\n#### 初始化MSDK分享\n\n```css\n$(function() {\n    //设置分享文案\n    var sharedata = {\n        title:\"$sTitle.DATA$\"\n        ,desc:\"腾讯游戏微官网\"\n        ,url:location.href\n        ,img:\"https://game.gtimg.cn/images/hyrz/m/2016m/logo.png\"  //换成游戏LOGO\n    }\n    //初始化\n    window.ingameShare = new igShare({\n    shareData:sharedata,\n    tcss:\"ingame.share\"\n    });\n})\n```\n\n[传世3D微社区分享功能体验站](http://3d.qq.com/webplat/info/news_version3/34445/35819/35956/35957/m20773/201807/736609.shtml)","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"评论组件","url":"%2F2018%2F07%2F09%2FTX--%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6%2F","content":"\n#### 使用方法\n\n 引用css和js文件\n  css  <copy>     \n\n  ```  css\n  <link rel=\"stylesheet\" href=\"css/comment.css\">\n  ```\n\n  js   <copy> \n\n  ```html\n  <script src=\"//ossweb-img.qq.com/images/js/zepto/zepto.min.js\"></script>\n  <script src=\"//ossweb-img.qq.com/images/js/mobile_bundle/milo.js\"></script>\n  <script src=\"//ossweb-img.qq.com/images/js/bsCommonFiles/library/vue/vue-2.min.js\"></script>\n  <script src=\"//ossweb-img.qq.com/images/js/bsCommonFiles/comment/comment-3.6.min.js\" charset=\"utf-8\"></script>\n  ```\n\n> `milo`必须在`zepto`之后\n\n#### 添加评论区域   <copy> \n```html\n<!-- 评论 -->\n<div class=\"discuss\">\n    <!--评论放置的地方-->\n    <div id=\"comment\"></div>\n</div>\n```\n\n#### 根据设计稿颜色自由调配评论组件的样式   <copy> \n```css\n  /* 评论组件主体 */\n  .discuss {width: 91%;/*评论区域*/}\n  .comment-item{color:#c68e64;}\n  .comment-main {color:#c68e64;}\n  .comment-add-bar--all {background: #c68e64;}\n  .comment-add-bar--input {color: #eadcca;background: #c4822f;}\n  /* 评论面板 */\n  .comment--highlight {color: #c68e64;}\n  .sl-reply-submit {background: #c68e64;}\n  /* 举报面板 */\n  .report-title{background:#c68e64;}\n  .report-sumbit{background: #d0aa5d;}\n  .report-options li.selected .report-options-item {background: #e5a22e}\n```\n#### 挂载评论\n```js\n/*评论配置开始*/\nnew Comment({\n  el: '#comment',\n  options: {\n      gameid: 'mhzx', // 游戏 id\n      stime: 201806, // 当前资源的创建时间，年月即可\n      objid: '731923', // 当前资源的自定义 id，需保证唯一性\n      moduleId: 'comment_ingame_mhzx' // 当前资源所属的业务模块 id\n  },\n  login: { // 若无微信 / QQ 登录授权需求，则可缺省\n      qqappid: '1106107956',\n      wxappid: 'wx96a8b9ae096de54d'\n  }\n})\n```\n[跳转到具体选项说明](https://alltest.ingame.qq.com/comment/docs/mobile/api/option.html)\n\n#### 附件\n\n[comment.css下载跳转](http://dev.test.gdinsight.com/dev/yq/common%20plugin/css/comment.zip)\n\n\n#### 实例\n[传奇世界3D微社区文章区](http://cqsj3d.qq.com/webplat/info/news_version3/34445/35819/35951/35952/m20773/201807/737601.shtml)","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"添加复制功能","url":"%2F2018%2F07%2F05%2Fhexo--%E6%B7%BB%E5%8A%A0%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%2F","content":"hexo自带的代码段没有复制功能，有时候不是很方便，我们使用`clipboard.js`完善该功能。\n\n#### 引入插件\n每个主题使用的模板语言不一样，这里以`.pug`为栗子\n`cd`你的博客目录，然后打开 `theme -> layout -> _partial ->head.pug`，加入外链 \n```jsp\n    script(type='text/javascript', src='https://cdn.bootcss.com/clipboard.js/1.5.16/clipboard.min.js')\n```\n\n#### 添加按钮样式\n按钮采用动态append实现，先添加一些**CSS样式**\n```css\nfigure{\n    position: relative;\n    overflow: hidden;\n    .copy{\n        position: absolute;\n        top: 0;\n        right: 0;\n        background: #faff27;\n        color: #262626;\n        padding: 0.24em 0.8em;\n        border-bottom-left-radius: 1em;\n        font-size: 0.7em;\n        cursor: pointer;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n        &.on{\n           background: #1ec241;\n            color:white;\n        }\n    }\n}\n\n```\n#### 动态实现\n只要找到能实现全局使用的js即可  \n`cd`你的博客目录，然后打开 `theme -> source -> js ->xx.js` ，添加功能\n```js\n//动态append复制按钮，添加映射\n$('figure').each(function(index, el) {\n    $(this).attr(\"id\",\"figure\"+(index+1)).append(' <span class=\"copy\">复制</span>')\n        .find('.copy').attr({'data-clipboard-target':\"#figure\"+(index+1),'title':'点击复制'})\n        .click(function() {$(this).addClass('on').text('完成');});\n});\nlet clipboard = new Clipboard('.copy');\n```\n> 因每一个主题的渲染方式存在差异，具体的元素选择也应入乡随俗\n  **核心是一个复制按钮映射一个代码段**","tags":["hexo"],"categories":["hexo功能整合"]},{"title":"添加本地搜索","url":"%2F2018%2F07%2F04%2Fhexo--%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%2F","content":"\n随着文章数量的不断增加，目录和标签已经不能满足我们的需求，添加本地搜索有助于我们对所需资源进行快捷定位\n#### 安装搜索插件\n`cd`你的博客目录，鼠标右键选择`Git Bash Here`  <copy>\n```bash\n$ npm install hexo-generator-searchdb --save\n```\n#### 修改站点配置文件\n在`_config.yml`添加搜索支持 <copy>\n```yml\nsearch：\n    path: search.xml\n    field: post\n    format: html\n    limit: 10000\n```\n\n#### 开启搜索功能\n修改主题目录下的`_config.yml` <copy>\n```yml\nlocal_search:\n    enable: true\n```","tags":["hexo"],"categories":["hexo功能整合"]},{"title":"Hexo + Github","url":"%2F2018%2F07%2F04%2Fhexo--Hexo%2BGithub%2F","content":"利用Hexo+Github搭建个人博客\n#### 安装Git + nodejs\nGit: https://www.git-scm.com/download/\nNode.js: https://nodejs.org/zh-cn/\n\n#### 安装hexo\n```bash\n$ npm install hexo-cli -g                   //全局安装hexo\n$ hexo init blog\t\t            //创建blog文件并且初始化\n$ cd blog\t\t\t            //进入刚才创建的blog文件\t\n$ npm install\t\t\t\t    //安装各种依赖\n$ hexo server\t\t\t\t    //启动服务\n```\n#### 配置个人用户信息\n```bash\n$ git config --global user.name \"yourname\"          //用户名\n$ git config --global user.email \"yourEmail\"        //邮箱\n\n```\n在`_config.yml`中添加关联的仓库地址   <copy>\n```yml\ndeploy:\n  type: git\n  repo: git@github.com:yourname/yourname.github.io.git\n  branch: master\n```\n\n## 创建SSH\n**SSH**是一种网络协议，用于计算机之间的加密登录  <copy>\n```\nssh-keygen -t rsa -C \"youremail@example.com\n```\n进入文件找到`key`\n```bash\n$ cd ~/.ssh\n$ cat id_rsa.pub\n```\n图中蓝色区域\n![](https://miao.su/images/2018/07/04/ssshfacdb.png)\n\n## 配置Github\n新建一个名为`yourname.github.io`的仓库\n在全局`settings`里面配置**SSH**，把`key`复制进里面，`titile`自拟\n![](https://miao.su/images/2018/07/04/kryb9a07.png)\n\n## 部署\n安装部署插件  <copy>\n```bash\n$ npm install hexo-deployer-git --save\n```\n依次输入\n```bash\n$ hexo clean\n$ hexo g\n$ hexo d\n```\n访问: `https://yourname.github.io/`","tags":["hexo"],"categories":["hexo功能整合"]},{"title":"Axios+Mock","url":"%2F2018%2F07%2F02%2FVue--Axios%2BMock%2F","content":"#### 目录结构\n\n`Axios`用于前后端通信，`mock.js`用于模拟随机数据，搭配使用旨在脱离后端进行开发测试。\n\n```\n|-- data                            // 目录示例\n\n     |-- api.js                     // 统一管理axios所有的请求\n\n     |-- index.js            \t    // 拦截请求\n\n     |-- mock-data.js               // 模拟数据\n\n```\n\n#### 模拟随机数据（**data / mock-data.js**）\n\n```js\n//引入mock\nimport Mock from 'mockjs';\n//模拟用户\nconst LoginUsers = {\n  id: 1,\n  username: 'USER3114001996',\n  password: '123456',\n  num:'3114001996',\n  year:'2014',\n  departments:'信息工程学院',\n  program:'轨道交通电气化',\n  cla:'140716',\n  sec:'男',\n  desc:'如有信息错误，请及时反馈~~',\n  name: Mock.Random.cname(),\n  phone: Mock.mock(/^\\d{11}/),\n  weChat: Mock.mock(/^\\d{9}/),\n  pas:  Mock.Random.id(),\n  schoolNum:Mock.mock(/^\\d{10}/),\n  address: Mock.Random.province() +Mock.Random.city()+Mock.Random.county(true)\n};\n//导出数据\nexport {LoginUsers};\n```\n\n#### 拦截请求（**data / index.js**）\n```js\n//依赖\nlet axios = require('axios');\nlet MockAdapter = require('axios-mock-adapter');\n//通过axios-mock-adapter生成代理api地址\n//导入数据\nimport {Users,course,schedule} from \"./mock-data\"\nexport default {\n  init() {\n    //实例化\n    let mock = new MockAdapter(axios);\n\t//拦截带参数的请求，reply的参数为 (status, data, headers)\n    mock.onGet('/login').reply(config => {\n      let username = config.username;  //存储请求数据\n      let password = config.password;\n      return new Promise((resolve, reject) => {\n        let hasUser = (Users.username==username && Users.password==password)?true:false;\n          //匹配成功\n        if (hasUser) {\n          resolve([200, { code: 200, msg: '请求成功' }]);\n        } else {\n          resolve([200, { code: 500, msg: '账号或密码错误' }]);\n        }\n      })\n    });\n\n    //拦截没有参数的请求\n    mock.onGet('/card').reply(200, {\n      LoginUsers: LoginUsers     //返回的对象\n    });\n    mock.onGet('/plan').reply(200, {\n      course: course\n    });\n  }\n}\n```\n#### 通过管理请求（**data / api.js**）\n```js\n//统一管理axios所有的请求\nimport axios from 'axios'\nlet base = '';  //${base}/xx 为路径\n//获取登录信息 \nexport const requestLogin = params => axios.get(`${base}/login`,params).then(res => res.data);\n//获取卡片信息\nexport const cardMessage = params => axios.get(`${base}/card`,params).then(res => res.data);\n//获取培养计划\nexport const getPlan = params => axios.get(`${base}/plan`,params).then(res => res.data);\n//获取课程表\nexport const schedule = params => axios.get(`${base}/schedule`,params).then(res => res.data);\n\n```\n#### 使用请求\n首先引入api文件   <copy>\n```js\n  import {requestLogin} from '../../data/api'\n```\n然后在有需要的地方使用引入的方法   <copy>\n```js\n  export default {\n    name: \"Login\",\n    data() {\n      return {\n        test: {\n          name: 'USER3114001996',\n          region: '123456'\n        },\n        checked: true,\n        loading:false\n      }\n    },\n    methods:{\n      enter(){\n        this.loading = true;\n        //发送axios请求并且传递用户参数\n        let loginParams = { username: this.test.name, password: this.test.region };\n        requestLogin(loginParams).then((data) => {\n          let { msg, code, user } = data;\n          if(code!==200){\n            this.loading = false;\n            this.$message({\n              message: msg,\n              type: 'error',\n              duration:1200\n            });\n          }else{\n            this.loading = false;\n            //请求成功后跟换路径，跳转路由\n            this.$router.push({ path: '/Card' });\n          }\n        })\n      }\n    }\n  }\n```","tags":["vue2.0"],"categories":["Vue开发"]},{"title":"搭建项目","url":"%2F2018%2F07%2F02%2FVue--%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F","content":"#### 在使用vue搭建项目之前，要安装所需依赖\n+ 安装 `nodejs`\n+ 安装 `webpack`:`$ npm install webpack -g`\n+ 安装 `vue-cli`:`$ npm install vue-cli -g`\n> 鉴于国内网络限制，可以选择切换镜像源\n`npm install -g cnpm --registry=https://registry.npm.taobao.org`\n> `npm install`不推荐使用国内镜像\n\n\n#### 初始化项目文件\n+ 创建一个名为“Abc”的初始化文件夹 `\tvue init webpack Abc` \n+ 如果已经提前建好了文件夹，则只需在该文件夹内 `vue init webpack`\n+ 如果`node_modules`没有安装，则`npm install`\n+ 使用`npm run dev`启动\n\n\n#### 配置路由\nvue适合用来构建SPA应用，所以路由嵌套很正常。\n在入口页面**App.html**中，`router-view`是路由区域。单页面的切换就在该区域。  <copy>\n```html\n<template>\n  <div id=\"app\">\n    <transition name=\"fade\"\n                mode=\"out-in\">\n      <router-view></router-view>\n    </transition>\n  </div>\n</template>\n```\n#### 引入路由组件(**src / router / index.js**)  <copy>\n```js\n//依赖\nimport Vue from 'vue'\nimport Router from 'vue-router'\n//主路由\nimport Main from '@/components/Main'\n//分路由\nimport Login from '@/components/Login'              //登录页面\nimport Card from '@/components/pages/Card'          //学籍卡片\n```\n#### 设置路由的跳转(**src / router / index.js**)  <copy>\n```js\nexport default new Router({\n  // mode: 'history',\n  routes: [\n    {path: '*',\n      hidden: true,\n      redirect: { path: '/404' }  //重定向404\n    },\n    {\n      path: '/login',             //路径\n      component: Login,           //组件\n      name:'',\n    },\n    {\n      path: '/404',             \n      component: notFound,\n      name:'',\n    },\n    {\n      path: '/',\n      leaf: true,\n      icon:'icon-myschedule',    //参数，传递给路由页面进行渲染\n      iconColor:'#d10dff',\n      component: Main,\n      main:true,\n      name:'',\n      children:[\n        { path: '/Plan', component: Plan, name: '培养方案' }\n      ]\n    }\n  ]\n})\n```\n#### 链接跳转(**src / components / xx.vue**)  <copy>\n```html\n  <div class=\"hello\">\n    <router-link to=\"/\"></router-link>\n    <!--使用to来跳转，对应路由文件里面的path-->\n  </div>\n```\n> 获取路由参数：`v-for=\"(item,index) in $router.options.routes`\n  使用参数：`item.children[n].path`","tags":["vue2.0"],"categories":["Vue开发"]},{"title":"Vuex","url":"%2F2018%2F07%2F02%2FVue--Vuex%2F","content":"\nvuex是数据仓库，同时也是状态管理器\n#### 使用方法\n新建js文件\n![](https://miao.su/images/2018/07/04/vuex1684a3.png)\n写入store.js   <copy>\n```js\n//引入依赖\nimport  Vue from 'vue';\nimport  Vuex from 'vuex';\nVue.use(Vuex);\n\nconst state ={  //state是状态\n  count:1       //count是公用的数据，放在状态里面\n};\n//暴露出去\nexport default new Vuex.Store({\n  state\n})\n```\n在组件中使用（**app.vue**）   <copy>\n```html\n<!-- 使用$.store.state获取状态 -->\n<h2>{{message}}</h2>\n<h3>这是数据仓库的值：{{$.store.state.count}}</h3>\n```\n**①**使用`computed`简化指令（**app.vue**）  <copy>\n```js\ncomputed:{   //computer用于临时计算，返回一个对象\n  count(){   //这里把count的值指向为  this.$store.state.count\n    return this.$store.state.count\n  }\n}\n```\n现在，`count`的值就有了，而且指向为`this.$store.state.count `\n这个时候就可以这么写   <copy>\n```html\n<h3>这是数据仓库的值：{{$store.state.count}}--{{count}}</h3>\n```\n**②**使用`mapState`简化指令（**app.vue**）\n引入和添加（**app.vue**）   <copy>\n```js\n//引入mapState\nimport {mapState} from 'vuex'\n//添加方式\ncomputed:mapState(['count'])\n```\n\n\n#### 改变数据的值\n通过mutations来改变state里面的值(**store / vuex.js**)   <copy>\n```js\nconst mutations = {\n  add(state,n){    //第一个是状态参数，第二个是自定义参数\n    state.count+=n;\n  }\n};\n//把状态和方法都暴露出去\nexport default new Vuex.Store({\n  state,mutations\n})\n```\n在组件里接收数据（**app.vue**）   <copy>\n```js\nimport store from  '@/vuex/store';  //接收数据\nimport { mapState,mapMutations } from 'vuex';\n  export default {\n    data(){\n      return {\n        message:'hello world'\n      }\n    },\n    store,  //接收数据\n    methods:mapMutations([\n        'add','reduce'\n    ]),\n  }\n```\n使用数据（**app.vue**）   <copy>\n```html\n<h3>{{count}}</h3>\n<button @click=\"$store.commit('add',10)\">增加</button>\n<!--只能通过 $store.commit（）调用方法--\n```\n\n\n","tags":["vue2.0"],"categories":["Vue开发"]},{"title":"弹窗组件","url":"%2F2018%2F06%2F14%2FTX--%E5%BC%B9%E7%AA%97%E7%BB%84%E4%BB%B6%2F","content":"\n为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。\n\n#### 在文档底部添加引用  <copy>\n```js\n<script src=\"//ossweb-img.qq.com/images/js/comm/showDialog.min.js\"></script>\n```\n#### 结构  <copy>\n```html\n<div class=\"pop\" id=\"\">\n <a href=\"javascript:showDialog.hide()\" class=\"close\" onclick=\"PTTSendClick('btn','close','关闭弹窗');\"></a>\n</div>\n```\n> 弹窗的高度一般不要超过`550px`\n为每一个弹窗添加特定的`id`,方便调用以及更改样式\n写样式之前，对弹窗相同样式进行抽取，**具体到不同的弹窗具体修改**\n\n参考代码如下:   <copy>\n```css\n/*------popCom------*/\n.pop{\n  position: relative;\n  display: none;\n  overflow: hidden;\n  width: 6.6rem;\n  margin-left: -3.3rem !important;\n  text-align: center;\n  background: url(ossweb-img/pop-bg.png) repeat;\n}\n.pop .close{\n  position: absolute;\n  top: 0.2rem;\n  right: 0.2rem;\n  width: 0.26rem;\n  height: 0.26rem;\n  background: url(ossweb-img/close.png) no-repeat center;\n  background-size: 100%;\n}\n/* ways */\n#ways{\n  height: 3.6rem;\n}\n#ways .title{\n  margin-top: 0.65rem;\n}\n```\n#### 显示弹窗   <copy>\n\n```js\nshowDialog.show('id');  //对于不同弹窗，更换不同的id即可\n```\n#### 隐藏弹窗   <copy>\n```js\nshowDialog.hide();\n```\n#### 是否可滚屏\n\n当弹窗出现时屏幕是否可以滚动，取决于客户需求，参看代码   <copy>\n```js\n$('body,html').css('overflowY', 'hidden'); //隐藏滚动条，弹窗初始化启用\n$('body,html').css('overflowY', 'auto');   //显示滚动条，弹窗关闭后启用\n```","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"flex布局","url":"%2F2018%2F06%2F05%2FCSS--flex%E5%B8%83%E5%B1%80%2F","content":"弹性布局是未来布局的发展趋势，现代浏览器均对flex实现了不同程度的支持，但是如果要兼容老版本的浏览器，则还是应该回归原始的布局方式。\n\n#### 基本概念\n+ 容器和项目\n\n弹性布局的实现需要一个容器，也就是flex容器。只要把父元素的`display`设置为`flex`，则他的子元素就全部成为了flex项目\n+ 主轴和交叉轴\n\n主轴（`main axis`）处于水平方向，是`x`轴。起点叫`main start`，终点叫做`main end`。\n交叉轴（`cross axis`）处于垂直方向，是`y`轴。起点叫`cross start`，终点叫做`cross end`。\n![](http://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png)\n\n#### 容器属性\n\n+ `flex-direction`  <copy>\n该属性决定项目的拍排列方向,有:\n水平方向：`row`（从左到右），`row-reverse`（从右到左）;\n垂直方向：`column`（从上到下），`column-reverse`（从下到上）\n```css\n.box{\n  flex-direction: column|column-reverse|row|row-reverse;\n}\n```\n![](https://miao.su/images/2018/06/05/0cbe5f8268121114e87d0546e53cda6e2131a.png)\n\n### `flex-wrap`\n改属性决定了项目溢出容器时候的处理方式，默认是自动收缩不换行（`nowrap `）\n不换行，水平方向自动收缩：`nowrap`\n![](https://miao.su/images/2018/06/05/nowrap18e54.png)\n换行：`warp`\n![](https://miao.su/images/2018/06/05/wrap95d91.png)\n换行之后反向：`wrap-reverse`\n![](https://miao.su/images/2018/06/05/wrap-reverse6c2a3.png)\n\n> 如果设置了项目的宽度，并且项目的`总宽度之和>容器的宽度`，在设置了不换行`nowarp`的情况下，`项目宽度`会被`自动压缩`，不超过容器范围\n\n+ `flex-flow`\n是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。\n优先使用这个属性。\n\n+ `justify-content` \n该属性决定项目在主轴(`x轴`)上的对其方式  <copy>\n```css\n.box{\n   justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n![](https://miao.su/images/2018/06/05/wsdsaa727.png)\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n+ `flex-start（默认值）`：左对齐\n+ `flex-end`：右对齐\n+ `center`： 居中\n+ `space-between`：两端对齐，项目之间的间隔都相等。\n+ `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n+ `align-items`   <copy>\n该属性决定项目在交叉轴(`y轴`)上的对其方式 \n```css\n.box{\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n![](https://miao.su/images/2018/06/05/baseline1286d.png)\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n+ `flex-start`：交叉轴的起点对齐。\n+ `flex-end`：交叉轴的终点对齐。\n+ `center`：交叉轴的中点对齐。\n+ `baseline`: 项目的第一行文字的基线对齐。\n+ `stretch（默认值）`：如果项目未设置高度或设为auto，将占满整个容器的高度。\n<div class=\"tip\">\n    尤其要注意，如果项目没有设置具体高度，那么他会默认`填充满容器`\n</div>\n\n+ `align-content`\n多轴属性，当换行的时候，会有多个主轴或者交叉轴的存在。该属性和主轴对其方式是一致的。  <copy>\n```css\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n![](https://miao.su/images/2018/06/05/js64812.png)\n\n\n#### 项目属性\n+  `order`\n排列顺序。数值越小，排列越靠前，默认为0  <copy>\n```css\n.flex-item {\n  order: <integer>;\n}\n```\n+ `flex-grow`\n放大比例，默认为0，即如果存在剩余空间，也不放大  <copy>\n```css\n.flex-item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n > 如果一个项目的`flex-grow`属性为`2`，其他项目都为`1`，则前者占据的剩余空间将比其他项多一倍。\n\n+ `flex-shrink`\n缩小比例，默认为1，即如果空间不足，该项目将缩小  <copy>\n```css\n.flex-item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n负值对该属性无效。\n+ `flex-basis`\n分配多余空间之前，项目占据的主轴空间（`main size`），也就是固定宽度  <copy>\n```css\n.flex-item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n+ `flex`\n 是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值`0 1 auto`。后两个属性可选\n### `align-self`\n 单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性\n![](https://miao.su/images/2018/06/05/TIM201806051153463325d.png)\n\n#### 小实例\n用弹性布局实现百分比高度的文字垂直居中\n<iframe width=\"100%\" height=\"160\" src=\"http://jsrun.net/LSZKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe></body>\n考虑到浏览器的兼容性差异，最好flex相关属性都加上浏览器内核前缀\n","tags":["css"],"categories":["css世界"]},{"title":"兼容措施","url":"%2F2018%2F06%2F05%2FCSS--%E5%85%BC%E5%AE%B9%E6%8E%AA%E6%96%BD%2F","content":"\n\n#### 透明度`opcaity` <copy>\n\n```css\n.ele{\n  opacity: 1;\n  filter: progid:DXImageTransform.Microsoft.Alpha(opacity=100);  \n}\n\n/*支持grba*/\n　.ele{\n       background:rgba(0,0,0,0.5); \n　　　　filter:progid:DXImageTransform.Microsoft.gradient(startcolorstr=#7F000000,endcolorstr=#7F000000);\n }　　　\n/*\n　　//rgba透明值：  0.1　　0.2　　0.3　　0.4　　 0.5　　0.6　　0.7　　0.8　　0.9\n　　//IE下filter值：19　　 33　　 4c　　 66　　  7f　　 99　　 b2　　 c8　　  e5\n*/\n\n```\n\n#### 让ie低版本支持`inlline-block` <copy>\n\n```css\n.ele{\n  display: inline-block;\n  *display: inline;\n  *zoom: 1\n}\n```\n\n#### 解决Chrome在应用transition时页面闪动的问题？ <copy>\n\n```css\n-webkit-transform-style:preserve-3d;\n/* 或者 */\n-webkit-backface-visibility:hidden;\n```\n\n#### 解决移动端的滑动事件总是出现无法侦听被动事件\n\n在使用有些移动端插件时，如果使用了滑动事件，可能会报错 <copy>\n\n`Unable to preventDefault inside passive event listener due to target being treated as passive`\n\n```css\n* { touch-action: none; }\n```\n\n\n#### 控制文字超出省略（移动端） <copy>\n```css\ndisplay: -webkit-box;\n-webkit-box-orient: vertical;\n-webkit-line-clamp: 3;   /*只显示三行*/\noverflow: hidden;\n```\n\n#### 解决tr、th设置border失效  <copy>\n```css\n/*因为table的border覆盖了tr、th的border*/\ntable{\n    border-collapse: collapse;\n}\n\n```\n\n#### 解safari滚动卡顿\n\n```css\n.main{\n      overflow-y: scroll;\n      -webkit-overflow-scrolling: touch;\n}\n```\n\n#### 修改滚动条样式\n```css\n\n/* 高度或宽度是缺省值 */\n.CLASSSTYLE::-webkit-scrollbar {\n    width: 8px;\n    height: 8px;\n}\n```\n`::-webkit-scrollbar `滚动条整体部分  \n`::-webkit-scrollbar-thumb ` 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）  \n`::-webkit-scrollbar-track`  滚动条的轨道（里面装有Thumb）  \n`::-webkit-scrollbar-button` 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。  \n`::-webkit-scrollbar-track-piece` 内层轨道，滚动条中间部分（除去）  \n`::-webkit-scrollbar-corner` 边角，即两个滚动条的交汇处  \n`::-webkit-resizer` 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件  \n\n\n#### 改变文字选中的样式\n```css\nfigure::selection {\n    background: #95fff1;\n}\nfigure::-moz-selection{\n    background: #95fff1;\n}\n```\n\n#### 判断是ipx\n\n```css\n@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio:3) {\n}\n```\n\n#### 禁止移动端浏览器上下反弹\n\n```js\ndocument.addEventListener('touchmove', function(event){\n    event.preventDefault();\n}, {\n    passive: false\n});\n```\n\n\n\n","tags":["css"],"categories":["css世界"]},{"title":"逐帧动画","url":"%2F2018%2F06%2F05%2FCSS--%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB%2F","content":"#### 实现逐帧动画\n```css\n@-webkit-keyframes sprite-slogan {\n    0% {\n        background-position-y: 0\n    }\n\n    100% {\n        background-position-y: -10800px\n    }\n\n}\n.page-index .slogan {\n    position: absolute;\n    width: 280px;\n    height: 450px;\n    bottom: 297px;\n    left: 50%;\n    margin-left: -146px;\n    background: url(https://qn.res.netease.com/pc/zt/20171127103634/img/slogan_d959a8a.png) no-repeat;\n    z-index: 10;\n    -webkit-animation: sprite-slogan 2s steps(24) infinite;\n    -moz-animation: sprite-slogan 2s steps(24) infinite;\n    -ms-animation: sprite-slogan 2s steps(24) infinite;\n    animation: sprite-slogan 2s steps(24) infinite\n}\n\n```\n> 暂停动画`animation-play-state: paused;`\n","tags":["css"],"categories":["css世界"]},{"title":"视频弹窗","url":"%2F2018%2F03%2F15%2FTX--%E8%A7%86%E9%A2%91%E6%8F%92%E4%BB%B6%2F","content":"\n为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。\n\n\n#### PC视频\n+ 引用视频组件   <copy>\n\n```html\n<script src=\"//ossweb-img.qq.com/images/js/comm/showDialog.min.js\"></script>\n<script src=\"//vm.gtimg.cn/tencentvideo/txp/js/txplayer.js\"></script>\n```\n\n+ 结构样式及调用 \n\n   +  html    <copy>\n    ```html\n      <!-- 视频弹窗 -->\n    <div class=\"pop\" id=\"vindex-play\">\n      <span class=\"btn-pop-close\" onclick=\"hideVideo();\" title=\"点击关闭\" onclick=\"PTTSendClick('btn','close','关闭弹窗');\">×</span>\n      <div class=\"pop-con\" id=\"vplay-con\" style=\"padding-top: 0\"></div>\n    </div>\n    ```\n      + css   <copy>\n\n   ```css\n   /*--------video---------*/\n   #vindex-play {position:relative;display: none;width:800px;height:500px;padding-top: 0;border:2px solid #e9d7a5;background: none;}\n   #vindex-play .btn-pop-close{position:absolute;top:-2px;right:-41px;display:block;width:40px;height:40px;cursor: pointer;text-align:center;text-decoration: none;color:#fff;background-color: #e9d7a5;font-family:Tahoma;font-size:30px;line-height:36px;}\n   #vindex-play .btn-pop-close:hover {text-decoration:none;color:#fff;}\n   #vindex-play .pop-con,#vindex-play .pop-con .tenvideo_player{width: 800px;height: 500px;}\n   ```\n\n  + html    <copy>\n       ```js\n       // pc视频弹窗方法\n       function playVideo(e,vid) {\n         showDialog.show({id:e});  //e为弹窗,vid为视频编码\n         var player = new Txplayer({\n           containerId: 'vplay-con',\n           vid: vid,\n           width: '100%',\n           height: '100%',\n           autoplay: false\n         });\n       }\n       // 关闭pc视频弹窗方法\n       function hideVideo() {\n         var flv_s = document.getElementById(\"vplay-con\");\n         if (flv_s){\n           flv_s.innerHTML= \"\";\n         }\n          showDialog.hide();\n       }\n       \n       ```\n  + 调用 <copy>\n\n       ```JS\n       onclick=\"playVideo('vindex-play','q0625wf8pcn')\"\n       ```\n\n#### H5视频\n+ 引用视频组件\n\n    ```html\n    <script src=\"//ossweb-img.qq.com/images/js/comm/showDialog.min.js\"></script>\n    <script src=\"//imgcache.gtimg.cn/tencentvideo_v1/tvp/js/tvp.player_v2.js\" charset=\"utf-8\"></script>\n    ```\n\n+ 结构样式及调用\n\n    + html\n    ```html\n    <!-- 视频弹窗 -->\n    <div id=\"videoPlayer\" class=\"video_player\"></div>\n    <i id=\"videoClose\" class=\"video_close\">×</i>\n    ```\n\n    + css\n\n    ```css\n    /--------video---------/\n    .video_player {position: fixed;z-index: 10011;top: 0;left: 0;display: none;width: 100%;height: 100%;background: #000;}\n    .video_close {position: fixed;z-index: 10014;top: 2%;right: 4%;display: none;width: 0.4rem;height: 0.4rem;text-align: center;color: #0091de;background: #000;font-size: 0.8rem;font-weight: 700;line-height: 0.6rem;}\n    ```\n    + js\n\n    ```js\n    //视频\n    var showVideo = function(vid){\n      var video = new tvp.VideoInfo();\n      video.setVid(vid);  //视频码\n      var player = new tvp.Player();\n        player.create({\n        width:\"100%\",\n        height:\"100%\",\n        video:video,\n        modId:\"videoPlayer\",\n        isHtml5UseAirPlay:true,\n        isHtml5UseFakeFullScreen:true,\n        autoplay:false\n      });\n        ('#videoPlayer').show();\n        ('#videoClose').show();\n    };\n    $('#videoClose').on(\"click\",function(){\n      $('#videoPlayer').hide().html(\" \");\n      $('#videoClose').hide();\n    });\n    ```\n\n    + 调用\n\n    ```js\n    onclick=\"showVideo('r0539nr9q6d');\"\n    ```\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"H5端构建","url":"%2F2018%2F03%2F14%2FTX--%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F","content":"\n\n#### 结构样式\n为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。\n+  html  <copy>\n\n```html\n<div class=\"part part1\"></div>\n<div class=\"part part2\"></div>\n```\n\n+  css  <copy>\n\n```css\n.part1{height: 3rem;background: url() no-repeat center;}\n.part2{height: 3rem;background: url() no-repeat center;}\n.part{position: relative;width: 7.5rem;overflow: hidden;background-size: 100%;}\n```\n\n## 组件上报  <copy>\n\n```js\nontouchend=\"PTTSendClick('btn','back','返回官网')\"\n```\n\n#### 分离路径\n传奇霸业:`//game.gtimg.cn/images/cqby/cp/a20180223bsdm/`\n御龙在天:`//game.gtimg.cn/images/ylzt/cp/a20180124jymtm/`\n传奇世界:`//game.gtimg.cn/images/cqsj3d/cp/a20180223bsdm/`\n梦幻诛仙:`//game.gtimg.cn/images/mhzx/cp/a20180418gcwfm/`\n轩辕传奇:`//game.gtimg.cn/images/xycq/cp/a20180423jyxtm/`\nQQ炫舞: `//game.gtimg.cn/images/x5m/cp/a20180516bbztm/`\n#### 链接跳转\n传霸官网:`//shuang.qq.com/m/`\n御龙官网:`//ylzt.qq.com/m/`\n传世官网:`//3d.qq.com/`\n[传世兴趣部落](//buluo.qq.com/p/barindex.html?bid=399251) /[传世游戏论坛](//bbs.g.qq.com/forum-57808-1.html) /[传世公众号](//game.weixin.qq.com/cgi-bin/comm/openlink?noticeid=90127011&appid=wx96a8b9ae096de54d&url=https%3A%2F%2Fgame.weixin.qq.com%2Fcgi-bin%2Fh5%2Fstatic%2Fsubscribe%2Findex.html%3Fappid%3Dwx96a8b9ae096de54d#wechat_redirect) /[传世微博](//weibo.com/u/6077836537?refer_flag=1001030101_ )\n梦诛官网:`//mhzx.qq.com/m/`\n轩辕官网:`//xycq.qq.com/m/`\n炫舞官网:`//x5m.qq.com/m/m201711/`\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"微区构建","url":"%2F2018%2F03%2F13%2FTX--%E5%BE%AE%E7%A4%BE%E5%8C%BA%2F","content":"\n####  结构样式\n为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。\n+  html  <copy>\n```html\n<div class=\"wrapper\">\n    <div class=\"part part1\"></div>\n    <div class=\"part part2\"></div>\n</div>\n```\n\n+  css  <copy>\n```css\n.wrapper,.part{position:relative;margin: 0 auto;overflow: hidden;background-size: 100%;width:7.5rem; }\n.part1{height: 2rem;background: url() no-repeat center top}\n.part2{height: 3rem;background: url() no-repeat center top}\n```\n\n#### 组件上报  <copy>\n```js\nontouchend=\"PTTSendClick('btn','back','返回官网')\"\n```\n\n#### 分离路径 \n御龙在天:`//game.gtimg.cn/images/ylzt/ingame/cp/a20180604sxfylig/ `\n梦幻诛仙:`//game.gtimg.cn/images/mhzx/ingame/cp/a20180604sxfylig/`\nQQ炫舞: `//game.gtimg.cn/images/x5m/ingame/cp/a20180604sxfylig/`\n\n#### 链接跳转\n御龙官网:`//ylzt.qq.com/ingame/all/`\n梦诛官网:`//mhzx.qq.com/ingame/all/`\n炫舞官网:`//x5m.qq.com/ingame/all/`\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"PC端构建","url":"%2F2018%2F03%2F11%2FTX--PC%E7%AB%AF%2F","content":"\n\n####  结构样式\n为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。\n+ html  <copy>\n```html\n<div class=\"part part1\">\n  <div class=\"content\"></div>\n</div>\n```\n\n+ css <copy>\n```css\n/*---sect---*/\n.part{position: relative;min-width: 1180px;}\n.content{position: relative;overflow: hidden;width: 1180px;margin: 0 auto;}\n.part1{background: url(ossweb-img/part1.jpg) no-repeat center top;}\n.part2{background: url(ossweb-img/part2.jpg) no-repeat center top;}\n.part1 .content{height: 650px;}\n.part2 .content{height: 491px;}\n```\n\n#### 组件上报  <copy>\n```js\nonclick=\"PTTSendClick('btn','back','返回官网')\"\n```\n\n#### 分离路径 \n传奇霸业:`//game.gtimg.cn/images/cqby/cp/a20180223bsd/`\n御龙在天:`//game.gtimg.cn/images/ylzt/cp/a20180223bsd/`\n传奇世界:`//game.gtimg.cn/images/cqsj3d/cp/a20180223bsd/`\n梦幻诛仙:`//game.gtimg.cn/images/mhzx/cp/a20180223bsd/`\n轩辕传奇:`//game.gtimg.cn/images/xycq/cp/a20180223bsd/`\nQQ炫舞: `//game.gtimg.cn/images/x5m/cp/a20180223bsd/`\n#### 链接跳转\n传霸官网:`//shuang.qq.com/`\n御龙官网:`//ylzt.qq.com/`\n传世官网:`//3d.qq.com/`\n梦诛官网:`//mhzx.qq.com/`\n轩辕官网:`//xycq.qq.com/`\n炫舞官网:`//x5m.qq.com/web201711/main.shtml`\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"分享蒙层","url":"%2F2018%2F03%2F11%2FTX--%E5%88%86%E4%BA%AB%E8%92%99%E5%B1%82%2F","content":"\n#### 使用说明\n针对移动设备浏览方式的差异，分为两种分享方式：右上角和下方\n对浏览方式进行判断然后选用适合的蒙层\n\n#### 结构   <copy>\n```html\n<!-- 右上角分享蒙层 -->\n<div class=\"share share-right\">\n  <img src=\"share.png\" alt=\"share\" class=\"share-icon\">\n  <p>点击右上角分享给好友</p>\n</div>\n<!-- 下方分享蒙层 -->\n<div class=\"share share-down\">\n  <p>点击下方导航栏,分享给好友</p>\n</div>\n```\n\n#### 样式  <copy>\n```css\n/* share */\n.share{position: fixed;z-index: 2;top: 0;display: none;width: 100%;height: 100%;text-align: center;color: white;background: rgba(12, 12, 12, 0.91);font-size: 0.4rem;}\n.share-right p{margin-left:25%;}\n.share-right img.share-icon {width: 1.42rem; margin: 12% 0 0 58%;}\n.share-down p{margin-top: 90%;font-size: 0.35rem;}\n```\n#### 判断方法\n展开和关闭  <copy>\n```js\n//判断分享类型\nvar ua = navigator.userAgent.toLowerCase();\nif ((ua.match(/MicroMessenger/i) == 'micromessenger') || (ua.match(/QQ/i) == \"qq\") || (ua.match(/WeiBo/i) == \"weibo\")) {\n  $('.share-right').show();\n} else {\n  $('.share-down').show();\n}\n//关闭蒙层\n$.each(['.share-right', '.share-down'], function(index, value) {\n  $(value).click(function(event) {\n    $(this).hide();\n  });\n});\n```\n#### 分享图标\n\n[跳转下载](http://miao.su/images/2018/04/19/share173a4.png)","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"浅拷贝和深拷贝","url":"%2F2017%2F10%2F22%2FJS--%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F","content":"区别主要在于**内存中的存储类型**不同。一般分为堆和栈两种存储区域。\n\n> 栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。\n\n#### ECMAScript 的数据类型\n\n+ 基本数据类型（null，undefined，number，string，boolean）\n\n  他们都存储在栈中，**值不可变**；\n\n  他们之间比较是值的比较，只要值相等就认为他们相等，实际工作中最好使用`==`判定\n\n+ 引用类型（obejct）\n\n  对象类型就是引用类型，包括有特殊对象数组；\n\n  存放在堆内存中的，变量实际上是一个存放在栈内存的**指针**，这个指针指向**堆内存中的地址**；\n\n  引用类型**值可变**；\n\n  两个对象之间的比较其实是**引用类型的比较**，判断其引用是否指向同一个对象；\n\n  ```js\n  var a = [1,2,3];\n  var b = [1,2,3];\n  console.log(a === b); // false\n  ```\n\n#### 传值与传址\n\n基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中,所以相互之间**独立不受影响**。\n\n引用类型的赋值是传址。只是**改变指针的指向**。引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响\n\n#### 浅拷贝实现\n\n+ `Object.assign(target, ...sources)` 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象\n\n  ```js\n  var obj = { a: 1 };\n  var copy = Object.assign({}, obj);\n  console.log(copy); // { a: 1 }\n  ```\n\n+ `{...obj}`展开运算符\n\n  ```js\n  var arr = [1,2,3];\n  var arr2 = [...arr]; // 和arr.slice()差不多\n  arr2.push(4)\n  ```\n\n> 对于数组的拷贝，一般情况下`Array.prototy`里面内置的方法会返回一个数组，所以也是一种拷贝\n\n#### 深拷贝的实现\n\n+ 不完全深拷贝（`JSON.sringify `和` JSON.parse` ）\n\n  将对象转换为字符串，再通过字符串重新建立一个对象\n\n  ```js\n  let obj = {\n      a: 1,\n      b: {\n      b1: 1,\n      b2: 2\n  \t}\n  };\n  let cp = JSON.parse(JSON.stringify(obj));\n  console.log(cp); //{a: 1, b: {b1:1,b2:2}}\n  ```\n  改方法存在局限性，尤其注意以下情况:\n\n  + 不能复制function、正则、Symbol\n  + 循环引用报错\n  + **相同的引用会被重复复制**\n\n+ 完全的深拷贝\n\n  思路就是写一个拷贝函数，递归调用。对于简单类型，直接复制。对于引用类型，递归复制它的每一个属性。\n\n  ```js\n  function deepCopy(target){ \n  let copyed_objs = [];//此数组解决了循环引用和相同引用的问题，它存放已经递归到的目标对象 \n      function _deepCopy(target){ \n          if((typeof target !== 'object')||!target){return target;}\n          for(let i= 0 ;i<copyed_objs.length;i++){\n              if(copyed_objs[i].target === target){\n                  return copyed_objs[i].copyTarget;\n              }\n          }\n          let obj = {};\n          if(Array.isArray(target)){\n              obj = [];//处理target是数组的情况 \n          }\n          copyed_objs.push({target:target,copyTarget:obj}) \n          Object.keys(target).forEach(key=>{ \n              if(obj[key]){ return;} \n              obj[key] = _deepCopy(target[key]);\n          }); \n          return obj;\n      } \n      return _deepCopy(target);\n  ```\n\n\n\n  > `typeof` 基本上只用来判断 `undefiend` 和 `function`\n\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"call和apply","url":"%2F2017%2F09%2F22%2FJS--call%20%E5%92%8C%20apply%2F","content":"\n每个函数都有`call`和`apply`方法，可以用来改变this的指向，或者说，用`call`和`apply`来帮助对象，去调用某个函数的方法\n\n#### 使用场景\n比如某个对象想用它本身没有的方法，但是又不想重写，就可以使用`call`和`apply`去调用其他函数的方法 <copy>\n\n```js\n Array.prototype.slice.call(arguments)\n```\n这时候的`this`并不是一个`Array`，因为需要借用`Array`类的方法，所以使用了`call`\n\n再来看一个栗子： <copy>\n\n```js\nvar cat = {\n  object:'怪兽'\n}\nvar superman ={\n  object:'鱼'\n}\nsuperman.beat = function () {\n  console.log(this.object);\n}\n//猫调用superman的beat的方法，但是它本身是没有这个方法的\nsuperman.beat.call(cat);\n```\n\n#### 作用总结\n所以其实`call`和`apply`有两个作用\n> ① 改变this的指向\n> ② 让某个对象不用重写方法去调用其他对象的方法\n\n换个层面来说，其实，当一个函数作为一个对象的方法被调用的时候，`this`指向的就是这个对象，比如说 <copy>\n\n```js\nvar cat ={\n  speak:function () {\n    console.log('我是猫的方法');\n  }\n}\ncat.speak()\n```\n\n所以，当使用`apply`和`call`的时候，该对象就有了新的方法。所以，为什么会改变`this`的指向，其实和上面的一样，函数作为这个对象的方法调用了 <copy>\n\n```js\nsuperman.beat.call(cat);\n//相当于\ncat.beat()\n//所以this就指向了cat对象\n```\n\n最后看一个栗子加深理解 <copy>\n\n```js\nvar a = 3;\nvar cat ={\n  a:1\n}\nvar ani = function () {\n  console.log(this.a);\n}\nani();   //3  直接调用，this指向window\nani.apply(cat)  //1  作为cat的方法调用，this指向对象cat\n```\n\n\n\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"关于对象","url":"%2F2017%2F09%2F22%2FJS--%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%2F","content":"\njs中有普通对象和函数对象。\n\n##### 普通对象\n\n都是 `created by Object`，继承了`Object.prototype`对象，所以普通对象从创建开始就有了对象（`Object.prototype`）的方法。\n\n那普通的对象的父类`Object`函数，它是`Function`函数创造的，即是 `created by Function`，所以他继承了`Function.prototype`对象。\n\n所以，普通的对象的父对象`Object`有自己的属性（来源于`Function.prototype`，不可以继承），和可以继承的属性（`Object.prototype`）\n\n> 他`Object.prototype`对象，继承了空对象 `null`\n\n##### 函数对象\n\n函数对象都来源于`Function`，继承了`Function.prototype`，而`Function.prototype`又反过来继承了`Object.prototype`，所以函数对象就同时有了 `Function.prototype`和`Object.prototype`里面的属性和方法\n\n##### 原型链\n\n当我们在一个对象上查找是否具有某个属性或者方法时，会先在**对象自身属性上查找**（这里包括了自己定义的和继承的属性），如果没有查找到，那么就会沿着该对象`__proto__`是否有继承其他对象的`prototype`属性里面去查找，直到尽头`Object.prototype`\n\n> 关键点在于，一个函数对象的prototype，也可以改变和重新指定\n\n\n\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"数组型对象的实现","url":"%2F2017%2F09%2F22%2FJS--%E6%95%B0%E7%BB%84%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%2F","content":"\n在jQuery中，如果调用`$`函数访问一个元素，例如`  console.log($('div'));`，则会返回一个数组型对象。可以借助循环添加的方式实现 <copy>\n```js\nvar o = {};\narray = ['p','a']\nfor(i=0;i<array.length;i++){\n  o[i] = arry[i];\n}\no.length = array.length;\nconsole.log(o);\t\t//{0: \"p\", 1: \"a\", length: 2}\n```\n\n但是在[jQuery](https://jquery.com/)里面，是通过数组的`push`方法来实现的  <copy>\n\n```js\nvar o = {};\nvar arry = ['p','a'];\nArray.prototype.push.apply(o,arry)\nconsole.log(o);   //{0: \"p\", 1: \"a\", length: 2}\n```\n\n> 原来apply的this指向的是数组，现在转换为对象","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"常见的封装","url":"%2F2017%2F08%2F23%2FJS--%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%81%E8%A3%85%2F","content":"\n\n\n#### 命名空间（用对象的方式模拟）\n首先用对象字面量的方式创建一个命名空间\n\n```js\nvar Game = {};\n```\n\n添加模块，可以将相同功能或者属性的归类\n\n```js\nGame.module1 = {name:'p',m:function(){}};\n```\n<!--more-->\n然后调用这个模块\n\n```js\nGame.module1.m(); \n```\n\n可以用立即执行函数把这个命名空间包裹起来，这样可以减少变量冲突\n\n#### 伪类\n\njs没有块作用域，有函数作用域，把方法和属性卸载函数里面，可以减少变量冲突\n\n对于构造器函数，包含实例化属性，自身属性，继承属性 <copy>\n\n```js\nfunction Person(name) {\n    this.name = name;  \t\t\t  //实例化属性\n    this.public = function () {    //实例化属性\n        console.log('this指向实例化的对象')  \n    };\n    function private() {\n        console.log('这是私有的方法')  //自身属性\n    }\n}\nPerson.prototype = {     //继承属性\n  my:function () {\n      console.log('这是可以继承方法')   \n  }\n};\n```\n\n然后通过`new`实现继承 <copy>\n\n```js\nvar man = new Person('PETER');\nconsole.log(man.name);   \t\t//PETER\nconsole.log(man.public());  \t//this指向实例化的对象\nconsole.log(man.my());          //这是可以继承方法\nconsole.log(man.private());     //Uncaught TypeError\n```\n\n实际案例中，会用私有方法调用共有方法或者共有方法调用私有方法 <copy>\n\n```js\nfunction Person(name) {\n    this.name = name;\n    function pm() {\n        console.log(this.name)  //输出实例化对象的name\n    }\n    this.text = function () {\n        console.log('public method');\n        pm.call(this);  //绑定到是实例化的对象\n    }\n}\nthis.name = 1;\nvar man= new Person('peter');\nman.text();   //peter\n```\n\n#### 采用对象工厂的方式\n\n核心思路：定义一个人对象，函数返回一个对象 <copy>\n```js\nfunction Person(name) {\n    function pm() {\n        console.log(self.name) \t//------→\n    }                           //      |\n    var self ={                 //  ←---|\n        name:name,\n        text:function () {\n            console.log('publick method');\n            pm();\n        }\n    };\n    return self;   //这个函数会返回一个对象，也就是实例化的对象继承了这个对象里面的属性\n}\nvar man = new Person('oe');\nman.text();\n```","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"原型继承","url":"%2F2017%2F08%2F22%2FJS--JS%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%2F","content":"\n在js中，要想创建一个对象，不是通过实例化，而是通过**选择一个对象作为原型去克隆它**来达到目的。\n而且对象只能克隆函数对象里面的`prototype`属性，既是`Function.prototye`，由于只有函数才有`prototype`对象，所以，想要创建一个对象，就必须要用函数才能创建，这个函数通常被称为构造器函数。来看一下普通对象和函数对象的创建：\n```js\nvar cat= {};\nfunction demo(){}\n```\n对于`cat`，只是普通对象，是通过`Object`函数构造的,所以克隆了`Object`函数的`prototype`\n```\ncat == (克隆) Object.prototype\n```\n对于`demo`，是函数对象，比较高级，因为：\n+ 它通过`Function`函数构造，克隆了`Function`函数的`prototype`\n+ 同时，自己又是一个函数，也有自己的`prootype`，可以当作构造器被其他对象克隆\n\n```html\ndemo == (克隆) Function.prototype\n```\n重点来了，函数的`prototype`，是一个对象，那么这个对象也是从其他对象克隆过来的\n在`js`中，克隆根原型是`null`，其次是`Object.prototype`，也就是说，**js所有的对象，都是通过`Object.prototype`克隆而来的**\n![](https://miao.su/images/2018/07/04/proto91beb.jpg)\n上面这张图充分解释了js的原型继承概念，可以分几部去总结：\n+ 普通对象克隆了`Object.prototype`，函数对象克隆了`Function.prototype`\n+ `Object.prototype`的`Object`函数，它也克隆了`Function.prototype`\n+ `Function`对象克隆了自己的`prototype`\n+ `Function.prototype`这个对象，反过来克隆了`Object`函数的`Object.prototype`，所以最终的根克隆对象，其实就是`Object.prototype`，在它上面，是一个`null`，没有任何克隆的内容\n\n```js\n  console.log(Object.getPrototypeOf(Object)== Function.prototype);  //ture\n  console.log(Object.getPrototypeOf(Function.prototype)== Object.prototype);     //ture\n  console.log(Object.getPrototypeOf(Function)== Function.prototype);     //ture\n  console.log(Object.getPrototypeOf(Object.prototype)== null); //ture\n```\n\n#### 补充：对象和函数关系图\n\n![prototypea3e6d.jpg](https://miao.su/images/2019/02/11/prototypea3e6d.jpg)","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"继承","url":"%2F2017%2F08%2F22%2FJS--%E7%BB%A7%E6%89%BF%2F","content":"\n\n#### 通过ES5的 `Object.create`实现\n\n 创建父类\n\n```js\nfunction Parent() {\n}\nParent.prototype.headCount = 1;\nParent.prototype.eat = function () {\nconsole.log('eat')\n}\n```\n\n 创建子类  <copy>\n\n```js\nfunction Children() {\n}\nChildren.prototype.language = 'javascript';\nChildren.prototype.work = function () {\n    console.log('work')\n}\n```\n\n 建立关系，修正构造器 <copy>\n\n```js\nChildren.prototype = Object.create(Parent.prototype);\nChildren.prototype.constructor = Children;\n```\n\n 调整顺序 <copy>\n\n```js\n//父类\nfunction Parent() {\n}\nParent.prototype.headCount = 1;\nParent.prototype.eat = function () {\n    console.log('eat')\n};\n//关联修正，调整顺序\nChildren.prototype = Object.create(Parent.prototype);\nChildren.prototype.constructor = Children;\n//子类\nfunction Children() {\n}\nChildren.prototype.language = 'javascript';\nChildren.prototype.work = function () {\n    console.log('work')\n};\n```\n#### 自己写一个函数\n\n步骤也是先定义父类和子类，然后建立关系，修正顺序，不过建立关系函数有所变化 <copy>\n\n```js\nfunction creatEx(c,p) {\n    function F() {}\n    F.prototype = p.prototype;\n    c.prototype = new F();\n    c.prototype.constructor = c;\n}\n```\n\n> 对于函数的关联，思路是把`c.prototype`和`p.prototype`连接起来，然后通过new实例化c产生的对象久可以同时使用c和p的方法和属性\n\n#### 如果子类要访问父类中的动态变量，比如`this.name`，改如何解决？ <copy>\n\n```js\nfunction Parent(name) {\n    this.name = name\n}\nfunction Children(name) {\n\tParent.apply(this,arguments)  //调用Parent，同时this绑定为该Children函数\n}\n```\n\n![9ddcbfc21a1fbda1c58de.png](https://miao.su/images/2018/02/09/9ddcbfc21a1fbda1c58de.png)","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"minijquery的实现","url":"%2F2017%2F08%2F21%2FJS--minijQuery%E7%9A%84%E5%AE%9E%E7%8E%B0%2F","content":"\n```js\n(function () {\n  //暴露jquer出去。挂在到window对象上\n  var jQuery = window.jQuery = window.$ = function () {\n    //每次执行jquer函数，返回的是一个对象\n    //因此，可以通过返回实例属性达到目的\n    return jQuery.fn.init();\n    //这样每次执行jquery就会返回对象jQuery.prototype，因此可以访问jQuery.prototype里面的属性和方法，实现链式操作\n  }\n\n  //处理原型链，用fn代替怪异的prototype\n  jQuery.fn = jQuery.prototype = {\n    init:function () {\n      return this; //指向jQuery.prototype\n    },\n    jquery:'1.0.0'\n  }\n\n  //实现继承\n  jQuery.extend = jQuery.fn.extend = function () {}\n\n  //添加静态方法\n  jQuery.extend({});\n  //添加实例方法\n  jQuery.fn.extend({});\n\n})();\n```\n\n","tags":["jQuery"],"categories":["JS出深入浅"]},{"title":"arguments和重载","url":"%2F2017%2F08%2F21%2FJS--arguments%2F","content":"\n函数被调用的时候，会接收两个附加参数，`this`和`arguments`。\n\n`arguments`是一个对象。当`arguments`（实参）和`parameters`（形参）的个数不匹配时，不会导致错误，多余的实参会被忽略。  <copy>\n\n```js\nfunction cat(a,b) {\n    console.log(cat.length); \t\t//函数的形参个数\n    console.log(arguments.length);   //函数的实参个数\n}\n```\n\n#### 重载\n\n比如要实现一个求和的函数   <copy>\n\n```js\nfunction add() {\n  var ad = 0;\n  for(var i=0;i<arguments.length;i++){\n    ad += arguments[i];\n  }\n}\nadd(1,2,3); //6\n```\n#### 当实参类型不一样时候的处理\n\n假设有一段`p`标签。同时改变字体颜色大小等书写  <copy>\n\n```js\nfunction change() {\n  var  ele = document.getElementsByClassName('text')[0];\n  //如果时对象类型\n  if(typeof arguments[0] == 'object'){\n    for(key in arguments[0]){\n      ele.style[key] = arguments[0][key]\n    }\n  }else{\n    ele.style.fontSize = arguments[0];\n    ele.style.backgroundColor = arguments[1];\n  }\n}\nchange('44px','red')\nchange({fontSize:'44px',backgroundColor:'green'})\n```\n\n\n> 当一个对象属性是动态值的时候，不能通过`.`访问，只能通过`[]`访问\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"prototype 和 __proto__","url":"%2F2017%2F08%2F15%2FJS--prototype%20%E5%92%8C%20__proto__%2F","content":"\n####  关于`prototype`\n\n当一个新函数被创建时，会被赋予一个 `prototype`属性，这个属性是用来**存放继承特性**的地方\n**只有函数才有`prototype`**。\n\n```js\nvar Demo = function () {}\nconsole.log(Demo.prototype)  // {constructor: ƒ}\n```\n\n> 可以表示为 `Demo.prototype={constructor: ƒ}`\n\n因此我们可以对这个 `prototype`属性进行扩展，存放更多继承的特性，例如：\n\n```js\nDemo.prototype.call = function () {console.log('我是新增加的继承特性')};\nvar he = new Demo();  //Demo是构造器，he是构造函数，通过new连接\nhe.call();   //我是新增加的继承特性\n```\n\n> **但是要注意的是，因为是继承特性，如果直接调用**`Demo.call()`是不存在的\n>\n> **`Demo`函数不做继承的属性直接写，例如：`Demo.call = function(){}`**\n\n问题深入：JS是基于原型的语言\n\nJS中的对象都继承于`object.prototype`，所以，尽管JS实现了继承概念，但是单一的原型`object.prototype`未免丧失活力，因此JS提供了可以改变对象的原型，以达到继承属性的办法\n\n比如我们有一个Demo函数，其原型是`object.prototype`，现在，我们要改变他的原型以获得想要的属性\n\n```js\nvar obj = {name:2};       //定义一个我们想要继承的属性 ←--\nvar Demo = function () {};       //                  ↑\nDemo.prototype = obj;    //改变原型指向  -----------→ ↑\nvar he = new Demo();\t\nconsole.log(he.name)     //2   Demo原型成功指向了obj，大功告成\n```\n\n#### 关于`__proto__`\n\n`__proto__`可以用于检测**构造该对象的构造器**的原型，听起来有点绕口，结合上面的例子\n\n```js\nvar obj = {name:2};       //定义一个我们想要继承的属性 ←--\nvar Demo = function () {};       //                  ↑\nDemo.prototype = obj;    //改变原型指向  -----------→ ↑\nvar he = new Demo();\t//he是构造函数，Demo是构造器\nconsole.log(he.__proto__)     //{name: 2}\n```\n\n`he.__proto_`刚好等于构造器Demo的原型，换一种写法就是`he.__proto_ = Demo.prototype`\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"JS的解析与执行过程","url":"%2F2017%2F08%2F13%2FJS--JS%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F","content":"\n在JS真正执行代码之前，会对代码有个预处理过程\n\n#### 预处理阶段\n\n  + 首先创建**词法环境（这里是全局）**\n\n  + 把用**声明的方式**创建的函数和用**var定义的变量**扫描出来，把这些函数和变量的**名字**加到词法环境中（这里是全局）\n    ```js\n    // LexcialEnvironment (词法环境)\n    {\n        a:undefined,   //a是变量的名字，右边是值\n        f:对函数的引用,  //f是函数的名字，右边引用(函数声明的方式)\n        g:undefined     //g是函数的名字，右边引用(函数表达式创建的函数)\n    }\n    ```\n\n  > 声明函数 `function xx(){}`区别于函数表达式`var xx = function xx(){} `\n  >\n  > 用函数表达式创建的函数，在预处理阶段，函数名字也会被**加到词法环境**中，但是后面的值不会解析，返回`undefined`\n\n  -  处理**函数声明**有冲突，会**覆盖**\n\n    ```js\n    console.log(a);  //function a() {console.log(3);}\n    function a() {console.log(2);}\n    function a() {console.log(3);}\n    ```\n\n  -  处理**变量声明**有冲突，会**忽略**\n\n    ```js\n    console.log(a);  //function a() {console.log(3);}\n    function a() {console.log(2);}\n    function a() {console.log(3);}\n    var a = 2;   //因为处理变量a有冲突，规则是忽略\n\n    //可以把函数表达式也当作变量声明 var xx = function(){}\n    ```\n\n  >① **用var开头的变量或者函数都会被提升，加入到词法环境，值都是`undefined`**\n  >​② **`function a (){} `的形式，a被提升同时值是该函数引用**\n  >​③ **var 声明冲突会被忽略，function声明会覆盖**\n\n  ​\n\n#### 执行阶段\n\n  + 在执行阶段就会真正赋值（无论原来值是变量还是函数，都会被覆盖）\n  + 如果碰到在词法环境中找不到的名字，则会报错","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"this的用法","url":"%2F2017%2F08%2F10%2FJS--this%E7%9A%84%E7%94%A8%E6%B3%95%2F","content":"\n\nJavaScript的 `this` 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境\n\n除去不常用的` with` 和` eval` 的情况，具体到实际应用中， this 的指向大致可以分为以下 4种\n\n#### 作为对象的方法调用\n\n  此时`this`指向该对象  <copy>\n\n  ```js\n  var obj = {\n    a: 1,\n    getA: function(){\n      alert ( this === obj ); // 输出：true\n      alert ( this.a ); // 输出: 1\n    }\n  };\n  obj.getA();\n  ```\n\n#### 作为普通函数调用\n\n  指向全局对象，在浏览器的 JavaScript里，这个全局对象是 window 对象。  <copy>\n\n  ```js\n  window.name = 'globalName';\n  var getName = function(){\n  return this.name;\n  };\n  console.log( getName() ); // 输出：globalName\n  ```\n\n#### 构造器调用\n\n  当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 指向返回的这个对象  <copy>\n\n  ```js\n  var Cat = function (name) {\n      this.name = name\n  };\n  var white = new Cat(p);\n  console.log(white.name) //p\n  ```\n\n#### `call`或者`apply`调用\n\n  改变this的指向  <copy>\n\n  ```js\n  var cat = {\n      name:'p',\n      x:function () {\n          console.log(this.name)\n      }\n  };\n  var obj = {name:'o'};\n  cat.x.call(obj)  //o\n  ```\n\n  ​","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"关于闭包","url":"%2F2017%2F08%2F10%2FJS--%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%2F","content":"\n闭包就是能够读取其他函数内部变量的函数。\n\n> 在Js中，如果一个函数在另外一个函数中定义，那么这个函数会访问到父函数里面定义的成员，形成闭包。\n> 或者说，一个函数能访问它被创建时所处的上下文环境，就是闭包。\n\n主要有三点：\n\n+ 他是**函数中的函数**（无论嵌套多少层）\n+ 无论他是在父函数**内部调用**还是被`return`出去**外部接收后调用**，都能记住原来父函数的词法环境\n\n\n```js\n//函数在内部被调用\nfunction f1() {\n  var a = 2;\n  function f2() {\n    console.log(a)  //2\n  }\n  f2();   //内部执行，严格来说不算闭包，是词法作用域的查找方式，从内到外\n}\n\n//函数在外部被调用\nfunction f1() {\n  var a = 2;\n  return function f2() {\n    console.log(a)  //\n  }\n}\nvar x = f1();   //此时x等于return出来的f2\nx();    //2   这就是闭包，函数在外部被调用，但是函数还能记住创建他的词法环境\n```\n\n#### 闭包的作用\n\n+  减少全局变量，延续生命周期\n\n  ```js\n  //函数在外部被调用\n  function f1() {\n      var a =1;  \t\t\t//a在函数作用域里面，不会污染全局变量\n      return function () {\n          console.log(a++)\n      }\n  }\n  var result = f1();\n  result();\n  ```\n\n+ 减少传递给函数的参数数量\n\n+ 封装\n\n#### 使用闭包的注意点\n\n+ 对捕获的变量只是个引用，不是复制\n\n  ```js\n  function f1() {\n      var num = 1;\n      function f2() {\n          console.log(num)  //引用了num而不是复制\n      }\n      num++;\n      f2()\n  }\n  f1()   //2\n  ```\n\n+ 父函数每调用一次，会产生不同的闭包\n\n  ```js\n  function f1() {\n      var num = 1;\n      return function f2() {\n          num++;\n          console.log(num)\n      }\n  }\n  var result1 = f1(); \n  result1();  //2\n  result1();  //3\n\n  var result2 = f1();//result和result2虽然都是调用了f1,但是词法作用域是不相同的，不会互相影响\n  result2();  //2\n  result2();  //3\n  ```\n\n#### 循环中问题\n\n  ```js\n  for(var i =1;i<3;i++){\n      console.log(i); //1,2      //能实时打印i\n      setTimeout(function () {   //回调函数\n          console.log(i); //3,3  //程序加载完才执行，所以是3\n      },1000)\n  }\n\n  //解决方案，利用立即执行函数和闭包将参数传递进去\n  for(var i =1;i<4;i++){\n    (function (id) {\n      setTimeout(function () {\n        console.log(id)\n      },1000)\n    })(i)\n  }\n  ```\n\n  假设有一个需求，有三个按钮，以此点击发出ajax请求\n\n  ```html\n  <button id=\"1\">1</button>\n  <button id=\"2\">2</button>\n  <button id=\"3\">3</button>\n  ```\n\n  ```js\n  for(var i =1;i<4;i++){\n      var btn = document.getElementById(i);\n      btn.onclick = function () {\n          alert(i);  //回调函数不会马上执行  //4\n      }\n  }\n  ```\n\n  我们期望依次弹出1，2，3，但是结果全是三个4\n\n  因为for没有快作用域，i暴露在全局之中，回调函数执行时，循环已经结束，此时i=4；\n\n  解决方案，使用闭包，或者用let代替var\n\n  ```js\n  for(var i =1;i<4;i++){\n      var btn = document.getElementById(i);\n      btn.onclick = (function (id) {   //这是父函数，\n          return function () {   //闭包函数\n              alert(id);  //函数持续引用父函数里面传递的参数，形成闭包\n          }\n      })(i);\n  }\n  ```\n\n  > 其实解决思路就是，在回调函数没有执行之前，把想要的参数传递进去，这就可以使用闭包，让回调函数里面的函数，用return函数的方式，引用外部父函数传递的形参\n  >\n  > 为什么要使用立即执行函数？是因为i参数改变时，立即执行函数才能把实时参数传递进去\n  >\n  > 每次循环的时候，父函数带着想要传递的参数立即执行，因为有闭包的存在，子函数依赖与父函数传递的参数，所以子函数就能正确引用每次循环不同的i值","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"Gulp的实例参考","url":"%2F2017%2F06%2F12%2FGulp--%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F","content":"\n\n#### 基本插件的安装\n\nGulpJs的安装依赖nodejs，所以先安装nodejs\n\n打开nodejs里面的cmd文件，安装gulp全局变量\n\n```bash\nnpm install -g gulp\n```\n\n安装项目开发所需要的依赖项\n\n```bash\nnpm install --save-dev gulp\n```\n\n安装用来压缩js文件的插件\n\n```bash\nnpm install --save-dev gulp-uglify\n```\n\n安装用来压缩css文件的插件\n\n```bash\nnpm install --save-dev gulp-minify-css\n```\n\n解析less的插件\n\n```bash\nnpm install --save-dev gulp-less\n```\n\n安装用来合并的插件\n\n```bash\nnpm install --save-dev gulp-concat\n```\n\n用来检查js代码的插件\n\n```bash\nnpm install --save-dev gulp-jshint\n```\n\n用来重命名的插件\n\n\n```bash\nnpm install --save-dev gulp-rename\n```\n\n搭建服务器的插件\n\n```bash\nnpm install --save-dev gulp-connect\n```\n\n一起安装\n\n```bash\nnpm install --save-dev gulp gulp-uglify gulp-minify-css gulp-concat gulp-jshint gulp-rename\n```\n\n+ ##### 在项目根目录下建一个以`gulpfile.js`命名的文本\n\n#### 文件的压缩示例\n\n编辑根目录下的`gulifile.js`文件 <copy>\n\n```js\nvar gulp = require('gulp');  //定义依赖项\n\nconcat = require('gulp-concat');   //定义合并插件\n\nmincss = require('gulp-minify-css');   //定义压缩css的插件\nminjs = require('gulp-uglify');         //定义压缩js的插件\n\nrename = require('gulp-rename');//定义重命名插件\n\n//定义任务   第一个是任务名字，第二个是要执行哪些操作\ngulp.task('css', function() {\n    gulp.src(['css/*.css'])  //操作css文件夹中所有的css文件\n    // gulp.src(['css/a.css'.'css.b.css'])  //操作css文件夹中ab文件\n        .pipe(concat('min.css'))  //执行合并插件并给合并完成的插件起一个名字\n        .pipe(mincss())         //执行压缩插件\n        .pipe(rename({suffix:'.xianyu'}))//执行重命名插件\n        .pipe(gulp.dest('css1'))//把执行以上操作后的文件放在css1文件夹里面\n});\n\ngulp.task('js', function() {\n    gulp.src(['js/*.js'])  //操作js文件夹中所有的js文件\n    // gulp.src(['js/a.js'.'js.b.js'])  //操作js文件夹中ab文件\n        .pipe(concat('min.js'))  //执行合并插件并给合并完成的插件起一个名字\n        .pipe(minjs())         //执行压缩插件\n        .pipe(rename({suffix:'.xianyu'}))//执行重命名插件\n        .pipe(gulp.dest('js'))//把执行以上操作后的文件放在js文件夹里面\n});\n\ngulp.task('default',['css','js']);  //执行任务名为css的任务\n\n//自动执行压缩任务\ngulp.watch('css/*.css',['css']);   //如果css文件夹下任何一个css有变动，则执行名字为css的任务\ngulp.watch('js/*.js',['js']);      //如果js文件夹下任何一个js有变动，则执行名字为js的任务\n```\n\n运行 gulp：\n\n```\ngulp\n```\n\n## 实现热更新的例子 <copy>\n\n```js\nvar gulp = require('gulp');\nconcat = require('gulp-concat');            //定义合并插件\nless = require('gulp-less');                //定义less编译插件\nmincss = require('gulp-minify-css');        //定义压缩css的插件\nminjs = require('gulp-uglify');             //定义压缩js的插件\nsourcemaps = require('gulp-sourcemaps');    //定义sourcemaps\nconnect = require('gulp-connect');          //自动刷新服务\n\n\ngulp.task('Less', function () {\n    gulp.src('src/less/*.less')             //入口文件目录\n        .pipe(sourcemaps.init())\n        .pipe(less())                       //执行less\n        .pipe(concat('min.css'))            //合并文件\n        .pipe(mincss())                     //压缩css\n        .pipe(sourcemaps.write('./'))       //生成sourcemaps\n        .pipe(gulp.dest('dist/src/css'))    //出口目录\n});\n\ngulp.task('js', function() {\n    gulp.src(['src/js/*.js'])               //入口文件\n        .pipe(sourcemaps.init())\n        .pipe(concat('min.js'))             //合并文件\n        .pipe(minjs())                      //执行压缩插件\n        .pipe(sourcemaps.write('./'))       //生成sourcemaps\n        .pipe(gulp.dest('dist/src/js'))     //出口目录\n});\n\ngulp.task('html', function () {\n    gulp.src('./dist/*.html')\n        .pipe(connect.reload());\n});\n\n\ngulp.task('connect', function() {           //搭建服务器\n    connect.server({\n        root: 'dist',\n        livereload: true,\n        port:8080\n    });\n});\n\ngulp.task('default',['Less','js','connect','html']);         //执行任务\n\n//自动执行压缩任务\ngulp.watch('src/less/*.less',['Less']);     //监视less文件\ngulp.watch('src/js/*.js',['js']);           //监视js文件\ngulp.watch('dist/*.html',['html']);           //监视js文件\n```\n\n\n","tags":["Gulp"],"categories":["Gulp使用参考"]},{"title":"Gulp入门指南","url":"%2F2017%2F06%2F12%2FGulp--%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%2F","content":"\ngulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率\n<!--more-->\n\n#### 1. 全局安装 gulp：\n\n```bash\n$ npm install --global gulp\n\n```\n\n#### 2. 作为项目的开发依赖（devDependencies）安装：\n\n```bash\n$ npm install --save-dev gulp\n\n```\n\n#### 3. 在项目根目录下创建一个名为 `gulpfile.js` 的文件：\n\n```javascript\nvar gulp = require('gulp');\n\ngulp.task('default', function() {\n  // 将你的默认的任务代码放在这\n});\n```\n\n#### 4. 运行 gulp：\n\n```bash\n$ gulp\n```\n\n默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。\n\n想要单独执行特定的任务（task），请输入 `gulp <task> <othertask>`。","tags":["Gulp"],"categories":["Gulp使用参考"]}]