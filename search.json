[{"title":"TWEEN补间动画","url":"%2F2018%2F10%2F01%2F3JS--TWEEN%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB%2F","content":"\n### 使用方法\n\n首先要用一个对象将需要进行补间动画的值包含进来\n\n```js\nvar changeSrc = {positionZ:1180}\n```\n\n然后在tween中注册使用该对象并且设置相关参数 \n\n```js\nvar tween = new TWEEN.Tween(posSrc)     //注册\n.to({pos:640},3000)\t\t\t\t\t\t//补间结束值 3000是持续时间\n.easing(TWEEN.Easing.Sinusoidal.InOut)  //选择补间动画\n.onUpdate(function () {                 //更新动画\n    console.log(this.pos);              //这就是tween帮助我们进行补间动画的值\n    //动态改变camera.position.x的值\n    camera.position.z = this.pos;        //相机的z轴距离等于补间动画的值\n});;\n```\n\n在模型加载完之后激活动画\n\n```js\n//激活动画\ntween.start();\n```\n\nTween.js本身不会运行，你需要通过`update`方法明确的告诉它什么时候开始运行。推荐在动画主循环中使用该方法。你可以通过调用`requestAnimationFrame`方法来获得良好的图像性能。\n\n```js\nfunction run() {\n    TWEEN.update();   //启动补间动画\n    renderer.render(scene, camera);\n    requestAnimationFrame(run);\n}\n```\n\n### 无限循环动画\n\n+ 通过chain来关联，头部结合无限循环\n\n```js\ntweenA.chain(tweenB);\ntweenB.chain(tweenA);\n```\n\n+ 使用repeat函数\n\n```js\ntween.repeat(10);        // repeats 10 times and stops\ntween.repeat(Infinity);  // repeats forever  不会回放\ntween.repeat(Infinity).yoyo(true)；    //增加回放，就像start和back使用chain串联起来\n```\n\n### 事件触发补间动画\n\n例子中使用点击事件触发相机视角移动\n\n```js\ndocument.addEventListener( 'mousedown', onDocumentMouseDown, false );\nfunction onDocumentMouseDown( event ) {\n    event.preventDefault();\n    new TWEEN.Tween( camera.position ).to( {  y:30}, 1000 ).easing(TWEEN.Easing.Sinusoidal.InOut).start();\n}\n\n//必须\nfunction run() {\n    TWEEN.update();   //启动补间动画\n    renderer.render(scene, camera);\n    requestAnimationFrame(run);\n}\nrun（）;\n```","tags":["THREE"],"categories":["THREE.js"]},{"title":"dat.gui使用","url":"%2F2018%2F09%2F30%2F3JS--dat.gui%20%E4%BD%BF%E7%94%A8%2F","content":"\n\ndat.GUI 是一个轻量级的**图形用户界面库（GUI 组件）**，使用这个库可以很容易地创建出能够改变代码变量的界面组件。\n### 基本使用方法\n\n#### 引用路径\n\n```html\n<script src=\"https://cdn.bootcss.com/dat-gui/0.7.2/dat.gui.min.js\"></script>\n```\n\n#### 创建对象\n\n该对象用于存储需要动态改变的值。\n\n```JS\n//创建一个对象存储需要动态改变的值\nvar controls = {\n    cameraPositionX:30,\n    cameraPositionY:30\n}\n//初始化和注册插件\nvar gui = new dat.GUI();           //初始化插件\ngui.add(controls, 'cpx', 0, 30);  //添加值 gui.add(controls, 'cameraPositionX', 0, 30);   \n```\n\n#### 动态更新\n\n+ 放在渲染函数中\n\n    当你改变值的时候，renderer重新渲染\n\n```js\n//渲染函数\nfunction run() {\n    //使用dat.gui里面可以动态改变的值,，比如上面创建的controls.cameraPositionX\n    camera.position.x = controls.cameraPositionX;\n    cube.rotation.x +=0.02;\n    cube.rotation.y +=0.02;\n    cube.rotation.z +=0.02;\n    //重复调用\n    renderer.render(scene,camera);\n    requestAnimationFrame(run);\n}\nrun();\n```\n\n+ **监听值（推荐）**\n\n  ```js\n  gui.add(controls, 'cameraPositionZ', 0, 80).onChange(function (e) {\n      camera.position.z = e\n  });\n  ```\n\n\n### 各种类型的控件\n\ndat.gui会根据对象值自动识别和转化控件类型。\n\n##### 数字类型（Number）\n\n+ 没有设置任何条件，则是一个输入框\n\n  ```js\n  gui.add(controls, 'cpx');\n  ```\n\n+ 可以设置大小范围（变成slide滑动组件），或者单独设置最大最小（还是input输入框）\n\n  ```js\n  gui.add(controls, 'cpx', 0, 30);    //0--30\n  gui.add(controls, 'cpx', nim(0));   //最小0\n  gui.add(controls, 'cpx', min(30));  //最大30\n  ```\n\n+ 可以配置step限制步长\n\n   ```js\n    gui.add(controls, 'cpx', 0, 30).step(0.5);  //限制一步增加0.5\n   ```\n\n+ 可以固定只为几个值（变成下拉框）\n\n  ```js\n  gui.add(controls, 'cpx', {Stopped: 0, Slow: 0.02, Fast: 5});  \n  ```\n\n##### 字符串（String）\n\n+ 默认情况一个输入框\n+ 可以固定为几个值\n\n#### 布尔类型（Boolean）\n\n会自动变为复选框的形式\n\n```js\nvar controls = {\n    isHide:true\n}\nvar gui = new dat.GUI();\ngui.add(controls, 'isHide');\n```\n\n##### 函数（Function）\n\n会自动变成按钮触发\n\n```js\nvar controls = {\n    hello:function(){alert('hello')}\n}\nvar gui = new dat.GUI();\ngui.add(controls, 'hello');\n```\n\n##### 颜色值\n\n一共有四种类型css、rgb、rgba、hue，使用 addColor 方法添加控件。\n\n```js\nvar controls = {\n    color0 = \"#ffae23\"; // CSS string\n    color1 = [0, 128, 255]; // RGB array\n    color2 = [0, 128, 255, 0.3]; // RGB with alpha\n    color3 = {h: 350, s: 0.9, v: 0.3}; // Hue, saturation, value\n};\n \nvar gui = new dat.GUI();\ngui.addColor(controls, 'color0');\ngui.addColor(controls, 'color1');\ngui.addColor(controls, 'color2');\ngui.addColor(controls, 'color3');\n```\n\n### 事件监听\n\n对于面板中的每一个控制项，我们都可以设置` onChange` 和 `onFinishChange `监听事件。\n\n```js\nvar controls =  {\n    speed = 1;\n};\nvar gui = new dat.GUI();\nvar speedController = gui.add(controls, 'speed', 0, 5);\n//对应控制项值改变时响应（比如拖动滑块过程中）\nspeedController.onChange(function(value) {\n  console.log(\"onChange:\" + value);\n});\n//对应控制项值修改完毕响应\nspeedController.onFinishChange(function(value) {\n  console.log(\"onFinishChange\" + value);\n});\n```\n\n","tags":["THREE"],"categories":["THREE.js"]},{"title":"材质","url":"%2F2018%2F08%2F21%2F3JS--%E6%9D%90%E8%B4%A8%2F","content":"\n\n\n材质结合几何体可以构成网格。材质就是物体的皮肤，决定结合体外表的样子。常用材质如下：\n\n| 名称                                | 描述                                                     |\n| :---------------------------------- | :------------------------------------------------------- |\n| MeshBasicMaterial（网格基础材质）   | 基础材质                                                 |\n| MeshDepthMaterial（网格深度材质）   | 根据网格到相机的距离，这种材质决定如何给网格染色         |\n| MeshNormalMaterial（网格法向材质）  | 简单材质，根据物体表面的法向向量计算颜色                 |\n| MeshFaceMaterial（网格面材质）      | 这是一个容器，可以在容器里为物体的各个表面指定不同的颜色 |\n| MeshLambertMaterial（网格朗伯材质） | 材质考虑光照，可以用来创建颜色**暗淡、不光亮**的物体     |\n| MeshPhongMaterial（网格Phong材质）  | 材质考虑光照，可以用来创建颜色**光亮**的物体             |\n| ShaderMaterial（着色器材质）        | 材质允许使用自定义着色器程序                             |\n| LineBasicMaterial（直线基础材质）   | 用于`THREE.Line`（直线）几何体，从而创建着色的直线       |\n| LineDashedMaterial（虚线材质）      | 虚线效果                                                 |\n\n对于如此多材质，我们可以分为三类属性去使用：基础属性、融合属性、高级属性。\n\n### 基础属性\n\n常用属性，控制物体的透明度，是否可见等等。\n\n| 属性                    | 描述                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| id（标识符）            | 第一个材质为0，以后新加一个值就加1                           |\n| uuid（通用唯一识别码）  | 生成的唯一ID，在内部使用                                     |\n| name（名称）            | 用于调试                                                     |\n| opacity（不透明度）     | 透明度0-1                                                    |\n| transparent（是否透明） | 为true，则物体会用指定的opacity去渲染；false这个物体不透明，只是着色更加明亮 |\n| overdraw（过度描绘）    | 物体有间隙，可以将这个设置为true调整                         |\n| visible（是否可见）     | 是否能看见这个物体                                           |\n| slide（侧面）           | 定义几何体的哪一面应用材质                                   |\n| needsUpdate（是否更新） | 属性更新后告诉THREE.js更新他的缓存                           |\n\n### 融合属性\n\n融合决定了我们渲染的颜色如何与他们后面的颜色交互\n\n| 名称                      | 描述                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| blending（融合）          | 决定物体上的材质是否**和背景融合**。一般的融合模式是NormalBlending，在这种模式下只显示材质的上层 |\n| blendsrc（融合源）        | 定义了该物体如何与背景相互融合，默认使用alpha（透明度）通道进行融合 |\n| blend电视台（融合目标）   | 定义融合时候如何使用背景（目标）                             |\n| blendequation（融合公式） | 定义如何使用blendsrc和blenddst的值。                         |\n\n","tags":["THREE"],"categories":["THREE.js"]},{"title":"各种光源","url":"%2F2018%2F08%2F20%2F3JS--%E5%90%84%E7%A7%8D%E5%85%89%E6%BA%90%2F","content":"\n`THREE.js`提供了一系列的光源，各有用途：\n\n| 光源名称                     | 描述                                                 |\n| ---------------------------- | ---------------------------------------------------- |\n| AmbientLight（环境光源）     | 颜色会直接作用物体的当前颜色上                       |\n| PointLight（点光源）         | 一个点向所有方向                                     |\n| SpotLight（聚光灯）          | 聚光灯效果（范围）例如台灯                           |\n| DirectionalLight（方向光源） | 平行光源 例如太阳光                                  |\n| HemisphereLight（半球光）    | 创造自然室外光线，模拟反光和光线微弱的天空，太阳升降 |\n| AreaLight（面光源）          | 可指定光线的面                                       |\n| LensFlare（镜头眩光）        | 给光源添加眩光效果                                   |\n\n### AmbientLight（环境光源）\n\n环境光可以说是场景的整体基调，它没有特定的来源，同时也不会影响阴影的产生。有点类似于滤镜，营造全局。\n\n```js\n// add subtle ambient lighting\nvar ambiColor = \"#0c0c0c\";    //浅色，弱化生硬的投影\nvar ambientLight = new THREE.AmbientLight(ambiColor);\nscene.add(ambientLight);\n```\n\n由于环境光无处不在，也就是说它是没有方向的，当然不能产生阴影。而且，它也不能作为环境中唯一的光源。\n\n### PointLight（点光源）  \n\n可以将点光源想象成萤火虫一样发出的光。由于它的光线也发射到四面八方，在ThreeJS中它也是不能产生阴影的。常用的属性如下：\n\n| 属性                | 描述                |\n| ------------------- | ------------------- |\n| color（颜色）       | 光源颜色            |\n| intensity（强度）   | 光照强度，默认值是1 |\n| distance（距离）    | 光源照射的距离      |\n| position（位置）    | 光源所在的位置      |\n| visible（是否可见） | true打开，false关闭 |\n### SpotLight（聚光灯）\n\n大概是最常用的光源，类比手电筒或灯笼。常用的属性如下：\n\n| 属性                                   | 描述                                                         |\n| -------------------------------------- | ------------------------------------------------------------ |\n| castShadow（阴影）                     | true则照射会产生yinying                                      |\n| shadowCameraNear（投影近点）           | 从距离光源的哪一点开始可以生成阴影                           |\n| shadowCameraFar（投影远点）            | 到距离光源的哪一点为止可以生成阴影                           |\n| shadowCameraFov（投影视场）            | 用于生成阴影的视场有多大                                     |\n| target（目标）                         | 决定光照的fang'xiang                                         |\n| shadowBias（阴影偏移）                 | 用来设置阴影的位置                                           |\n| angle（角度）                          | 光源射出的光柱有多宽。单位是弧度，默认值是Math.PI/3          |\n| exponent（光强衰减指数）               | 光照指向特定目标。在这个方向上距离光源越远，则光强度递减得越快。这个值觉得光照强度递减得有多快 |\n| onlyShadow（仅阴影）                   | true这个光源只会生成阴影而不会在场景                         |\n| shadowCameraFovVisible（投影方式可见） | true就可以看到光源在哪里以及如何生成光源                     |\n| shadowDarkness（阴影暗度）             | 默认值0.5。                                                  |\n| shadowMapWidth（引用映射宽度）         | 决定由多少像素来生成阴影。如果阴影的边缘参差不齐或看上去不那么平滑，可以增加这个值。 |\n| shadowMapHeight（引用映射高度）        | 决定由多少像素来生成阴影。如果阴影的边缘参差不齐或看上去不那么平滑，可以增加这个值。 |\n\n```js\nvar spotLight = new THREE.SpotLight(0xffffff);  //颜色\n    spotLight.position.set(0, 90, -50);    //光源位置\n    spotLight.castShadow = true;          //打开照射阴影\n    spotLight.target = plane;             //照射目标（照射于中心点）\n    spotLight.shadowCameraFovVisible = true;  //显示阴影的形成\n    scene.add(spotLight);\n```\n\n### DirectionalLight（方向光源）\n\n方向光源可以看成是距离很远的光源，就像太阳光一样，达到地球的光线都可以看成是平行光。被方向光光源照亮的整个区域接收到的光强是一样的。\n\n由于模型的阴影渲染会消耗很多的性能，所以我们需要设置平行光相关的区域能够显示阴影，和阴影显示的良好程度。如下几个属性：\n\n```js\ndirectionalLight.shadow.camera.near = 20; //产生阴影的最近距离\ndirectionalLight.shadow.camera.far = 200; //产生阴影的最远距离\ndirectionalLight.shadow.camera.left = -50; //产生阴影距离位置的最左边位置\ndirectionalLight.shadow.camera.right = 50; //最右边\ndirectionalLight.shadow.camera.top = 50; //最上边\ndirectionalLight.shadow.camera.bottom = -50; //最下面\n\n//这两个值决定使用多少像素生成阴影 默认512\ndirectionalLight.shadow.mapSize.height = 1024;\ndirectionalLight.shadow.mapSize.width = 1024;\n```\n\n![pl6e21c.png](https://miao.su/images/2018/08/23/pl6e21c.png)\n\n由于所有光线是相互平行的，所以不会有光椎，却而代之的是一个方块。图中方块区域内的元素会显示阴影。\n\n### HemisphereLight（半球光）\n\n使用半球光可以获得光加贴近自然的光照效果。\n\n当你使用环境光为场景提供基础色，现实中并非所有的光都来自天空，还有很多散射、地面的反射和其他物体的反射，所有他可以设置如下属性：\n\n| 属性        | 描述·                    |\n| ----------- | ------------------------ |\n| groundColor | 从地面发出的光线的颜色   |\n| Color       | 从天空中发出的光线的颜色 |\n| intensity   | 光照强度                 |\n\n### LensFlare（镜头眩光）\n\n当你直接朝着太阳拍照时候就会出现镜头眩光，现实中虽然要必然这种现象，但是在游戏场景中，镜头眩光能使得场景更加真实。常用的属性如下：\n\n| 参数             | 描述                     |\n| ---------------- | ------------------------ |\n| texture（纹理）  | 眩光材质，决定炫光的样子 |\n| size（尺寸）     | 制定眩光的大小           |\n| distance（距离） | 光源（0）到相机（1）     |\n| blending（融合） | 丰富眩光的材质           |\n| color（颜色）    | 眩光的颜色               |\n\n```js\nvar textureFlare0 = THREE.ImageUtils.loadTexture(\"lensflare0.png\");  //加载纹理\nvar textureFlare3 = THREE.ImageUtils.loadTexture(\"lensflare3.png\");  //加载纹理\nvar flareColor = new THREE.Color(0xf0fa78);\nvar lensFlare = new THREE.LensFlare(textureFlare0, 350, 0.0, THREE.AdditiveBlending, flareColor); \n// new THREE.LensFlare(texture, size, distance, blending, color)\n\n\n//.add ( texture, size, distance, blending, color )\n// 添加一个光晕，和构造函数的配置一样\nlensFlare.add(textureFlare3, 60, 0.6, THREE.AdditiveBlending); \nlensFlare.add(textureFlare3, 70, 0.7, THREE.AdditiveBlending);\nlensFlare.add(textureFlare3, 120, 0.9, THREE.AdditiveBlending);\nlensFlare.add(textureFlare3, 70, 1.0, THREE.AdditiveBlending);\nlensFlare.position.copy(spotLight.position);  //让镜头眩光出现在点光源处\n\nscene.add(lensFlare);\n```\n\n![lenf2b614.png](https://miao.su/images/2018/08/23/lenf2b614.png)","tags":["THREE"],"categories":["THREE.js"]},{"title":"THREE.Scene常用方法和属性","url":"%2F2018%2F08%2F18%2F3JS--%E5%9C%BA%E6%99%AF%E5%AF%B9%E8%B1%A1THREE.Scene%2F","content":"THREE.Scence 场景是所有对象的容器，所有对象和元素都会被放到场景中才能渲染。\n\n| 方法（属性）                    | 描述                                                         |\n| ------------------------------- | ------------------------------------------------------------ |\n| add(object)                     | 用于向场景中添加对象。使用该方法还可以创建对象组。           |\n| children                        | 用于返回一个场景中所有对象的列表，包括摄像机和光源。         |\n| getObjectByName(name,recursive) | 在创建对象时可以指定唯一的标识 name，使用该方法可以查找特定名字的对象。 当参数 recursive 设置为 false 时，在调用者子元素上查找当参数 recursive 设置为 true 时，在调用者的所有后代对象上查找 |\n| remove(object)                  | object 为场景中对象的引用，使用该方法可以将对象从场景中移除。 |\n| traverse(function)              | 该方法也可以遍历调用者和调用者的所有后代，function 参数是一个函数，被调用者和每一个后代对象调用 function 方法。 |\n| fog                             | 使用该属性可以为场景添加雾化效果，可以产生隐藏远处物体的浓雾效果。 |\n| overrideMaterial                | 使用该属性可以强制场景中的所有物体使用相同的材质。           |\n\n ```js\nvar scene = new THREE.Scene();  //初始化\n ```\n\n### add（object）\n\n场景有了之后，我们需要在场景中放置我们的演员（对象），这里包括物体，相机和光源。\n\n```js\n    //绘制一个物体\n    var cubeShape = new THREE.BoxGeometry(4,4,4);\n    var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000, wireframe: true});\n    var cube = new THREE.Mesh(cubeShape, cubeMaterial);\n\t//把物体放置进场景中\n    scene.add(cube);    \n```\n\n### children\n\n该属性用于返回`scene`中所有的对象，在控制台打印`scene`\n\n![sceneb6363.png](https://miao.su/images/2018/08/21/sceneb6363.png)\n\n可以可到`scene`中定义的各种属性。当我们往`scene`中添加对象，这些元素都会存储到`scene`中的`children`数组里面。\n\n所以移除场景中对象，就是除`children`数组中的值\n\n```js\nfunction removeEle(num) {\n    var allChildren = scene.children;\n    var lastObject = allChildren[num];\n    if (lastObject instanceof THREE.Mesh) {\n        scene.remove(lastObject);\n    }\n}\n```\n\n我们也可以为每一个对象添加属于他自己的`name` 属性\n\n```js\n//绘制一个立方体\nvar cubeShape = new THREE.BoxGeometry(4,4,4);\nvar cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000, wireframe: true});\nvar cube = new THREE.Mesh(cubeShape, cubeMaterial);\n// position the cube\ncube.name = '立方体'\n```\n![children3aefd.png](https://miao.su/images/2018/08/21/children3aefd.png)\n\n可以看到`name`属性成功添加到元素中，后续方便我们查找。\n\n### getObjectByName(name,recursive)\n\n上面，`cube.name = '立方体'`，这个`name`也是该对象的标识符，通过`getObjectByName`可以找到该对象\n\n```js\nconsole.log(scene.getObjectByName('立方体'));\n//THREE.Mesh {uuid: \"B9454ABD-01EF-4333-A6DD-21FA30F8F843\", name: \"立方体\", type: \"Mesh\", parent: T…E.Scene, children: Array(0), …}\n//如果 recursive 为 true，则开启后代查询\n```\n\n### remove（object）\n\n查找到有标识符的对象，就可以对其进行操作，比如删除该对象:\n\n```js\nvar target = scene.getObjectByName('立方体');\nif (target instanceof THREE.Mesh) {\n    scene.remove(target);\n}\n```\n\n如此，`name`属性为'立方体'的对象就会从`scene`中删除。\n\n> 移除前我们还要检查下该对象是不是 THREE.Mesh 对象，这样做是为了**避免移除摄像机和光源**。\n\n### traverse（function）\n\n我们可以将一个方法作为参数传递给 `traverse() `方法，这个传递过来的方法会在**每一个子对象上执行**。\n\n由于 THREE.Scene 对象存储的是对象树，所以如果子对象本身还有子对象，traverse() 方法会在所有的子对象上执行，直到遍历完场景树中的所有对象为止。\n\n比如我们给所有对象添加`name`：\n\n```js\nscene.traverse(function (e) {\n    if (e instanceof THREE.Mesh) {\n        e.name ='123'\n    }\n})\n```\n### fog\n\n使用 fog 属性可以为整个场景添加雾化效果，即场景中的物体离得越远就会变得越模糊。具体样式有如下两种：\n\n（1）使用 THREE.Fog：该方法雾的浓度是线性增长的，它有三个参数：\n\n+ 第 1 个参数：雾的颜色\n\n+ 第 2 个参数：near（近处）属性的值，决定雾化开始的地方。\n\n+ 第 3 参数：far（远处）属性的值，决定雾化结束的地方。\n\n```js\n`scene.fog = ``new` `THREE.Fog(0xffffff, 0.015, 100);`\n```\n\n（2）使用 THREE.FogExp2：该方法雾的浓度不再是线性增长的，而是随着距离呈指数增长，它有两个参数：\n\n+ 第 1 个参数：雾的颜色\n\n+ 第 2 个参数：雾的浓度\n\n```js\n`scene.fog = ``new` `THREE.FogExp2( 0xffffff, 0.015 );`\n```\n\n### overrideMaterial 属性\n\n（1）场景设置了 overrideMaterial 属性后，场景中所有的物体都会使用该属性指向的材质，即使物体本身也设置了材质。\n\n（2）上面的样例中我们使用的材质是 THREE.MeshLambertMaterial，该材质可以创建出不发光但是可以对场景中的光源产生反应的物体。\n\n```js\n`scene.overrideMaterial = ``new` `THREE.MeshLambertMaterial({color: 0xffffff});`\n```","tags":["THREE"],"categories":["THREE.js"]},{"title":"02--模块加载系统","url":"%2F2018%2F07%2F25%2FJS%E6%A1%86%E6%9E%B6--%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F%2F","content":"JS不像其他语言一样拥有完善的模块化机制，早前只能靠插入一个个script标签来引入脚本，并且容易带来命名冲突的问题。\n\nJS模块化标准CommonJS与AMD就是为了实现JS的模块化机制，前者运用于node环境，后者在浏览器环境中由Require.js等实现。随着ES6的普及，AMD和CMD都终将成为历史。\n\n实现一个简单的js加载器并不复杂，主要可以分为**解析路径、下载模块、解析模块依赖、解析模块**四个步骤。\n\n## 模块\n当构建庞大的程序时，如果不对功能进行拆分，不仅会带来很高的维护成本，而且不利于程序的扩展。\n\n一个JS文件相当于一个模块。为了能实现模块化加载，就必须遵循一定的规范，比如CommonJS与AMD。\n\n我们可以在模块文件中，构造一个闭包，并传出一个对象，作为模块的导出：\n```js\ndefine(factory() {\n    var x = {\n        a: 1\n    };\n    return x;\n});\n```\n","tags":["JS框架"],"categories":["JavaScript框架"]},{"title":"01--种子模块","url":"%2F2018%2F07%2F17%2FJS%E6%A1%86%E6%9E%B6--%E7%A7%8D%E5%AD%90%E6%A8%A1%E5%9D%97%2F","content":"\n种子模块就是核心模块，负责框架的初始部分。\n\n## 命名空间\nJS基于对象，其命名空间也是使用**对象的属性**来扩展的。\n\n比如下面代码中，通过不同给对象`Ten`（我们的命名空间）添加属性，从而有条不紊得构建我们的框架。我们只需要通过`Ten.xx.xx`来调用即可 <copy>\n```js\nif(typeof(Ten) === \"undefined\" ){\n  Ten = {};\n  Ten.Function = {/*略*/ }\n  Ten.Array = {/*略*/ }\n  Ten.Class = {/*略*/ }\n  Ten.JSONP =new Ten.Class(/*略*/)\n  Ten.XHR =new Ten.Class(/*略*/)\n}\n```\n有时候也会出现命名空间冲突的情况，比如早期的`Prototype`和现在的`jQuery`都会在`window`对象中添加`$`属性，同时引用就会报错。\n\n`jQuery`实现了多库共存，其原理也比较简单：先用`_$`存储原来window中的`$`属性(来源于`Prototype`)，然后自己使用`$`属性。\n\n当你现在不需要使用`jQuery`而想使用`Prototyp`e时，就可以调用`$.noConflict()`,这时$就会恢复成prototype对象 <copy>\n```JS\nvar _$ =  window.$,_jQuery= window.jQuery;  //先把可能存在的同名变量保存起来\n_jQuery.extend=({\n    noConflict:function(deep){\n        window.$ = _$;    //放回去\n    　　 if(deep)  window.jQuery = _jQuery;\n        return jQuery;    //返回了jQuery对象，如果jQuery没有冲突，则可以用变量接受这个函数，然后调用jquery的方法。\n    }\n})\n```\n\n\n## 对象扩展\n命名空间对象有了，那我们需要扩展功能。比如：我需要把A对象的属性和方法全部复制到B对象中。我不用一个一个在B对象中去写代码。\n\n简单的对象扩展\n```js\nfunction mix(target,source) {\n  for(key in source){\n    target[key] = source[key]\n  }\n  return target;\n}\n```\n进行加工\n```js\nfunction mix(target,source) {\n  var args = [].slice.call(arguments),  //对参数进行数组化\n      i = 1;\n      isCover  = typeof args[args.length-1] ===\"boolean\" ?false:true;\n      /*\n        利用args[args.length-1]来判断arguments的最后一个参数是否是布尔值\n        如果是布尔值，则不覆盖，isCover = false\n        相反则默认覆盖 isCover = true\n        有点类似于用最后一个参数来决定是否冒泡\n      */\n      if (args.length == 1) {\n        target = !this.window? this:{};\n        /*\n         如果只有一个对象参数时，就扩展this对象\n         比如A的上下文中调用mix(B)，此时this指向A\n         只有window对象拥有window属性，通过这判断是否传入了window对象，防止误加属性给window对象\n        */\n        i=0;\n      }\n      while((source==args[i++])){\n        for(key in source){\n          if(isCover||!(key in source)){target[key]=source[key]}\n        }\n      }\n      return target;\n}\n```\n## 数组化\n使用jQuery函数会返回一个对象，这个对象是伪数组对象，可以通过数字索引访问其中的属性,类似于下面这种：\n```js\nvar arrayLike = {\n       0:\"a\",\n       1:\"b\",\n      length:2\n}\n```\n通常情况下只要通过`[].slice.call(a)`就可以实现了，这种简便方法存在兼容性问题\n\n参考mass的数组化方法：\n```js\n$.slice = window.dispatchEvent ? function(nodes, start, end) {\n    return [].slice.call(nodes,start,end);\n  }\n  //如果window有dispatchEvent  属性就证明支持[].slice.call方法，能力检测。\n  :\n  function(nodes, start, end) {\n    var ret = [],\n      n = nodes.length;　　　　　　　　\n    if (end == undefined || typeof end === \"number\" && isFinite(end)) { //&&优先级高于||，因此end没写，或者end是有限数字就进入\n      start = parseInt(start, 10) || 0; //如果start不存在或者不是数字，则就赋值为0.\n      end = end == undefined ? n : parseInt(end, 10); //如果end不存在，则赋值为n.\n      　　　　　　　　　　　　\n      if (start < 0) start += n;　　　　　　　　　　　　\n      if (end < 0) end += n;　　　　　　　　　　　　\n      if (end > n) end = n;　　　　　　　　　　　　\n      for (var i = start; i < end; i++) {\n        ret[i - start] = nodes[i]; //低版本IE使用数组赋值的形式\n      }　　　　　　　　\n    }　　　　　　　　\n    return ret;\n  };\n```\n\n## 类型判断\nJavaScript有两种数据类型：基本数据类型和对象类型。基本数据类型有五种，number，string，boolean，underfine，null。此外所有其他的值都是对象类型。\n\n数字、字符串和布尔值貌似对象，因为他们拥有方法，但是他们是不可变的。在JS中，对象是**可变的键控集合（keyed collections）**。\n\n由于JS自带的类型检测系统不是特别靠谱，我们需要根据需求相应选择不同的方法对数据类型进行判断。\n\n`typeof`方法（判断基本数据类型，除了**null**）\n```js\n  console.log(typeof 1);             //number\n  console.log(typeof '123');         //string\n  console.log(typeof true);          //boolean\n  console.log(typeof undefined);     //undefined\n  console.log(typeof null);          //object\n  console.log(typeof {});            //object\n  console.log(typeof []);            //object\n  \n  //无论引用的是什么类型的对象，它都返回 \"object\"\n```\n`instanceof`方法（判断一个实例是否属于某种类型）\n```js\n// 定义构造函数\nfunction C(){} \nfunction D(){} \n\nvar o = new C();\no instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype\no instanceof D; // false，因为 D.prototype不在o的原型链上\no instanceof Object; // true,因为Object.prototype.isPrototypeOf(o)返回true\nC.prototype instanceof Object // true,同上\nC.prototype = {};\n\nvar o2 = new C();\no2 instanceof C; // true\no instanceof C; // false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.\nD.prototype = new C(); // 继承\n\nvar o3 = new D();\no3 instanceof D; // true\no3 instanceof C; // true 因为C.prototype现在在o3的原型链上\n```\n`Object.prototype.toString.call`\n最推荐的方法\n```js\nvar  gettype=Object.prototype.toString\n\ngettype.call('aaaa')             //    [object String]\ngettype.call(2222)               //    [object Number]\ngettype.call(true)               //    [object Boolean]\ngettype.call(undefined)          //    [object Undefined]\ngettype.call(null)               //    [object Null]\ngettype.call({})                 //    [object Object]\ngettype.call([])                 //    [object Array]\ngettype.call(function(){})       //    [object Function]\n```\n可以封装的方法如下：\n```js\nvar  gettype=Object.prototype.toString\nvar  utility={\nisObj:function(o){\n   return   gettype.call(o)==\"[object Object]\";\n    }\n}\n```\n\n","tags":["JS框架"],"categories":["JavaScript框架"]},{"title":"预加载","url":"%2F2018%2F07%2F10%2FTX-%E9%A2%84%E5%8A%A0%E8%BD%BD%2F","content":"\n当网页图片比较多的时候，使用预加载动画，可以提高用户体验\n\n## 引用  <copy>\n\n预加载效果使用`loder.js`实现，[前往下载](http://dev.test.gdinsight.com/dev/yq/common%20plugin/js/loder.zip)\n\n```js\n<script src=\"js/loder.js\"></script>\n```\n\n## 添加结构\n\n根据设计稿灵活添加结构和样式，比如我要实现一个数字动态增加的预加载效果，给数字一个类名，方便抓取 <copy>\n\n```html\n<!-- 参考样式 -->\n  <div id=\"loader\" class=\"loader\">\n    <div class=\"loader-cont\">\n      <p class=\"load_val starting\">0%</p>\n    </div>\n  </div>\n```\n\n> 在`loder.js`初始化时候默认加载动画的容器`id`是`loader`\n\n## 添加动画元素 <copy>\n\n首先，要在`loder.js`里面对需要实现动态预加载效果的元素进行“注册”，修改`preloader.init`函数 \n\n```js\npreloader.init = function() {\n    preloader.visuals = {\n        loaded: $('#loader .starting'),  //获取加载动画需要动态改变的元素\n        unloaded: $('#loader .ending')\n    };\n    preloader.$slide = $('#loader');   //加载动画容器\n};\n```\n\n通过在`preloader.visuals`对象里面添加我们想要动态改变的元素，后面就可以通过``preloader.visuals.loaded``操作该元素\n\n## 添加动画效果\n\n预加载的动画效果在`preloader.fillVisuals `函数中  <copy>\n\n```js\npreloader.fillVisuals = function(fillAmount, callback) {\n    if (!callback) callback = function() {};\n    $(function() {\n        //动画区域开始-----------\n        preloader.visuals.loaded.html(parseInt(100*fillAmount)+'%');\n        callback();  //动画完成后的回掉函数（等于preloader.onload）\n        //动画区域结束-----------\n    });\n};\n```\n\n## 执行预加载\n\n通过`preloader.start`函数初始化预加载动画，当动画结束后执行`preloader.onLoad` <copy>\n\n```js\n  preloader.start();  //预加载\n  preloader.onLoad = function() {\n    setTimeout(function() {\n      preloader.disable();   //预加载容器消失\n      //do something\n    }, 700);\n  };\n```\n\n[斗破苍穹预加载体验](http://dp.qq.com/cp/a20180525yyz/index_p.shtml)","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"评论组件","url":"%2F2018%2F07%2F09%2FTX-%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6%2F","content":"\n## 使用方法\n\n### 引用css和js文件\ncss  <copy>       \n```css   \n<link rel=\"stylesheet\" href=\"css/comment.css\">\n```\njs   <copy> \n```html\n<script src=\"//ossweb-img.qq.com/images/js/zepto/zepto.min.js\"></script>\n<script src=\"//ossweb-img.qq.com/images/js/mobile_bundle/milo.js\"></script>\n<script src=\"//ossweb-img.qq.com/images/js/bsCommonFiles/library/vue/vue-2.min.js\"></script>\n<script src=\"//ossweb-img.qq.com/images/js/bsCommonFiles/comment/comment-3.6.min.js\" charset=\"utf-8\"></script>\n```\n> `milo`必须在`zepto`之后\n\n### 添加评论区域   <copy> \n```html\n<!-- 评论 -->\n<div class=\"discuss\">\n    <!--评论放置的地方-->\n    <div id=\"comment\"></div>\n</div>\n```\n\n### 根据设计稿颜色自由调配评论组件的样式   <copy> \n```css\n  /* 评论组件主体 */\n  .discuss {width: 91%;/*评论区域*/}\n  .comment-item{color:#c68e64;}\n  .comment-main {color:#c68e64;}\n  .comment-add-bar--all {background: #c68e64;}\n  .comment-add-bar--input {color: #eadcca;background: #c4822f;}\n  /* 评论面板 */\n  .comment--highlight {color: #c68e64;}\n  .sl-reply-submit {background: #c68e64;}\n  /* 举报面板 */\n  .report-title{background:#c68e64;}\n  .report-sumbit{background: #d0aa5d;}\n  .report-options li.selected .report-options-item {background: #e5a22e}\n```\n### 挂载评论\n```js\n/*评论配置开始*/\nnew Comment({\n  el: '#comment',\n  options: {\n      gameid: 'mhzx', // 游戏 id\n      stime: 201806, // 当前资源的创建时间，年月即可\n      objid: '731923', // 当前资源的自定义 id，需保证唯一性\n      moduleId: 'comment_ingame_mhzx' // 当前资源所属的业务模块 id\n  },\n  login: { // 若无微信 / QQ 登录授权需求，则可缺省\n      qqappid: '1106107956',\n      wxappid: 'wx96a8b9ae096de54d'\n  }\n})\n```\n[跳转到具体选项说明](https://alltest.ingame.qq.com/comment/docs/mobile/api/option.html)\n\n## 附件\n\n[comment.css下载跳转](http://dev.test.gdinsight.com/dev/yq/common%20plugin/css/comment.zip)\n\n\n## 实例\n[传奇世界3D微社区文章区](http://cqsj3d.qq.com/webplat/info/news_version3/34445/35819/35951/35952/m20773/201807/737601.shtml)","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"02--路径","url":"%2F2018%2F07%2F06%2Fcanvas--%E8%B7%AF%E5%BE%84%2F","content":"### 路径\n| 方法        | 描述     |\n| ---------- | -------- | \n| fill()        | 填充当前绘图（路径）  |\n| stroke()      | 连接当前的绘图（路径） |\n| beginPath()   | 起始一条路径，或重置当前路径。     |\n| moveTo()      | 移动画笔     |\n| closePath()   | 闭合路径    |\n| lineTo()      | 添加一个新点     |\n| arc()         | 创建弧/曲线（用于创建圆形或部分圆）。     |\n| arcTo()       | 创建两切线之间的弧/曲线。      |\n| clip()        | 从原始画布剪切任意形状和尺寸的区域。   |\n| quadraticCurveTo()   | 创建二次贝塞尔曲线。       |\n| bezierCurveTo()      | 创建三次贝塞尔曲线。       |\n| isPointInPath()      | 如果指定的点位于当前路径中，则返回 true，否则返回 false。    |","tags":["canvas"],"categories":["canvas攻略"]},{"title":"01--基础使用","url":"%2F2018%2F07%2F05%2Fcanvas--%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F","content":"\n`<canvas> `标签相当于画布，可以通过脚本来绘制图形。一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。\n\n我们不能直接在画布上作图，需要先获取`canvas`的上下文，然后通过操作上下文去选择性绘制图像。\n```js\nvar canvas = document.getElementById('canvas');\nvar cxt = canvas.getContext('2d');\n```\n> 通过`canvas.getContext()`去获取`canvas`的上下文\n> **2d**参数则表示我们创建的是一个**2d**的画布\n\n### 绘制步骤\n\n可以将所有绘制分为两大类：线和面。线使用的API一般以stroke开头，面的API是以fill开头。\n\n准备画布 --》 选择画笔 --》 选择颜料 --》 画出轮廓 --》 填充颜色\n\n\n```js\nvar cxt = document.getElementById('canvas').getContext('2d');    //选择画布\ncxt.lineWidth = 5;                                               //选择画笔\ncxt.strokeStyle = \"blue\";                                        //选择颜料\ncxt.moveTo(10,10);                                               //起始点\ncxt.lineTo(150,50);                                              //两点一线\ncxt.lineTo(10,50);                                               //画出轮廓\ncxt.stroke();                                                    //填充颜色\n```\n\n为了能在一张画图上绘制多个图形而互不影响，CanvasRenderingContext2D提供了\nbeginPath和 closePath。\n\nbeginPath 用于在开始绘制一个独立图形的时候声明，在beginPath之后定义的画笔，颜料都不会影响到画图中的其他图形。\n```js\nvar canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\n\n//第一条路径\nctx.beginPath();\nctx.strokeStyle = 'blue';\nctx.moveTo(20,20);\nctx.lineTo(200,20);\nctx.stroke();\n\n//第二条路径\nctx.beginPath();\nctx.strokeStyle = 'green';\nctx.moveTo(20,20);\nctx.lineTo(120,120);\nctx.stroke();\n```\n![效果图](https://raw.githubusercontent.com/fwon/blog/master/assets/escape-1-3.png)\n\n\n","tags":["canvas"],"categories":["canvas攻略"]},{"title":"添加复制功能","url":"%2F2018%2F07%2F05%2Fhexo--%E6%B7%BB%E5%8A%A0%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%2F","content":"hexo自带的代码段没有复制功能，有时候不是很方便，我们使用`clipboard.js`完善该功能。\n\n## 引入插件\n每个主题使用的模板语言不一样，这里以`.pug`为栗子\n`cd`你的博客目录，然后打开 `theme -> layout -> _partial ->head.pug`，加入外链 \n```jsp\n    script(type='text/javascript', src='https://cdn.bootcss.com/clipboard.js/1.5.16/clipboard.min.js')\n```\n\n## 添加按钮样式\n按钮采用动态append实现，先添加一些**CSS样式**\n```css\nfigure{\n    position: relative;\n    overflow: hidden;\n    .copy{\n        position: absolute;\n        top: 0;\n        right: 0;\n        background: #faff27;\n        color: #262626;\n        padding: 0.24em 0.8em;\n        border-bottom-left-radius: 1em;\n        font-size: 0.7em;\n        cursor: pointer;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n        &.on{\n           background: #1ec241;\n            color:white;\n        }\n    }\n}\n\n```\n## 动态实现\n只要找到能实现全局使用的js即可  \n`cd`你的博客目录，然后打开 `theme -> source -> js ->xx.js` ，添加功能\n```js\n//动态append复制按钮，添加映射\n$('figure').each(function(index, el) {\n    $(this).attr(\"id\",\"figure\"+(index+1)).append(' <span class=\"copy\">复制</span>')\n        .find('.copy').attr({'data-clipboard-target':\"#figure\"+(index+1),'title':'点击复制'})\n        .click(function() {$(this).addClass('on').text('完成');});\n});\nlet clipboard = new Clipboard('.copy');\n```\n> 因每一个主题的渲染方式存在差异，具体的元素选择也应入乡随俗\n  **核心是一个复制按钮映射一个代码段**","tags":["hexo"],"categories":["hexo功能整合"]},{"title":"效果样式","url":"%2F2018%2F07%2F05%2FSwiper3-0-%E6%95%88%E6%9E%9C%E6%A0%B7%E5%BC%8F%2F","content":"整合提取各个效果对应的样式，按需所取，去除冗余\n\n## 渐变样式 <copy>\n```css\n/* Fade */\n.swiper-container-fade.swiper-container-free-mode .swiper-slide {-webkit-transition-timing-function: ease-out;-moz-transition-timing-function: ease-out;-ms-transition-timing-function: ease-out;-o-transition-timing-function: ease-out;transition-timing-function: ease-out;}\n.swiper-container-fade .swiper-slide {pointer-events: none;-webkit-transition-property: opacity;-moz-transition-property: opacity;-o-transition-property: opacity;transition-property: opacity;}\n.swiper-container-fade .swiper-slide .swiper-slide {pointer-events: none;}\n.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active {pointer-events: auto;}\n.swiper-zoom-container {width: 100%;height: 100%;display: -webkit-box;display: -moz-box;display: -ms-flexbox;display: -webkit-flex;display: flex;-webkit-box-pack: center;-moz-box-pack: center;-ms-flex-pack: center;-webkit-justify-content: center;justify-content: center;-webkit-box-align: center;-moz-box-align: center;-ms-flex-align: center;-webkit-align-items: center;align-items: center;text-align: center;}\n.swiper-zoom-container > img,.swiper-zoom-container > svg,.swiper-zoom-container > canvas {max-width: 100%;max-height: 100%;object-fit: contain;}\n```\n添加JS：`effect:'fade'`\n\n## 3D翻转\n### 公用样式 <copy>\n```css\n/* 3D Container */\n.swiper-container-3d {-webkit-perspective: 1200px;-moz-perspective: 1200px;-o-perspective: 1200px;perspective: 1200px;}\n.swiper-container-3d .swiper-wrapper,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-slide-shadow-bottom,\n.swiper-container-3d .swiper-cube-shadow {-webkit-transform-style: preserve-3d;-moz-transform-style: preserve-3d;-ms-transform-style: preserve-3d;transform-style: preserve-3d;}\n.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-slide-shadow-bottom {position: absolute;left: 0;top: 0;width: 100%;height: 100%;pointer-events: none;z-index: 10;}\n.swiper-container-3d .swiper-slide-shadow-left {background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));}\n.swiper-container-3d .swiper-slide-shadow-right {background-image: -webkit-gradient(linear, right top, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));}\n.swiper-container-3d .swiper-slide-shadow-top {background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));}\n.swiper-container-3d .swiper-slide-shadow-bottom {background-image: -webkit-gradient(linear, left bottom, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image: -webkit-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -moz-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: -o-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));}\n.swiper-container-coverflow .swiper-wrapper,.swiper-container-flip .swiper-wrapper {-ms-perspective: 1200px;}\n```\n### cube翻转 <copy>\n```css\n/* Cube */\n.swiper-container-cube .swiper-slide {visibility: hidden;-webkit-transform-origin: 0 0;-moz-transform-origin: 0 0;-ms-transform-origin: 0 0;transform-origin: 0 0;width: 100%;height: 100%;}\n.swiper-container-cube.swiper-container-rtl .swiper-slide {-webkit-transform-origin: 100% 0;-moz-transform-origin: 100% 0;-ms-transform-origin: 100% 0;transform-origin: 100% 0;}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-prev,.swiper-container-cube .swiper-slide-next + .swiper-slide {pointer-events: auto;visibility: visible;}\n.swiper-container-cube .swiper-cube-shadow {position: absolute;left: 0;bottom: 0px;width: 100%;height: 100%;background: #000;opacity: 0.6;-webkit-filter: blur(50px);filter: blur(50px);z-index: 0;}\n```\n### coverflow翻转 <copy>\n```css\n/* Coverflow */\n.swiper-container-coverflow .swiper-wrapper,.swiper-container-flip .swiper-wrapper {-ms-perspective: 1200px;}\n```\n### 添加JS代码 <copy>\n```js\neffect : 'cube',\ncube: {\n  slideShadows: true,     //开启slide阴影。默认 true。\n  shadow: true,           //开启投影。默认 true。\n  shadowOffset: 100,      //投影距离。默认 20，单位px。\n  shadowScale: 0.6       //投影缩放比例。默认0.94。\n}\n//-------华丽的分割线------------\neffect : 'coverflow',\nslidesPerView: 3,\ncoverflow: {\n  rotate: 30,              //slide做3d旋转时Y轴的旋转角度。默认50。\n  stretch: 10,             //每个slide之间的拉伸值，越大slide靠得越紧。 默认0\n  depth: 60,               //slide的位置深度。值越大z轴距离越远，看起来越小。 默认100。\n  modifier: 2,             //epth和rotate和stretch的倍率，相当于depth*modifier、rotate*modifier、stretch*modifier，值越大这三个参数的效果越明显。默认1。\n  slideShadows : false     //阴影\n},\ncenteredSlides: true,\n```","tags":["Swiper3.0"],"categories":["Swiper3.0手册"]},{"title":"局部组件","url":"%2F2018%2F07%2F05%2FSwiper3-0-%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6%2F","content":"最好不要直接直接引用完整的swiper的css文件\n要根据页面中是否包括滑动块（slides）、分页器(pagination)、前进按钮和动画等进行**精简**\n\n## 前进后退按钮 <copy>\n```css\n/* Arrows */\n.swiper-button-prev,.swiper-button-next {position: absolute;top: 50%;width: 27px;height: 44px;margin-top: -22px;z-index: 10;cursor: pointer;-moz-background-size: 27px 44px;-webkit-background-size: 27px 44px;background-size: 27px 44px;background-position: center;background-repeat: no-repeat;}\n.swiper-button-prev.swiper-button-disabled,.swiper-button-next.swiper-button-disabled {opacity: 0.35;cursor: auto;pointer-events: none;}\n.swiper-button-prev,.swiper-container-rtl .swiper-button-next {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");left: 10px;right: auto;}\n.swiper-button-prev.swiper-button-black,.swiper-container-rtl .swiper-button-next.swiper-button-black {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\");}\n.swiper-button-prev.swiper-button-white,.swiper-container-rtl .swiper-button-next.swiper-button-white {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\");}\n.swiper-button-next,.swiper-container-rtl .swiper-button-prev {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");right: 10px;left: auto;}\n.swiper-button-next.swiper-button-black,.swiper-container-rtl .swiper-button-prev.swiper-button-black {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\");}\n.swiper-button-next.swiper-button-white,.swiper-container-rtl .swiper-button-prev.swiper-button-white {background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\");}\n/* 改变背景 */\n.swiper-button-next,.swiper-button-prev{\n  width: 0.65rem;\n  height: 0.65rem;\n  background:url(//game.gtimg.cn/images/cqby/cp/a20180110bycjm/arrow.png) no-repeat center;\n  background-size: 100%\n}\n.swiper-button-prev{\n  background:url(//game.gtimg.cn/images/cqby/cp/a20180110bycjm/arrow2.png) no-repeat center;\n  background-size: 100%\n}\n```\n## 分页器 <copy>\n```css\n/* Pagination Styles */\n.swiper-pagination {position: absolute;text-align: center;-webkit-transition: 300ms;-moz-transition: 300ms;-o-transition: 300ms;transition: 300ms;-webkit-transform: translate3d(0, 0, 0);-ms-transform: translate3d(0, 0, 0);-o-transform: translate3d(0, 0, 0);transform: translate3d(0, 0, 0);z-index: 10;}\n/* Common Styles */\n.swiper-pagination-fraction,.swiper-pagination-custom,.swiper-container-horizontal > .swiper-pagination-bullets {z-index: 3;bottom: 14px;left: 0;width: 100%;}\n/* Bullets */\n.swiper-pagination-bullet {display: inline-block;border-radius: 100%;background: #000;opacity: 0.2;}\nbutton.swiper-pagination-bullet {border: none;margin: 0;padding: 0;box-shadow: none;-moz-appearance: none;-ms-appearance: none;-webkit-appearance: none;appearance: none;}\n.swiper-pagination-clickable .swiper-pagination-bullet {cursor: pointer;}\n.swiper-pagination-white .swiper-pagination-bullet {background: #fff;}\n.swiper-pagination-bullet-active {opacity: 1;background: #007aff;}\n.swiper-pagination-white .swiper-pagination-bullet-active {background: #fff;}\n.swiper-pagination-black .swiper-pagination-bullet-active {background: #000;}\n.swiper-container-vertical > .swiper-pagination-bullets {right: 10px;top: 50%;-webkit-transform: translate3d(0px, -50%, 0);-moz-transform: translate3d(0px, -50%, 0);-o-transform: translate(0px, -50%);-ms-transform: translate3d(0px, -50%, 0);transform: translate3d(0px, -50%, 0);}\n.swiper-container-vertical > .swiper-pagination-bullets .swiper-pagination-bullet {margin: 5px 0;display: block;}\n.swiper-container-horizontal > .swiper-pagination-bullets .swiper-pagination-bullet {margin: 0 5px;}\n/* 自定义进度条的样式 */\n.swiper-pagination-bullet{width: 2.2rem;height: 2.2rem;background: red;opacity:0.5;}\nspan.swiper-pagination-bullet.swiper-pagination-bullet-active{background: black;opacity: 1}\n```\n分页器切换页面  <copy>\n```js\nvar mySwiper = new Swiper ('#swiper-container1', {\n  pagination : '.swiper-pagination',  //分页器\n  paginationClickable :true        //点击分页器自动切换\n})\n```","tags":["Swiper3.0"],"categories":["Swiper3.0手册"]},{"title":"使用方法","url":"%2F2018%2F07%2F05%2Fswiper3-0-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F","content":"\n## 基本结构\n`Swiper`: 整个滑动对象，有时特指滑块释放后仍然正向移动直到贴合边缘的过程(过渡)\n`container`: Swiper的容器，包括滑块（slides）、封套（wrapper)、分页器(pagination)、前进按钮等\n`wrapper`: 触控的对象，可触摸区域，移动的块的集合，过渡时会随slide切换产生位移\n`slider`: 切换的滑块，可以包含文字、图片、html元素或另外一个Swiper\n`pagination`: 分页器，指示slide的数量和当前活动的slide\n![](https://miao.su/images/2018/07/05/swiper2fc2b.png)\n\n## 结构样式\n线上路径 <copy> \n```html\n<script src=\"//ossweb-img.qq.com/images/js/swiper/swiper-3.4.2.min.js\"></script>\n```\n\n页面结构 <copy> \n```html\n<div class=\"swiper-container\" id=\"swiper-container1\">\n  <div class=\"swiper-wrapper\">\n    <div class=\"swiper-slide\">Slide 1</div>\n    <div class=\"swiper-slide\">Slide 2</div>\n    <div class=\"swiper-slide\">Slide 3</div>\n  </div>\n  <!-- 如果需要分页器 -->\n  <div class=\"swiper-pagination\"></div>\n\n  <!-- 如果需要导航按钮 -->\n  <div class=\"swiper-button-prev\"></div>\n  <div class=\"swiper-button-next\"></div>\n\n  <!-- 如果需要滚动条 -->\n  <div class=\"swiper-scrollbar\"></div>\n</div>\n```\n基础样式 <copy>\n```css\n/* base */\n.swiper-wp8-horizontal {-ms-touch-action: pan-y;touch-action: pan-y;}\n.swiper-container {margin-left: auto;margin-right: auto;position: relative;overflow: hidden;/* Fix of Webkit flickering */z-index: 1;}\n.swiper-container-no-flexbox .swiper-slide {float: left;}\n.swiper-container-vertical > .swiper-wrapper {-webkit-box-orient: vertical;-moz-box-orient: vertical;-ms-flex-direction: column;-webkit-flex-direction: column;flex-direction: column;}\n.swiper-wrapper {position: relative;width: 100%;height: 100%;z-index: 1;display: -webkit-box;display: -moz-box;display: -ms-flexbox;display: -webkit-flex;display: flex;-webkit-transition-property: -webkit-transform;-moz-transition-property: -moz-transform;-o-transition-property: -o-transform;-ms-transition-property: -ms-transform;transition-property: transform;-webkit-box-sizing: content-box;-moz-box-sizing: content-box;box-sizing: content-box;}\n.swiper-container-android .swiper-slide,.swiper-wrapper {-webkit-transform: translate3d(0px, 0, 0);-moz-transform: translate3d(0px, 0, 0);-o-transform: translate(0px, 0px);-ms-transform: translate3d(0px, 0, 0);transform: translate3d(0px, 0, 0);}\n.swiper-container-multirow > .swiper-wrapper {-webkit-box-lines: multiple;-moz-box-lines: multiple;-ms-flex-wrap: wrap;-webkit-flex-wrap: wrap;flex-wrap: wrap;}\n.swiper-container-free-mode > .swiper-wrapper {-webkit-transition-timing-function: ease-out;-moz-transition-timing-function: ease-out;-ms-transition-timing-function: ease-out;-o-transition-timing-function: ease-out;transition-timing-function: ease-out;margin: 0 auto;}\n.swiper-slide {-webkit-flex-shrink: 0;-ms-flex: 0 0 auto;flex-shrink: 0;width: 100%;height: 100%;position: relative;}\n/* Auto Height */\n.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide {height: auto;}\n.swiper-container-autoheight .swiper-wrapper {-webkit-box-align: start;-ms-flex-align: start;-webkit-align-items: flex-start;align-items: flex-start;-webkit-transition-property: -webkit-transform, height;-moz-transition-property: -moz-transform;-o-transition-property: -o-transform;-ms-transition-property: -ms-transform;}\n\n/* 设置宽度和高度 */\n#swiper-container1{\n  width: 500px;\n  height: 500px;\n}\n.swiper-slide1{\n  background: red;\n}\n```\n初始化 <copy>\n```js\nvar mySwiper = new Swiper ('#swiper-container1', {\n  direction: 'vertical',\n  loop: true,\n// 如果需要分页器\n  pagination: '.swiper-pagination',\n\n// 如果需要前进后退按钮\n  nextButton: '.swiper-button-next',\n  prevButton: '.swiper-button-prev',\n\n// 如果需要滚动条\n  scrollbar: '.swiper-scrollbar',\n})\n```\n更多细节参考官网API:http://3.swiper.com.cn/api/index.html","tags":["Swiper3.0"],"categories":["Swiper3.0手册"]},{"title":"添加本地搜索","url":"%2F2018%2F07%2F04%2Fhexo--%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%2F","content":"\n随着文章数量的不断增加，目录和标签已经不能满足我们的需求，添加本地搜索有助于我们对所需资源进行快捷定位\n## 安装搜索插件\n`cd`你的博客目录，鼠标右键选择`Git Bash Here`  <copy>\n```\n$ npm install hexo-generator-searchdb --save\n```\n## 修改站点配置文件\n在`_config.yml`添加搜索支持 <copy>\n```yml\nsearch：\n    path: search.xml\n    field: post\n    format: html\n    limit: 10000\n```\n\n## 开启搜索功能\n修改主题目录下的`_config.yml` <copy>\n```yml\nlocal_search:\n    enable: true\n```","tags":["hexo"],"categories":["hexo功能整合"]},{"title":"Hexo + Github","url":"%2F2018%2F07%2F04%2Fhexo--Hexo%2BGithub%2F","content":"利用Hexo+Github搭建个人博客\n## 安装Git + nodejs\nGit: https://www.git-scm.com/download/\nNode.js: https://nodejs.org/zh-cn/\n\n## 安装hexo\n```\n$ npm install hexo-cli -g                   //全局安装hexo\n$ hexo init blog\t\t            //创建blog文件并且初始化\n$ cd blog\t\t\t            //进入刚才创建的blog文件\t\n$ npm install\t\t\t\t    //安装各种依赖\n$ hexo server\t\t\t\t    //启动服务\n```\n## 配置个人用户信息\n```\n$ git config --global user.name \"yourname\"          //用户名\n$ git config --global user.email \"yourEmail\"        //邮箱\n\n```\n在`_config.yml`中添加关联的仓库地址   <copy>\n```yml\ndeploy:\n  type: git\n  repo: git@github.com:yourname/yourname.github.io.git\n  branch: master\n```\n\n## 创建SSH\n**SSH**是一种网络协议，用于计算机之间的加密登录  <copy>\n```\nssh-keygen -t rsa -C \"youremail@example.com\n```\n进入文件找到`key`\n```\n$ cd ~/.ssh\n$ cat id_rsa.pub\n```\n图中蓝色区域\n![](https://miao.su/images/2018/07/04/ssshfacdb.png)\n\n## 配置Github\n新建一个名为`yourname.github.io`的仓库\n在全局`settings`里面配置**SSH**，把`key`复制进里面，`titile`自拟\n![](https://miao.su/images/2018/07/04/kryb9a07.png)\n\n## 部署\n安装部署插件  <copy>\n```\n$ npm install hexo-deployer-git --save\n```\n依次输入\n```\n$ hexo clean\n$ hexo g\n$ hexo d\n```\n访问: `https://yourname.github.io/`","tags":["hexo"],"categories":["hexo功能整合"]},{"title":"Axios+Mock","url":"%2F2018%2F07%2F02%2FVue--Axios%2BMock%2F","content":"## 目录结构\n\n`Axios`用于前后端通信，`mock.js`用于模拟随机数据，搭配使用旨在脱离后端进行开发测试。\n\n```\n|-- data                            // 目录示例\n\n     |-- api.js                     // 统一管理axios所有的请求\n\n     |-- index.js            \t    // 拦截请求\n\n     |-- mock-data.js               // 模拟数据\n\n```\n\n## 模拟随机数据（**data / mock-data.js**）\n\n```js\n//引入mock\nimport Mock from 'mockjs';\n//模拟用户\nconst LoginUsers = {\n  id: 1,\n  username: 'USER3114001996',\n  password: '123456',\n  num:'3114001996',\n  year:'2014',\n  departments:'信息工程学院',\n  program:'轨道交通电气化',\n  cla:'140716',\n  sec:'男',\n  desc:'如有信息错误，请及时反馈~~',\n  name: Mock.Random.cname(),\n  phone: Mock.mock(/^\\d{11}/),\n  weChat: Mock.mock(/^\\d{9}/),\n  pas:  Mock.Random.id(),\n  schoolNum:Mock.mock(/^\\d{10}/),\n  address: Mock.Random.province() +Mock.Random.city()+Mock.Random.county(true)\n};\n//导出数据\nexport {LoginUsers};\n```\n\n## 拦截请求（**data / index.js**）\n```js\n//依赖\nlet axios = require('axios');\nlet MockAdapter = require('axios-mock-adapter');\n//通过axios-mock-adapter生成代理api地址\n//导入数据\nimport {Users,course,schedule} from \"./mock-data\"\nexport default {\n  init() {\n    //实例化\n    let mock = new MockAdapter(axios);\n\t//拦截带参数的请求，reply的参数为 (status, data, headers)\n    mock.onGet('/login').reply(config => {\n      let username = config.username;  //存储请求数据\n      let password = config.password;\n      return new Promise((resolve, reject) => {\n        let hasUser = (Users.username==username && Users.password==password)?true:false;\n          //匹配成功\n        if (hasUser) {\n          resolve([200, { code: 200, msg: '请求成功' }]);\n        } else {\n          resolve([200, { code: 500, msg: '账号或密码错误' }]);\n        }\n      })\n    });\n\n    //拦截没有参数的请求\n    mock.onGet('/card').reply(200, {\n      LoginUsers: LoginUsers     //返回的对象\n    });\n    mock.onGet('/plan').reply(200, {\n      course: course\n    });\n  }\n}\n```\n## 通过管理请求（**data / api.js**）\n```js\n//统一管理axios所有的请求\nimport axios from 'axios'\nlet base = '';  //${base}/xx 为路径\n//获取登录信息 \nexport const requestLogin = params => axios.get(`${base}/login`,params).then(res => res.data);\n//获取卡片信息\nexport const cardMessage = params => axios.get(`${base}/card`,params).then(res => res.data);\n//获取培养计划\nexport const getPlan = params => axios.get(`${base}/plan`,params).then(res => res.data);\n//获取课程表\nexport const schedule = params => axios.get(`${base}/schedule`,params).then(res => res.data);\n\n```\n## 使用请求\n首先引入api文件   <copy>\n```js\n  import {requestLogin} from '../../data/api'\n```\n然后在有需要的地方使用引入的方法   <copy>\n```js\n  export default {\n    name: \"Login\",\n    data() {\n      return {\n        test: {\n          name: 'USER3114001996',\n          region: '123456'\n        },\n        checked: true,\n        loading:false\n      }\n    },\n    methods:{\n      enter(){\n        this.loading = true;\n        //发送axios请求并且传递用户参数\n        let loginParams = { username: this.test.name, password: this.test.region };\n        requestLogin(loginParams).then((data) => {\n          let { msg, code, user } = data;\n          if(code!==200){\n            this.loading = false;\n            this.$message({\n              message: msg,\n              type: 'error',\n              duration:1200\n            });\n          }else{\n            this.loading = false;\n            //请求成功后跟换路径，跳转路由\n            this.$router.push({ path: '/Card' });\n          }\n        })\n      }\n    }\n  }\n```","tags":["vue2.0"],"categories":["Vue使用手册"]},{"title":"Vuex参考","url":"%2F2018%2F07%2F02%2FVue--Vuex%2F","content":"\nvuex是数据仓库，同时也是状态管理器\n## 使用方法\n新建js文件\n![](https://miao.su/images/2018/07/04/vuex1684a3.png)\n写入store.js   <copy>\n```js\n//引入依赖\nimport  Vue from 'vue';\nimport  Vuex from 'vuex';\nVue.use(Vuex);\n\nconst state ={  //state是状态\n  count:1       //count是公用的数据，放在状态里面\n};\n//暴露出去\nexport default new Vuex.Store({\n  state\n})\n```\n在组件中使用（**app.vue**）   <copy>\n```html\n<!-- 使用$.store.state获取状态 -->\n<h2>{{message}}</h2>\n<h3>这是数据仓库的值：{{$.store.state.count}}</h3>\n```\n**①**使用`computed`简化指令（**app.vue**）  <copy>\n```js\ncomputed:{   //computer用于临时计算，返回一个对象\n  count(){   //这里把count的值指向为  this.$store.state.count\n    return this.$store.state.count\n  }\n}\n```\n现在，`count`的值就有了，而且指向为`this.$store.state.count `\n这个时候就可以这么写   <copy>\n```html\n<h3>这是数据仓库的值：{{$store.state.count}}--{{count}}</h3>\n```\n**②**使用`mapState`简化指令（**app.vue**）\n引入和添加（**app.vue**）   <copy>\n```js\n//引入mapState\nimport {mapState} from 'vuex'\n//添加方式\ncomputed:mapState(['count'])\n```\n\n\n## 改变数据的值\n通过mutations来改变state里面的值(**store / vuex.js**)   <copy>\n```js\nconst mutations = {\n  add(state,n){    //第一个是状态参数，第二个是自定义参数\n    state.count+=n;\n  }\n};\n//把状态和方法都暴露出去\nexport default new Vuex.Store({\n  state,mutations\n})\n```\n在组件里接收数据（**app.vue**）   <copy>\n```js\nimport store from  '@/vuex/store';  //接收数据\nimport { mapState,mapMutations } from 'vuex';\n  export default {\n    data(){\n      return {\n        message:'hello world'\n      }\n    },\n    store,  //接收数据\n    methods:mapMutations([\n        'add','reduce'\n    ]),\n  }\n```\n使用数据（**app.vue**）   <copy>\n```html\n<h3>{{count}}</h3>\n<button @click=\"$store.commit('add',10)\">增加</button>\n<!--只能通过 $store.commit（）调用方法--\n```\n\n\n","tags":["vue2.0"],"categories":["Vue使用手册"]},{"title":"Vue搭建项目","url":"%2F2018%2F07%2F02%2FVue--%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F","content":"## 在使用vue搭建项目之前，要安装所需依赖\n+ 安装 `nodejs`\n+ 安装 `webpack`:`$ npm install webpack -g`\n+ 安装 `vue-cli`:`$ npm install vue-cli -g`\n> 鉴于国内网络限制，可以选择切换镜像源\n`npm install -g cnpm --registry=https://registry.npm.taobao.org`\n> `npm install`不推荐使用国内镜像\n\n\n## 初始化项目文件\n+ 创建一个名为“Abc”的初始化文件夹 `\tvue init webpack Abc` \n+ 如果已经提前建好了文件夹，则只需在该文件夹内 `vue init webpack`\n+ 如果`node_modules`没有安装，则`npm install`\n+ 使用`npm run dev`启动\n\n\n## 配置路由\nvue适合用来构建SPA应用，所以路由嵌套很正常。\n在入口页面**App.html**中，`router-view`是路由区域。单页面的切换就在该区域。  <copy>\n```html\n<template>\n  <div id=\"app\">\n    <transition name=\"fade\"\n                mode=\"out-in\">\n      <router-view></router-view>\n    </transition>\n  </div>\n</template>\n```\n#### 引入路由组件(**src / router / index.js**)  <copy>\n```js\n//依赖\nimport Vue from 'vue'\nimport Router from 'vue-router'\n//主路由\nimport Main from '@/components/Main'\n//分路由\nimport Login from '@/components/Login'              //登录页面\nimport Card from '@/components/pages/Card'          //学籍卡片\n```\n#### 设置路由的跳转(**src / router / index.js**)  <copy>\n```js\nexport default new Router({\n  // mode: 'history',\n  routes: [\n    {path: '*',\n      hidden: true,\n      redirect: { path: '/404' }  //重定向404\n    },\n    {\n      path: '/login',             //路径\n      component: Login,           //组件\n      name:'',\n    },\n    {\n      path: '/404',             \n      component: notFound,\n      name:'',\n    },\n    {\n      path: '/',\n      leaf: true,\n      icon:'icon-myschedule',    //参数，传递给路由页面进行渲染\n      iconColor:'#d10dff',\n      component: Main,\n      main:true,\n      name:'',\n      children:[\n        { path: '/Plan', component: Plan, name: '培养方案' }\n      ]\n    }\n  ]\n})\n```\n#### 链接跳转(**src / components / xx.vue**)  <copy>\n```html\n  <div class=\"hello\">\n    <router-link to=\"/\"></router-link>\n    <!--使用to来跳转，对应路由文件里面的path-->\n  </div>\n```\n> 获取路由参数：`v-for=\"(item,index) in $router.options.routes`\n  使用参数：`item.children[n].path`","tags":["vue2.0"],"categories":["Vue使用手册"]},{"title":"jQuery常用操作","url":"%2F2018%2F06%2F29%2FjQuery--%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F","content":"\n收集和整合jquery常用操作，便于快速查询和使用，提升开发效率。\n## 判断滚动条位置   <copy>\n```js\n$(window).scroll(function(event) {\n  if ($('html,body').scrollTop() > $('.sect1').height()) {\n    //do something\n  } else {\n    //do something\n  }\n});\n\n```\n\n## 导航按钮  <copy>\n\n```js\n//pc端\nfunction bodyMove(num) {\n   $(\"html,body\").animate({\n      scrollTop: num\n   }, 400, function() {});\n}\n$('.nav').each(function(index, el) {\n  $(this).click(function(event) {\n    var href = $(this).attr('data-href');\n    bodyMove($(href).offset().top);\n  });\n});\n\n//zepto没有animate\nfunction bodyMove(num) {\n  $(\"html,body\").scrollTop(num);\n}\n```\n\n## 获取鼠标位置  <copy>\n\nscreenX：相对于`屏幕`的坐标\n\nclientX：相对于`浏览器内容区域 `的坐标（不包括滚动条隐藏的部分）\n\npageX：相对于`页面文档`的坐标，和浏览器宽高无关\n\noffsetX：相对于`盒子模型`里面的坐标，和浏览器宽高无关\n\n```js\nfunction getCoordinates(e,t) {\n    return site = {\n        x:e[t+'X'],\n        y:e[t+'Y'],\n    }\n}\n$('body').mousemove(function(event) {\n    console.log(getCoordinates(event,'client'));\n});\n```\n\n## 选择同辈元素  <copy>\n\n```js\n//zepto和jquery均适用\n$('.box').click(function(event) {\n    $(this).addClass('active').siblings().removeClass('active');\n});\n```\n\n## 对元素进行判断  <copy>\n\n```js\nif (!$('.nav').length) {}        //检测元素是否存在\nif (!$('.key').html()) {}        //检测元素是否为空（不包括自身）\nif (!$('.key').is(':empty')) {}  //检测元素是否为空（包括自身）\n```\n\n## 阻止移动端浏览器页面滑动 <copy>\n```js\ndocument.body.addEventListener('touchmove',bodyScroll,false);\n// 去除默认事件\nfunction bodyScroll(event){\n    event.preventDefault();\n}\n```\n","tags":["jQuery"],"categories":["jQuery使用手册"]},{"title":"弹窗组件","url":"%2F2018%2F06%2F14%2FTX-%E5%BC%B9%E7%AA%97%E7%BB%84%E4%BB%B6%2F","content":"\n为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。\n\n### 在文档底部添加引用  <copy>\n```js\n<script src=\"//ossweb-img.qq.com/images/js/comm/showDialog.min.js\"></script>\n```\n### 结构  <copy>\n```html\n<div class=\"pop\" id=\"\">\n <a href=\"javascript:showDialog.hide()\" class=\"close\" onclick=\"PTTSendClick('btn','close','关闭弹窗');\"></a>\n</div>\n```\n> 弹窗的高度一般不要超过`550px`\n为每一个弹窗添加特定的`id`,方便调用以及更改样式\n写样式之前，对弹窗相同样式进行抽取，**具体到不同的弹窗具体修改**\n\n参考代码如下:   <copy>\n```css\n/*------popCom------*/\n.pop{\n  position: relative;\n  display: none;\n  overflow: hidden;\n  width: 6.6rem;\n  margin-left: -3.3rem !important;\n  text-align: center;\n  background: url(ossweb-img/pop-bg.png) repeat;\n}\n.pop .close{\n  position: absolute;\n  top: 0.2rem;\n  right: 0.2rem;\n  width: 0.26rem;\n  height: 0.26rem;\n  background: url(ossweb-img/close.png) no-repeat center;\n  background-size: 100%;\n}\n/* ways */\n#ways{\n  height: 3.6rem;\n}\n#ways .title{\n  margin-top: 0.65rem;\n}\n```\n### 显示弹窗   <copy>\n\n```js\nshowDialog.show('id');  //对于不同弹窗，更换不同的id即可\n```\n### 隐藏弹窗   <copy>\n```js\nshowDialog.hide();\n```\n### 是否可滚屏\n\n当弹窗出现时屏幕是否可以滚动，取决于客户需求，参看代码   <copy>\n```js\n$('body,html').css('overflowY', 'hidden'); //隐藏滚动条，弹窗初始化启用\n$('body,html').css('overflowY', 'auto');   //显示滚动条，弹窗关闭后启用\n```","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"兼容措施","url":"%2F2018%2F06%2F13%2FCSS%E6%89%8B%E5%86%8C--%E5%85%BC%E5%AE%B9%E6%8E%AA%E6%96%BD%2F","content":"\n\n\n## 透明度`opcaity` <copy>\n\n```css\n.ele{\n  opacity: 1;\n  filter: progid:DXImageTransform.Microsoft.Alpha(opacity=100);  \n}\n```\n\n## 让ie低版本支持`inlline-block` <copy>\n\n```css\n.ele{\n  display: inline-block;\n  *display: inline;\n  *zoom: 1\n}\n```\n\n## 解决Chrome在应用transition时页面闪动的问题？ <copy>\n\n```css\n-webkit-transform-style:preserve-3d;\n/* 或者 */\n-webkit-backface-visibility:hidden;\n```\n\n## 解决移动端的滑动事件总是出现无法侦听被动事件\n\n在使用有些移动端插件时，如果使用了滑动事件，可能会报错 <copy>\n\n`Unable to preventDefault inside passive event listener due to target being treated as passive`\n\n```css\n* { touch-action: none; }\n```\n\n## flex垂直居中兼容性写法 <copy>\n```css\n.flex{\n  text-align: center;\n  font-size: 18px;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-pack: center;\n  -ms-flex-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n}\n```\n## 控制文字超出省略（移动端） <copy>\n```css\ndisplay: -webkit-box;\n-webkit-box-orient: vertical;\n-webkit-line-clamp: 3;   /*只显示三行*/\noverflow: hidden;\n```\n\n## 解决tr、th设置border失效  <copy>\n```css\n/*因为table的border覆盖了tr、th的border*/\ntable{\n    border-collapse: collapse;\n}\n\n```\n\n## 解safari滚动卡顿\n\n```css\n.main{\n      overflow-y: scroll;\n      -webkit-overflow-scrolling: touch;\n}\n```\n\n## 修改滚动条样式\n```css\n\n/* 高度或宽度是缺省值 */\n.CLASSSTYLE::-webkit-scrollbar {\n    width: 8px;\n    height: 8px;\n}\n\n```\n\n::-webkit-scrollbar 滚动条整体部分  \n::-webkit-scrollbar-thumb  滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）  \n::-webkit-scrollbar-track  滚动条的轨道（里面装有Thumb）  \n::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。  \n::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去）  \n::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处  \n::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件  \n\n\n## 改变文字选中的样式\n```css\nfigure::selection {\n    background: #95fff1;\n}\nfigure::-moz-selection{\n    background: #95fff1;\n}\n```","tags":["CSS兼容"],"categories":["CSS手册"]},{"title":"flex布局","url":"%2F2018%2F06%2F05%2Fflex%E5%B8%83%E5%B1%80%2F","content":"弹性布局是未来布局的发展趋势，现代浏览器均对flex实现了不同程度的支持，但是如果要兼容老版本的浏览器，则还是应该回归原始的布局方式。\n<!-- more -->\n## 基本概念\n### 容器和项目\n\n弹性布局的实现需要一个容器，也就是flex容器。只要把父元素的`display`设置为`flex`，则他的子元素就全部成为了flex项目\n### 主轴和交叉轴\n\n主轴（`main axis`）处于水平方向，是`x`轴。起点叫`main start`，终点叫做`main end`。\n交叉轴（`cross axis`）处于垂直方向，是`y`轴。起点叫`cross start`，终点叫做`cross end`。\n![](http://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png)\n\n## 容器属性\n\n### `flex-direction`  <copy>\n该属性决定项目的拍排列方向,有:\n水平方向：`row`（从左到右），`row-reverse`（从右到左）;\n垂直方向：`column`（从上到下），`column-reverse`（从下到上）\n```css\n.box{\n  flex-direction: column|column-reverse|row|row-reverse;\n}\n```\n![](https://miao.su/images/2018/06/05/0cbe5f8268121114e87d0546e53cda6e2131a.png)\n\n### `flex-wrap`\n改属性决定了项目溢出容器时候的处理方式，默认是自动收缩不换行（`nowrap `）\n不换行，水平方向自动收缩：`nowrap`\n![](https://miao.su/images/2018/06/05/nowrap18e54.png)\n换行：`warp`\n![](https://miao.su/images/2018/06/05/wrap95d91.png)\n换行之后反向：`wrap-reverse`\n![](https://miao.su/images/2018/06/05/wrap-reverse6c2a3.png)\n\n> 如果设置了项目的宽度，并且项目的`总宽度之和>容器的宽度`，在设置了不换行`nowarp`的情况下，`项目宽度`会被`自动压缩`，不超过容器范围\n\n### `flex-flow`\n是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。\n优先使用这个属性。\n\n### `justify-content` \n该属性决定项目在主轴(`x轴`)上的对其方式  <copy>\n```css\n.box{\n   justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n![](https://miao.su/images/2018/06/05/wsdsaa727.png)\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n+ `flex-start（默认值）`：左对齐\n+ `flex-end`：右对齐\n+ `center`： 居中\n+ `space-between`：两端对齐，项目之间的间隔都相等。\n+ `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n### `align-items`   <copy>\n该属性决定项目在交叉轴(`y轴`)上的对其方式 \n```css\n.box{\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n![](https://miao.su/images/2018/06/05/baseline1286d.png)\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n+ `flex-start`：交叉轴的起点对齐。\n+ `flex-end`：交叉轴的终点对齐。\n+ `center`：交叉轴的中点对齐。\n+ `baseline`: 项目的第一行文字的基线对齐。\n+ `stretch（默认值）`：如果项目未设置高度或设为auto，将占满整个容器的高度。\n<div class=\"tip\">\n    尤其要注意，如果项目没有设置具体高度，那么他会默认`填充满容器`\n</div>\n\n### `align-content`\n多轴属性，当换行的时候，会有多个主轴或者交叉轴的存在。该属性和主轴对其方式是一致的。  <copy>\n```css\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n![](https://miao.su/images/2018/06/05/js64812.png)\n\n\n## 项目属性\n###  `order`\n排列顺序。数值越小，排列越靠前，默认为0  <copy>\n```css\n.flex-item {\n  order: <integer>;\n}\n```\n### `flex-grow`\n放大比例，默认为0，即如果存在剩余空间，也不放大  <copy>\n```css\n.flex-item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n > 如果一个项目的`flex-grow`属性为`2`，其他项目都为`1`，则前者占据的剩余空间将比其他项多一倍。\n\n### `flex-shrink`\n缩小比例，默认为1，即如果空间不足，该项目将缩小  <copy>\n```css\n.flex-item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n负值对该属性无效。\n### `flex-basis`\n分配多余空间之前，项目占据的主轴空间（`main size`），也就是固定宽度  <copy>\n```css\n.flex-item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n### `flex`\n 是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值`0 1 auto`。后两个属性可选\n### `align-self`\n 单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性\n![](https://miao.su/images/2018/06/05/TIM201806051153463325d.png)\n\n## 小实例\n用弹性布局实现百分比高度的文字垂直居中\n<iframe width=\"100%\" height=\"160\" src=\"http://jsrun.net/LSZKp/embedded/all/light/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe></body>\n考虑到浏览器的兼容性差异，最好flex相关属性都加上浏览器内核前缀\n","tags":["flex"],"categories":["弹性布局"]},{"title":"视频弹窗","url":"%2F2018%2F03%2F15%2FTX-%E8%A7%86%E9%A2%91%E6%8F%92%E4%BB%B6%2F","content":"\n为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。\n\n\n## PC视频\n### 引用视频组件   <copy>\n\n```html\n<script src=\"//ossweb-img.qq.com/images/js/comm/showDialog.min.js\"></script>\n<script src=\"//vm.gtimg.cn/tencentvideo/txp/js/txplayer.js\"></script>\n```\n\n### 结构样式及调用 \n \nhtml    <copy>\n```html\n<!-- 视频弹窗 -->\n<div class=\"pop\" id=\"vindex-play\">\n  <span class=\"btn-pop-close\" onclick=\"hideVideo();\" title=\"点击关闭\" onclick=\"PTTSendClick('btn','close','关闭弹窗');\">×</span>\n  <div class=\"pop-con\" id=\"vplay-con\" style=\"padding-top: 0\"></div>\n</div>\n```\n\ncss   <copy>\n```css\n/*--------video---------*/\n#vindex-play {position:relative;display: none;width:800px;height:500px;padding-top: 0;border:2px solid #e9d7a5;background: none;}\n#vindex-play .btn-pop-close{position:absolute;top:-2px;right:-41px;display:block;width:40px;height:40px;cursor: pointer;text-align:center;text-decoration: none;color:#fff;background-color: #e9d7a5;font-family:Tahoma;font-size:30px;line-height:36px;}\n#vindex-play .btn-pop-close:hover {text-decoration:none;color:#fff;}\n#vindex-play .pop-con,#vindex-play .pop-con .tenvideo_player{width: 800px;height: 500px;}\n```\n\njs   <copy>\n```js\n// pc视频弹窗方法\nfunction playVideo(e,vid) {\n  showDialog.show({id:e});  //e为弹窗,vid为视频编码\n  var player = new Txplayer({\n    containerId: 'vplay-con',\n    vid: vid,\n    width: '100%',\n    height: '100%',\n    autoplay: false\n  });\n}\n// 关闭pc视频弹窗方法\nfunction hideVideo() {\n  var flv_s = document.getElementById(\"vplay-con\");\n  if (flv_s){\n    flv_s.innerHTML= \"\";\n  }\n   showDialog.hide();\n}\n```\n\n调用\n\n```js\nonclick=\"playVideo('vindex-play','q0625wf8pcn')\"\n```\n\n## H5视频\n### 引用视频组件\n\n```html\n<script src=\"//ossweb-img.qq.com/images/js/comm/showDialog.min.js\"></script>\n<script src=\"//imgcache.gtimg.cn/tencentvideo_v1/tvp/js/tvp.player_v2.js\" charset=\"utf-8\"></script>\n```\n### 结构样式及调用\n\nhtml\n\n```html\n<!-- 视频弹窗 -->\n<div id=\"videoPlayer\" class=\"video_player\"></div>\n<i id=\"videoClose\" class=\"video_close\">×</i>\n```\n\ncss\n\n```css\n/*--------video---------*/\n.video_player {position: fixed;z-index: 10011;top: 0;left: 0;display: none;width: 100%;height: 100%;background: #000;}\n.video_close {position: fixed;z-index: 10014;top: 2%;right: 4%;display: none;width: 0.4rem;height: 0.4rem;text-align: center;color: #0091de;background: #000;font-size: 0.8rem;font-weight: 700;line-height: 0.6rem;}\n```\n\njs\n\n```js\n//视频\nvar showVideo = function(vid){\n  var video = new tvp.VideoInfo();\n  video.setVid(vid);  //视频码\n  var player = new tvp.Player();\n    player.create({\n    width:\"100%\",\n    height:\"100%\",\n    video:video,\n    modId:\"videoPlayer\",\n    isHtml5UseAirPlay:true,\n    isHtml5UseFakeFullScreen:true,\n    autoplay:false\n  });\n    $('#videoPlayer').show();\n    $('#videoClose').show();\n};\n$('#videoClose').on(\"click\",function(){\n  $('#videoPlayer').hide().html(\" \");\n  $('#videoClose').hide();\n});\n```\n\n调用\n\n```js\nonclick=\"showVideo('r0539nr9q6d');\"\n```\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"H5端构建","url":"%2F2018%2F03%2F14%2FTX-%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F","content":"\n\n\n## 结构样式\n为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。\n### html  <copy>\n\n```html\n<div class=\"part part1\"></div>\n<div class=\"part part2\"></div>\n```\n\n### css  <copy>\n\n```css\n.part1{height: 3rem;background: url() no-repeat center;}\n.part2{height: 3rem;background: url() no-repeat center;}\n.part{position: relative;width: 7.5rem;overflow: hidden;background-size: 100%;}\n```\n\n## 组件上报  <copy>\n\n```js\nontouchend=\"PTTSendClick('btn','back','返回官网')\"\n```\n\n## 分离路径\n传奇霸业:`//game.gtimg.cn/images/cqby/cp/a20180223bsdm/`\n御龙在天:`//game.gtimg.cn/images/ylzt/cp/a20180124jymtm/`\n传奇世界:`//game.gtimg.cn/images/cqsj3d/cp/a20180223bsdm/`\n梦幻诛仙:`//game.gtimg.cn/images/mhzx/cp/a20180418gcwfm/`\n轩辕传奇:`//game.gtimg.cn/images/xycq/cp/a20180423jyxtm/`\nQQ炫舞: `//game.gtimg.cn/images/x5m/cp/a20180516bbztm/`\n## 链接跳转\n传霸官网:`//shuang.qq.com/m/`\n御龙官网:`//ylzt.qq.com/m/`\n传世官网:`//3d.qq.com/`\n[传世兴趣部落](//buluo.qq.com/p/barindex.html?bid=399251) /[传世游戏论坛](//bbs.g.qq.com/forum-57808-1.html) /[传世公众号](//game.weixin.qq.com/cgi-bin/comm/openlink?noticeid=90127011&appid=wx96a8b9ae096de54d&url=https%3A%2F%2Fgame.weixin.qq.com%2Fcgi-bin%2Fh5%2Fstatic%2Fsubscribe%2Findex.html%3Fappid%3Dwx96a8b9ae096de54d#wechat_redirect) /[传世微博](//weibo.com/u/6077836537?refer_flag=1001030101_ )\n梦诛官网:`//mhzx.qq.com/m/`\n轩辕官网:`//xycq.qq.com/m/`\n炫舞官网:`//x5m.qq.com/m/m201711/`\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"微区构建","url":"%2F2018%2F03%2F13%2FTX-%E5%BE%AE%E7%A4%BE%E5%8C%BA%2F","content":"\n\n\n## 结构样式\n为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。\n### html  <copy>\n```html\n<div class=\"wrapper\">\n    <div class=\"part part1\"></div>\n    <div class=\"part part2\"></div>\n</div>\n```\n\n### css  <copy>\n```css\n.wrapper,.part{position:relative;margin: 0 auto;overflow: hidden;background-size: 100%;width:7.5rem; }\n.part1{height: 2rem;background: url() no-repeat center top}\n.part2{height: 3rem;background: url() no-repeat center top}\n```\n\n## 组件上报  <copy>\n```js\nontouchend=\"PTTSendClick('btn','back','返回官网')\"\n```\n\n## 分离路径 \n御龙在天:`//game.gtimg.cn/images/ylzt/ingame/cp/a20180604sxfylig/ `\n梦幻诛仙:`//game.gtimg.cn/images/mhzx/ingame/cp/a20180604sxfylig/`\nQQ炫舞: `//game.gtimg.cn/images/x5m/ingame/cp/a20180604sxfylig/`\n\n## 链接跳转\n御龙官网:`//ylzt.qq.com/ingame/all/`\n梦诛官网:`//mhzx.qq.com/ingame/all/`\n炫舞官网:`//x5m.qq.com/ingame/all/`\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"分享蒙层","url":"%2F2018%2F03%2F11%2FTX-%E5%88%86%E4%BA%AB%E8%92%99%E5%B1%82%2F","content":"\n\n\n### 使用说明\n针对移动设备浏览方式的差异，分为两种分享方式：右上角和下方\n对浏览方式进行判断然后选用适合的蒙层\n\n### 结构   <copy>\n```html\n<!-- 右上角分享蒙层 -->\n<div class=\"share share-right\">\n  <img src=\"share.png\" alt=\"share\" class=\"share-icon\">\n  <p>点击右上角分享给好友</p>\n</div>\n<!-- 下方分享蒙层 -->\n<div class=\"share share-down\">\n  <p>点击下方导航栏,分享给好友</p>\n</div>\n```\n\n### 样式  <copy>\n```css\n/* share */\n.share{position: fixed;z-index: 2;top: 0;display: none;width: 100%;height: 100%;text-align: center;color: white;background: rgba(12, 12, 12, 0.91);font-size: 0.4rem;}\n.share-right p{margin-left:25%;}\n.share-right img.share-icon {width: 1.42rem; margin: 12% 0 0 58%;}\n.share-down p{margin-top: 90%;font-size: 0.35rem;}\n```\n### 判断方法\n展开和关闭  <copy>\n```js\n//判断分享类型\nvar ua = navigator.userAgent.toLowerCase();\nif ((ua.match(/MicroMessenger/i) == 'micromessenger') || (ua.match(/QQ/i) == \"qq\") || (ua.match(/WeiBo/i) == \"weibo\")) {\n  $('.share-right').show();\n} else {\n  $('.share-down').show();\n}\n//关闭蒙层\n$.each(['.share-right', '.share-down'], function(index, value) {\n  $(value).click(function(event) {\n    $(this).hide();\n  });\n});\n```\n### 分享图标\n\n[跳转下载](http://miao.su/images/2018/04/19/share173a4.png)","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"PC端构建","url":"%2F2018%2F03%2F11%2FTX-PC%E7%AB%AF%2F","content":"\n\n\n## 结构样式\n为了增强团队的协作和高效开发，提升代码质量 ，综合整理解决方案。\n### html  <copy>\n```html\n<div class=\"part part1\">\n  <div class=\"content\"></div>\n</div>\n```\n\n### css <copy>\n```css\n/*---sect---*/\n.part{position: relative;min-width: 1180px;}\n.content{position: relative;overflow: hidden;width: 1180px;margin: 0 auto;}\n.part1{background: url(ossweb-img/part1.jpg) no-repeat center top;}\n.part2{background: url(ossweb-img/part2.jpg) no-repeat center top;}\n.part1 .content{height: 650px;}\n.part2 .content{height: 491px;}\n```\n\n## 组件上报  <copy>\n```js\nonclick=\"PTTSendClick('btn','back','返回官网')\"\n```\n\n## 分离路径 \n传奇霸业:`//game.gtimg.cn/images/cqby/cp/a20180223bsd/`\n御龙在天:`//game.gtimg.cn/images/ylzt/cp/a20180223bsd/`\n传奇世界:`//game.gtimg.cn/images/cqsj3d/cp/a20180223bsd/`\n梦幻诛仙:`//game.gtimg.cn/images/mhzx/cp/a20180223bsd/`\n轩辕传奇:`//game.gtimg.cn/images/xycq/cp/a20180223bsd/`\nQQ炫舞: `//game.gtimg.cn/images/x5m/cp/a20180223bsd/`\n## 链接跳转\n传霸官网:`//shuang.qq.com/`\n御龙官网:`//ylzt.qq.com/`\n传世官网:`//3d.qq.com/`\n梦诛官网:`//mhzx.qq.com/`\n轩辕官网:`//xycq.qq.com/`\n炫舞官网:`//x5m.qq.com/web201711/main.shtml`\n","tags":["供应商"],"categories":["TX-解决方案"]},{"title":"call和apply","url":"%2F2017%2F09%2F22%2FJS--call%20%E5%92%8C%20apply%2F","content":"\n每个函数都有`call`和`apply`方法，可以用来改变this的指向，或者说，用`call`和`apply`来帮助对象，去调用某个函数的方法\n\n## 使用场景\n比如某个对象想用它本身没有的方法，但是又不想重写，就可以使用`call`和`apply`去调用其他函数的方法 <copy>\n\n```js\n Array.prototype.slice.call(arguments)\n```\n<!--more-->\n这时候的`this`并不是一个`Array`，因为需要借用`Array`类的方法，所以使用了`call`\n\n再来看一个栗子： <copy>\n\n```js\nvar cat = {\n  object:'怪兽'\n}\nvar superman ={\n  object:'鱼'\n}\nsuperman.beat = function () {\n  console.log(this.object);\n}\n//猫调用superman的beat的方法，但是它本身是没有这个方法的\nsuperman.beat.call(cat);\n```\n\n## 作用总结\n所以其实`call`和`apply`有两个作用\n> ① 改变this的指向\n> ② 让某个对象不用重写方法去调用其他对象的方法\n\n换个层面来说，其实，当一个函数作为一个对象的方法被调用的时候，`this`指向的就是这个对象，比如说 <copy>\n\n```js\nvar cat ={\n  speak:function () {\n    console.log('我是猫的方法');\n  }\n}\ncat.speak()\n```\n\n所以，当使用`apply`和`call`的时候，该对象就有了新的方法。所以，为什么会改变`this`的指向，其实和上面的一样，函数作为这个对象的方法调用了 <copy>\n\n```js\nsuperman.beat.call(cat);\n//相当于\ncat.beat()\n//所以this就指向了cat对象\n```\n\n最后看一个栗子加深理解 <copy>\n\n```js\nvar a = 3;\nvar cat ={\n  a:1\n}\nvar ani = function () {\n  console.log(this.a);\n}\nani();   //3  直接调用，this指向window\nani.apply(cat)  //1  作为cat的方法调用，this指向对象cat\n```\n\n\n\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"数组型对象的实现","url":"%2F2017%2F09%2F22%2FJS--%E6%95%B0%E7%BB%84%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%2F","content":"\n在jQuery中，如果调用`$`函数访问一个元素，例如`  console.log($('div'));`，则会返回一个数组型对象。可以借助循环添加的方式实现 <copy>\n```js\nvar o = {};\narray = ['p','a']\nfor(i=0;i<array.length;i++){\n  o[i] = arry[i];\n}\no.length = array.length;\nconsole.log(o);\t\t//{0: \"p\", 1: \"a\", length: 2}\n```\n\n但是在[jQuery](https://jquery.com/)里面，是通过数组的`push`方法来实现的  <copy>\n\n```js\nvar o = {};\nvar arry = ['p','a'];\nArray.prototype.push.apply(o,arry)\nconsole.log(o);   //{0: \"p\", 1: \"a\", length: 2}\n```\n\n> 原来apply的this指向的是数组，现在转换为对象","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"常见的封装","url":"%2F2017%2F08%2F23%2FJS--%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%81%E8%A3%85%2F","content":"\n\n\n## 命名空间（用对象的方式模拟）\n\n首先用对象字面量的方式创建一个命名空间\n\n```js\nvar Game = {};\n```\n\n添加模块，可以将相同功能或者属性的归类\n\n```js\nGame.module1 = {name:'p',m:function(){}};\n```\n<!--more-->\n然后调用这个模块\n\n```js\nGame.module1.m(); \n```\n\n可以用立即执行函数把这个命名空间包裹起来，这样可以减少变量冲突\n\n## 伪类\n\njs没有块作用域，有函数作用域，把方法和属性卸载函数里面，可以减少变量冲突\n\n对于构造器函数，包含实例化属性，自身属性，继承属性 <copy>\n\n```js\nfunction Person(name) {\n    this.name = name;  \t\t\t  //实例化属性\n    this.public = function () {    //实例化属性\n        console.log('this指向实例化的对象')  \n    };\n    function private() {\n        console.log('这是私有的方法')  //自身属性\n    }\n}\nPerson.prototype = {     //继承属性\n  my:function () {\n      console.log('这是可以继承方法')   \n  }\n};\n```\n\n然后通过`new`实现继承 <copy>\n\n```js\nvar man = new Person('PETER');\nconsole.log(man.name);   \t\t//PETER\nconsole.log(man.public());  \t//this指向实例化的对象\nconsole.log(man.my());          //这是可以继承方法\nconsole.log(man.private());     //Uncaught TypeError\n```\n\n实际案例中，会用私有方法调用共有方法或者共有方法调用私有方法 <copy>\n\n```js\nfunction Person(name) {\n    this.name = name;\n    function pm() {\n        console.log(this.name)  //输出实例化对象的name\n    }\n    this.text = function () {\n        console.log('public method');\n        pm.call(this);  //绑定到是实例化的对象\n    }\n}\nthis.name = 1;\nvar man= new Person('peter');\nman.text();   //peter\n```\n\n## 采用对象工厂的方式\n\n核心思路：定义一个人对象，函数返回一个对象 <copy>\n```js\nfunction Person(name) {\n    function pm() {\n        console.log(self.name) \t//------→\n    }                           //      |\n    var self ={                 //  ←---|\n        name:name,\n        text:function () {\n            console.log('publick method');\n            pm();\n        }\n    };\n    return self;   //这个函数会返回一个对象，也就是实例化的对象继承了这个对象里面的属性\n}\nvar man = new Person('oe');\nman.text();\n```","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"继承","url":"%2F2017%2F08%2F22%2FJS--%E7%BB%A7%E6%89%BF%2F","content":"\n\n## 通过ES5的 `Object.create`实现\n\n### 创建父类\n\n```js\nfunction Parent() {\n}\nParent.prototype.headCount = 1;\nParent.prototype.eat = function () {\nconsole.log('eat')\n}\n```\n<!--more-->\n\n### 创建子类  <copy>\n\n```js\nfunction Children() {\n}\nChildren.prototype.language = 'javascript';\nChildren.prototype.work = function () {\n    console.log('work')\n}\n```\n\n### 建立关系，修正构造器 <copy>\n\n```js\nChildren.prototype = Object.create(Parent.prototype);\nChildren.prototype.constructor = Children;\n```\n\n### 调整顺序 <copy>\n\n```js\n//父类\nfunction Parent() {\n}\nParent.prototype.headCount = 1;\nParent.prototype.eat = function () {\n    console.log('eat')\n};\n//关联修正，调整顺序\nChildren.prototype = Object.create(Parent.prototype);\nChildren.prototype.constructor = Children;\n//子类\nfunction Children() {\n}\nChildren.prototype.language = 'javascript';\nChildren.prototype.work = function () {\n    console.log('work')\n};\n```\n## 自己写一个函数\n\n步骤也是先定义父类和子类，然后建立关系，修正顺序，不过建立关系函数有所变化 <copy>\n\n```js\nfunction creatEx(c,p) {\n    function F() {}\n    F.prototype = p.prototype;\n    c.prototype = new F();\n    c.prototype.constructor = c;\n}\n```\n\n> 对于函数的关联，思路是把`c.prototype`和`p.prototype`连接起来，然后通过new实例化c产生的对象久可以同时使用c和p的方法和属性\n\n## 如果子类要访问父类中的动态变量，比如`this.name`，改如何解决？ <copy>\n\n```js\nfunction Parent(name) {\n    this.name = name\n}\nfunction Children(name) {\n\tParent.apply(this,arguments)  //调用Parent，同时this绑定为该Children函数\n}\n```\n\n![9ddcbfc21a1fbda1c58de.png](https://miao.su/images/2018/02/09/9ddcbfc21a1fbda1c58de.png)","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"原型继承","url":"%2F2017%2F08%2F22%2FJS-JS%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%2F","content":"\n\n## JS的原型继承\n在js中，要想创建一个对象，不是通过实例化，而是通过**选择一个对象作为原型去克隆它**来达到目的。\n而且对象只能克隆函数对象里面的`prototype`属性，既是`Function.prototye`，由于只有函数才有`prototype`对象，所以，想要创建一个对象，就必须要用函数才能创建，这个函数通常被称为构造器函数。来看一下普通对象和函数对象的创建：\n```js\nvar cat= {};\nfunction demo(){}\n```\n对于`cat`，只是普通对象，是通过`Object`函数构造的,所以克隆了`Object`函数的`prototype`\n```\ncat == (克隆) Object.prototype\n```\n对于`demo`，是函数对象，比较高级，因为：\n+ 它通过`Function`函数构造，克隆了`Function`函数的`prototype`\n+ 同时，自己又是一个函数，也有自己的`prootype`，可以当作构造器被其他对象克隆\n\n```html\ndemo == (克隆) Function.prototype\n```\n重点来了，函数的`prototype`，是一个对象，那么这个对象也是从其他对象克隆过来的\n在`js`中，克隆根原型是`null`，其次是`Object.prototype`，也就是说，**js所有的对象，都是通过`Object.prototype`克隆而来的**\n![](https://miao.su/images/2018/07/04/proto91beb.jpg)\n上面这张图充分解释了js的原型继承概念，可以分几部去总结：\n+ 普通对象克隆了`Object.prototype`，函数对象克隆了`Function.prototype`\n+ `Object.prototype`的`Object`函数，它也克隆了`Function.prototype`\n+ `Function`对象克隆了自己的`prototype`\n+ `Function.prototype`这个对象，反过来克隆了`Object`函数的`Object.prototype`，所以最终的根克隆对象，其实就是`Object.prototype`，在它上面，是一个`null`，没有任何克隆的内容\n\n```js\n  console.log(Object.getPrototypeOf(Object)== Function.prototype);  //ture\n  console.log(Object.getPrototypeOf(Function.prototype)== Object.prototype);     //ture\n  console.log(Object.getPrototypeOf(Function)== Function.prototype);     //ture\n  console.log(Object.getPrototypeOf(Object.prototype)== null); //ture\n```\n\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"arguments和重载","url":"%2F2017%2F08%2F21%2FJS--arguments%2F","content":"\n函数被调用的时候，会接收两个附加参数，`this`和`arguments`。\n\n`arguments`是一个对象。当`arguments`（实参）和`parameters`（形参）的个数不匹配时，不会导致错误，多余的实参会被忽略。  <copy>\n\n```js\nfunction cat(a,b) {\n    console.log(cat.length); \t\t//函数的形参个数\n    console.log(arguments.length);   //函数的实参个数\n}\n```\n\n## 重载\n\n比如要实现一个求和的函数   <copy>\n\n```js\nfunction add() {\n  var ad = 0;\n  for(var i=0;i<arguments.length;i++){\n    ad += arguments[i];\n  }\n}\nadd(1,2,3); //6\n```\n## 当实参类型不一样时候的处理\n\n假设有一段`p`标签。同时改变字体颜色大小等书写  <copy>\n\n```js\nfunction change() {\n  var  ele = document.getElementsByClassName('text')[0];\n  //如果时对象类型\n  if(typeof arguments[0] == 'object'){\n    for(key in arguments[0]){\n      ele.style[key] = arguments[0][key]\n    }\n  }else{\n    ele.style.fontSize = arguments[0];\n    ele.style.backgroundColor = arguments[1];\n  }\n}\nchange('44px','red')\nchange({fontSize:'44px',backgroundColor:'green'})\n```\n\n\n> 当一个对象属性是动态值的时候，不能通过`.`访问，只能通过`[]`访问\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"对象的关联","url":"%2F2017%2F08%2F15%2FJS--%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E8%81%94%2F","content":"\nJS的数据类型有两种：\n\n+ 原始类型（string、boolean、number、null、undefined）\n+ 对象类型（object）\n<!--more-->\n\n## 对象之间的关联，可以通过`Object.creat()`来创建 <copy>\n\n```js\nvar foo = {\n  something:function(){\n    console.log('hello')\n  }\n};\nvar bar = Object.create(foo);\nbar.something(); //hello\n```\n\n`Object.create(...)`会创建一个新对象（bar）并把它关联到我们指定的对象（foo）\n\n>用这种方式关联对象，可以充分发挥Prototype机制的威力，同时避免不必要的麻烦（**比如使用new的构造函数调用会生成.prototype和.constructor引用**）\n\n## 解决旧IE无法使用`Object.creat()`的问题 <copy>\n\n```js\nif(!Object.creat){\n  Object.creat = function(o){\n    function F(){}\n    F.prototype = 0;\n    return new F();\n  };\n}\n```\n\n>  `Object.create(null)`会创建一个没有原型链的对象，这种特殊的空[[prototyepe]]对象被称为“字典”，他们完全不会受到原型链的干扰，因此特别适合用来**存储数据**\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"prototype 和 __proto__","url":"%2F2017%2F08%2F15%2FJS--prototype%20%E5%92%8C%20__proto__%2F","content":"\n##  关于`prototype`\n\n当一个新函数被创建时，会被赋予一个 `prototype`属性，这个属性是用来**存放继承特性**的地方\n**只有函数才有`prototype`**。\n\n```js\nvar Demo = function () {}\nconsole.log(Demo.prototype)  // {constructor: ƒ}\n```\n\n> 可以表示为 `Demo.prototype={constructor: ƒ}`\n\n因此我们可以对这个 `prototype`属性进行扩展，存放更多继承的特性，例如：\n\n```js\nDemo.prototype.call = function () {console.log('我是新增加的继承特性')};\nvar he = new Demo();  //Demo是构造器，he是构造函数，通过new连接\nhe.call();   //我是新增加的继承特性\n```\n\n> **但是要注意的是，因为是继承特性，如果直接调用**`Demo.call()`是不存在的\n>\n> **`Demo`函数不做继承的属性直接写，例如：`Demo.call = function(){}`**\n\n问题深入：JS是基于原型的语言\n\nJS中的对象都继承于`object.prototype`，所以，尽管JS实现了继承概念，但是单一的原型`object.prototype`未免丧失活力，因此JS提供了可以改变对象的原型，以达到继承属性的办法\n\n比如我们有一个Demo函数，其原型是`object.prototype`，现在，我们要改变他的原型以获得想要的属性\n\n```js\nvar obj = {name:2};       //定义一个我们想要继承的属性 ←--\nvar Demo = function () {};       //                  ↑\nDemo.prototype = obj;    //改变原型指向  -----------→ ↑\nvar he = new Demo();\t\nconsole.log(he.name)     //2   Demo原型成功指向了obj，大功告成\n```\n\n## 关于`__proto__`\n\n`__proto__`可以用于检测**构造该对象的构造器**的原型，听起来有点绕口，结合上面的例子\n\n```js\nvar obj = {name:2};       //定义一个我们想要继承的属性 ←--\nvar Demo = function () {};       //                  ↑\nDemo.prototype = obj;    //改变原型指向  -----------→ ↑\nvar he = new Demo();\t//he是构造函数，Demo是构造器\nconsole.log(he.__proto__)     //{name: 2}\n```\n\n`he.__proto_`刚好等于构造器Demo的原型，换一种写法就是`he.__proto_ = Demo.prototype`\n","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"关于闭包","url":"%2F2017%2F08%2F14%2FJS--%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%2F","content":"\n\n闭包就是能够读取其他函数内部变量的函数。\n\n> 在Js中，如果一个函数在另外一个函数中定义，那么这个函数会访问到父函数里面定义的成员，形成闭包。\n> ​或者说，一个函数能访问它被创建时所处的上下文环境，就是闭包。\n<!--more-->\n\n主要有三点：\n\n+ 他是**函数中的函数**（无论嵌套多少层）\n+ 无论他是在父函数**内部调用**还是被`return`出去**外部接收后调用**，都能记住原来父函数的词法环境\n\n\n```js\n//函数在内部被调用\nfunction f1() {\n  var a = 2;\n  function f2() {\n    console.log(a)  //2\n  }\n  f2();   //内部执行，严格来说不算闭包，是词法作用域的查找方式，从内到外\n}\n\n//函数在外部被调用\nfunction f1() {\n  var a = 2;\n  return function f2() {\n    console.log(a)  //\n  }\n}\nvar x = f1();   //此时x等于return出来的f2\nx();    //2   这就是闭包，函数在外部被调用，但是函数还能记住创建他的词法环境\n```\n\n## 闭包的作用\n\n##### 减少全局变量，延续生命周期\n\n  ```js\n  //函数在外部被调用\n  function f1() {\n      var a =1;  \t\t\t//a在函数作用域里面，不会污染全局变量\n      return function () {\n          console.log(a++)\n      }\n  }\n  var result = f1();\n  result();\n  ```\n\n##### 减少传递给函数的参数数量\n\n##### 封装\n\n### 使用闭包的注意点\n\n##### 对捕获的变量只是个引用，不是复制\n\n  ```js\n  function f1() {\n      var num = 1;\n      function f2() {\n          console.log(num)  //引用了num而不是复制\n      }\n      num++;\n      f2()\n  }\n  f1()   //2\n  ```\n\n##### 父函数每调用一次，会产生不同的闭包\n\n  ```js\n  function f1() {\n      var num = 1;\n      return function f2() {\n          num++;\n          console.log(num)\n      }\n  }\n  var result1 = f1(); \n  result1();  //2\n  result1();  //3\n\n  var result2 = f1();//result和result2虽然都是调用了f1,但是词法作用域是不相同的，不会互相影响\n  result2();  //2\n  result2();  //3\n  ```\n\n### 循环中问题\n\n  ```js\n  for(var i =1;i<3;i++){\n      console.log(i); //1,2      //能实时打印i\n      setTimeout(function () {   //回调函数\n          console.log(i); //3,3  //程序加载完才执行，所以是3\n      },1000)\n  }\n\n  //解决方案，利用立即执行函数和闭包将参数传递进去\n  for(var i =1;i<4;i++){\n    (function (id) {\n      setTimeout(function () {\n        console.log(id)\n      },1000)\n    })(i)\n  }\n  ```\n\n  假设有一个需求，有三个按钮，以此点击发出ajax请求\n\n  ```html\n  <button id=\"1\">1</button>\n  <button id=\"2\">2</button>\n  <button id=\"3\">3</button>\n  ```\n\n  ```js\n  for(var i =1;i<4;i++){\n      var btn = document.getElementById(i);\n      btn.onclick = function () {\n          alert(i);  //回调函数不会马上执行  //4\n      }\n  }\n  ```\n\n  我们期望依次弹出1，2，3，但是结果全是三个4\n\n  因为for没有快作用域，i暴露在全局之中，回调函数执行时，循环已经结束，此时i=4；\n\n  解决方案，使用闭包，或者用let代替var\n\n  ```js\n  for(var i =1;i<4;i++){\n      var btn = document.getElementById(i);\n      btn.onclick = (function (id) {   //这是父函数，\n          return function () {   //闭包函数\n              alert(id);  //函数持续引用父函数里面传递的参数，形成闭包\n          }\n      })(i);\n  }\n  ```\n\n  > 其实解决思路就是，在回调函数没有执行之前，把想要的参数传递进去，这就可以使用闭包，让回调函数里面的函数，用return函数的方式，引用外部父函数传递的形参\n  >\n  > 为什么要使用立即执行函数？是因为i参数改变时，立即执行函数才能把实时参数传递进去\n  >\n  > 每次循环的时候，父函数带着想要传递的参数立即执行，因为有闭包的存在，子函数依赖与父函数传递的参数，所以子函数就能正确引用每次循环不同的i值","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"JS的解析与执行过程","url":"%2F2017%2F08%2F13%2FJS--JS%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F","content":"\n\n\n在JS真正执行代码之前，会对代码有个预处理过程\n\n## 预处理阶段\n\n  + 首先创建**词法环境（这里是全局）**\n\n  + 把用**声明的方式**创建的函数和用**var定义的变量**扫描出来，把这些函数和变量的**名字**加到词法环境中（这里是全局）\n    ```js\n    // LexcialEnvironment (词法环境)\n    {\n        a:undefined,   //a是变量的名字，右边是值\n        f:对函数的引用,  //f是函数的名字，右边引用(函数声明的方式)\n        g:undefined     //g是函数的名字，右边引用(函数表达式创建的函数)\n    }\n    ```\n\n  > 声明函数 `function xx(){}`区别于函数表达式`var xx = function xx(){} `\n  >\n  > 用函数表达式创建的函数，在预处理阶段，函数名字也会被**加到词法环境**中，但是后面的值不会解析，返回`undefined`\n\n  -  处理**函数声明**有冲突，会**覆盖**\n\n    ```js\n    console.log(a);  //function a() {console.log(3);}\n    function a() {console.log(2);}\n    function a() {console.log(3);}\n    ```\n\n  -  处理**变量声明**有冲突，会**忽略**\n\n    ```js\n    console.log(a);  //function a() {console.log(3);}\n    function a() {console.log(2);}\n    function a() {console.log(3);}\n    var a = 2;   //因为处理变量a有冲突，规则是忽略\n\n    //可以把函数表达式也当作变量声明 var xx = function(){}\n    ```\n\n  >① **用var开头的变量或者函数都会被提升，加入到词法环境，值都是`undefined`**\n  >​② **`function a (){} `的形式，a被提升同时值是该函数引用**\n  >​③ **var 声明冲突会被忽略，function声明会覆盖**\n\n  ​\n\n## 执行阶段\n\n  + 在执行阶段就会真正赋值（无论原来值是变量还是函数，都会被覆盖）\n  + 如果碰到在词法环境中找不到的名字，则会报错","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"this的用法","url":"%2F2017%2F08%2F10%2FJS--this%E7%9A%84%E7%94%A8%E6%B3%95%2F","content":"\n\n\nJavaScript的 `this` 总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境\n\n除去不常用的` with` 和` eval` 的情况，具体到实际应用中， this 的指向大致可以分为以下 4种\n<!--more-->\n\n## 作为对象的方法调用\n\n  此时`this`指向该对象  <copy>\n\n  ```js\n  var obj = {\n    a: 1,\n    getA: function(){\n      alert ( this === obj ); // 输出：true\n      alert ( this.a ); // 输出: 1\n    }\n  };\n  obj.getA();\n  ```\n\n## 作为普通函数调用\n\n  指向全局对象，在浏览器的 JavaScript里，这个全局对象是 window 对象。  <copy>\n\n  ```js\n  window.name = 'globalName';\n  var getName = function(){\n  return this.name;\n  };\n  console.log( getName() ); // 输出：globalName\n  ```\n\n## 构造器调用\n\n  当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 指向返回的这个对象  <copy>\n\n  ```js\n  var Cat = function (name) {\n      this.name = name\n  };\n  var white = new Cat(p);\n  console.log(white.name) //p\n  ```\n\n## `call`或者`apply`调用\n\n  改变this的指向  <copy>\n\n  ```js\n  var cat = {\n      name:'p',\n      x:function () {\n          console.log(this.name)\n      }\n  };\n  var obj = {name:'o'};\n  cat.x.call(obj)  //o\n  ```\n\n  ​","tags":["JavaScript"],"categories":["JS出深入浅"]},{"title":"Gulp入门指南","url":"%2F2017%2F06%2F12%2FGulp--%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%2F","content":"\ngulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率\n<!--more-->\n\n### 1. 全局安装 gulp：\n\n```\n$ npm install --global gulp\n\n```\n\n### 2. 作为项目的开发依赖（devDependencies）安装：\n\n```\n$ npm install --save-dev gulp\n\n```\n\n### 3. 在项目根目录下创建一个名为 `gulpfile.js` 的文件：\n\n```javascript\nvar gulp = require('gulp');\n\ngulp.task('default', function() {\n  // 将你的默认的任务代码放在这\n});\n```\n\n### 4. 运行 gulp：\n\n```\n$ gulp\n\n```\n\n默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。\n\n想要单独执行特定的任务（task），请输入 `gulp <task> <othertask>`。","tags":["Gulp"],"categories":["Gulp使用参考"]},{"title":"Gulp的实例参考","url":"%2F2017%2F06%2F12%2FGulp--%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F","content":"\n\n## 基本插件的安装\n\nGulpJs的安装依赖nodejs，所以先安装nodejs\n\n打开nodejs里面的cmd文件，安装gulp全局变量\n\n```\nnpm install -g gulp\n```\n\n安装项目开发所需要的依赖项\n\n```\nnpm install --save-dev gulp\n```\n\n安装用来压缩js文件的插件\n\n```\nnpm install --save-dev gulp-uglify\n```\n\n安装用来压缩css文件的插件\n\n```\nnpm install --save-dev gulp-minify-css\n```\n\n解析less的插件\n\n```\nnpm install --save-dev gulp-less\n```\n\n安装用来合并的插件\n\n```\nnpm install --save-dev gulp-concat\n```\n\n用来检查js代码的插件\n\n```\nnpm install --save-dev gulp-jshint\n```\n\n用来重命名的插件\n\n\n```\nnpm install --save-dev gulp-rename\n```\n\n搭建服务器的插件\n\n```\nnpm install --save-dev gulp-connect\n```\n\n一起安装\n\n```\nnpm install --save-dev gulp gulp-uglify gulp-minify-css gulp-concat gulp-jshint gulp-rename\n```\n\n+ ### 在项目根目录下建一个以`gulpfile.js`命名的文本\n\n\n\n## 文件的压缩示例\n\n编辑根目录下的`gulifile.js`文件 <copy>\n\n```js\nvar gulp = require('gulp');  //定义依赖项\n\nconcat = require('gulp-concat');   //定义合并插件\n\nmincss = require('gulp-minify-css');   //定义压缩css的插件\nminjs = require('gulp-uglify');         //定义压缩js的插件\n\nrename = require('gulp-rename');//定义重命名插件\n\n//定义任务   第一个是任务名字，第二个是要执行哪些操作\ngulp.task('css', function() {\n    gulp.src(['css/*.css'])  //操作css文件夹中所有的css文件\n    // gulp.src(['css/a.css'.'css.b.css'])  //操作css文件夹中ab文件\n        .pipe(concat('min.css'))  //执行合并插件并给合并完成的插件起一个名字\n        .pipe(mincss())         //执行压缩插件\n        .pipe(rename({suffix:'.xianyu'}))//执行重命名插件\n        .pipe(gulp.dest('css1'))//把执行以上操作后的文件放在css1文件夹里面\n});\n\ngulp.task('js', function() {\n    gulp.src(['js/*.js'])  //操作js文件夹中所有的js文件\n    // gulp.src(['js/a.js'.'js.b.js'])  //操作js文件夹中ab文件\n        .pipe(concat('min.js'))  //执行合并插件并给合并完成的插件起一个名字\n        .pipe(minjs())         //执行压缩插件\n        .pipe(rename({suffix:'.xianyu'}))//执行重命名插件\n        .pipe(gulp.dest('js'))//把执行以上操作后的文件放在js文件夹里面\n});\n\ngulp.task('default',['css','js']);  //执行任务名为css的任务\n\n//自动执行压缩任务\ngulp.watch('css/*.css',['css']);   //如果css文件夹下任何一个css有变动，则执行名字为css的任务\ngulp.watch('js/*.js',['js']);      //如果js文件夹下任何一个js有变动，则执行名字为js的任务\n```\n\n运行 gulp：\n\n```\ngulp\n```\n\n## 实现热更新的例子 <copy>\n\n```js\nvar gulp = require('gulp');\nconcat = require('gulp-concat');            //定义合并插件\nless = require('gulp-less');                //定义less编译插件\nmincss = require('gulp-minify-css');        //定义压缩css的插件\nminjs = require('gulp-uglify');             //定义压缩js的插件\nsourcemaps = require('gulp-sourcemaps');    //定义sourcemaps\nconnect = require('gulp-connect');          //自动刷新服务\n\n\ngulp.task('Less', function () {\n    gulp.src('src/less/*.less')             //入口文件目录\n        .pipe(sourcemaps.init())\n        .pipe(less())                       //执行less\n        .pipe(concat('min.css'))            //合并文件\n        .pipe(mincss())                     //压缩css\n        .pipe(sourcemaps.write('./'))       //生成sourcemaps\n        .pipe(gulp.dest('dist/src/css'))    //出口目录\n});\n\ngulp.task('js', function() {\n    gulp.src(['src/js/*.js'])               //入口文件\n        .pipe(sourcemaps.init())\n        .pipe(concat('min.js'))             //合并文件\n        .pipe(minjs())                      //执行压缩插件\n        .pipe(sourcemaps.write('./'))       //生成sourcemaps\n        .pipe(gulp.dest('dist/src/js'))     //出口目录\n});\n\ngulp.task('html', function () {\n    gulp.src('./dist/*.html')\n        .pipe(connect.reload());\n});\n\n\ngulp.task('connect', function() {           //搭建服务器\n    connect.server({\n        root: 'dist',\n        livereload: true,\n        port:8080\n    });\n});\n\ngulp.task('default',['Less','js','connect','html']);         //执行任务\n\n//自动执行压缩任务\ngulp.watch('src/less/*.less',['Less']);     //监视less文件\ngulp.watch('src/js/*.js',['js']);           //监视js文件\ngulp.watch('dist/*.html',['html']);           //监视js文件\n```\n\n\n","tags":["Gulp"],"categories":["Gulp使用参考"]}]